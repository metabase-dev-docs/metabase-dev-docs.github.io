<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="A classy high-level Clojure library for defining application models and retrieving them from a DB" name="description" /><meta contents="noindex" name="robots" /><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{font-size:34px;display:inline;}h2.project-version{font-size:18px;margin-top:0;display:inline;margin-left:10px;}.toc-link{font-size:12px;margin-left:10px;color:#252519;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{font-size:34px;margin:0;}.docs-header{border-bottom:dotted #aaa 1px;padding-bottom:10px;margin-bottom:25px;}.toc h1{font-size:24px;}.toc{border-bottom:solid #bbb 1px;margin-bottom:40px;}.toc ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.toc li{list-style-type:none;padding-left:0;}.dependencies{}.dependencies table{font-size:16px;width:99.99%;border:none;margin-left:20px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{border-right:none;color:transparent;background-color:transparent;noshade:noshade;border-left:none;border-top:none;margin-bottom:-6px;height:0;border-bottom:dotted #bbb 1px;}.dependencies .dep-version{text-align:right;}.plugins ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.plugins li{list-style-type:none;padding-left:0;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;top:10px;right:20px;height:20px;overflow:hidden;text-align:right;}#floating-toc li{list-style-type:none;margin:0;padding:0;}</style><style type="text/css">body{margin:0;padding:0;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;font-size:16px;color:#252519;background-color:#F5F5FF;}h1{font-size:20px;margin-top:0;}h2{font-size:18px;}h3{font-size:16px;}a.anchor{text-decoration:none;color:#252519;}a.anchor:hover{color:#5050A6;}table{border-spacing:0;border-bottom:solid #ddd 1px;;margin-bottom:10px;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{width:410px;max-width:410px;vertical-align:top;margin:0px;padding-left:55px;padding-right:20px;border:none;background-color:#FFF;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{vertical-align:top;font-size:10pt;overflow:hidden;background-color:#F5F5FF;width:55%;border-left:solid #E5E5EE 1px;padding-left:20px;border:none;margin:0px;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{background-color:ghostWhite;border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript">/*! jQuery v1.7.1 jquery.com | jquery.org/license */
(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cv(a){if(!ck[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){cl||(cl=c.createElement("iframe"),cl.frameBorder=cl.width=cl.height=0),b.appendChild(cl);if(!cm||!cl.createElement)cm=(cl.contentWindow||cl.contentDocument).document,cm.write((c.compatMode==="CSS1Compat"?"<!doctype html>":"")+"<html><body>"),cm.close();d=cm.createElement(a),cm.body.appendChild(d),e=f.css(d,"display"),b.removeChild(cl)}ck[a]=e}return ck[a]}function cu(a,b){var c={};f.each(cq.concat.apply([],cq.slice(0,b)),function(){c[this]=a});return c}function ct(){cr=b}function cs(){setTimeout(ct,0);return cr=f.now()}function cj(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ci(){try{return new a.XMLHttpRequest}catch(b){}}function cc(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function cb(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function ca(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bE.test(a)?d(a,e):ca(a+"["+(typeof e=="object"||f.isArray(e)?b:"")+"]",e,c,d)});else if(!c&&b!=null&&typeof b=="object")for(var e in b)ca(a+"["+e+"]",b[e],c,d);else d(a,b)}function b_(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function b$(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bT,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=b$(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=b$(a,c,d,e,"*",g));return l}function bZ(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bP),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function bC(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?bx:by,g=0,h=e.length;if(d>0){if(c!=="border")for(;g<h;g++)c||(d-=parseFloat(f.css(a,"padding"+e[g]))||0),c==="margin"?d+=parseFloat(f.css(a,c+e[g]))||0:d-=parseFloat(f.css(a,"border"+e[g]+"Width"))||0;return d+"px"}d=bz(a,b,b);if(d<0||d==null)d=a.style[b]||0;d=parseFloat(d)||0;if(c)for(;g<h;g++)d+=parseFloat(f.css(a,"padding"+e[g]))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+e[g]+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+e[g]))||0);return d+"px"}function bp(a,b){b.src?f.ajax({url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bf,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)}function bo(a){var b=c.createElement("div");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||"").toLowerCase();b==="input"?bm(a):b!=="script"&&typeof a.getElementsByTagName!="undefined"&&f.grep(a.getElementsByTagName("input"),bm)}function bm(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bk(a,b){var c;if(b.nodeType===1){b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase();if(c==="object")b.outerHTML=a.outerHTML;else if(c!=="input"||a.type!=="checkbox"&&a.type!=="radio"){if(c==="option")b.selected=a.defaultSelected;else if(c==="input"||c==="textarea")b.defaultValue=a.defaultValue}else a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value);b.removeAttribute(f.expando)}}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c+(i[c][d].namespace?".":"")+i[c][d].namespace,i[c][d],i[c][d].data)}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function U(a){var b=V.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+"defer",e=b+"queue",g=b+"mark",h=f._data(a,d);h&&(c==="queue"||!f._data(a,e))&&(c==="mark"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b==="data"&&f.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(k,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNumeric(d)?parseFloat(d):j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,n=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,q=/(?:^|:|,)(?:\s*\[)+/g,r=/(webkit)[ \/]([\w.]+)/,s=/(opera)(?:.*version)?[ \/]([\w.]+)/,t=/(msie) ([\w.]+)/,u=/(mozilla)(?:.*? rv:([\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+"").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.7.1",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),"slice",F.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").off("ready")}},bindReady:function(){if(!A){A=e.Callbacks("once memory");if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",B,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",B),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a&&typeof a=="object"&&"setInterval"in a},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,"constructor")&&!D.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,"@").replace(p,"]").replace(q,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,"ms-").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?"":G.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h){var i=a.length;if(typeof c=="object"){for(var j in c)e.access(a,j,c[j],f,g,d);return a}if(d!==b){f=!h&&f&&e.isFunction(d);for(var k=0;k<i;k++)g(a[k],c,f?d.call(a[k],k,g(a[k],c)):d,h);return a}return i?g(a[0],c):b},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf("compatible")<0&&u.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){I["[object "+b+"]"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener("DOMContentLoaded",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h==="array"?m(g):h==="function"&&(!a.unique||!o.has(g))&&c.push(g)},n=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,l=j||0,j=0,k=c.length;for(;c&&l<k;l++)if(c[l].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}i=!1,c&&(a.once?e===!0?o.disable():c=[]:d&&d.length&&(e=d.shift(),o.fireWith(e[0],e[1])))},o={add:function(){if(c){var a=c.length;m(arguments),i?k=c.length:e&&e!==!0&&(j=a,n(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){i&&f<=k&&(k--,f<=l&&l--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&o.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(i?a.once||d.push([b,c]):(!a.once||!e)&&n(b,c));return this},fire:function(){o.fireWith(this,arguments);return this},fired:function(){return!!e}};return o};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks("once memory"),c=f.Callbacks("once memory"),d=f.Callbacks("memory"),e="pending",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[b,"reject"],progress:[c,"notify"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+"With"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+"With"]=g[j].fireWith;i.done(function(){e="resolved"},c.disable,d.lock).fail(function(){e="rejected"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p,q=c.createElement("div"),r=c.documentElement;q.setAttribute("className","t"),q.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=q.getElementsByTagName("*"),e=q.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=q.getElementsByTagName("input")[0],b={leadingWhitespace:q.firstChild.nodeType===3,tbody:!q.getElementsByTagName("tbody").length,htmlSerialize:!!q.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:q.className!=="t",enctype:!!c.createElement("form").enctype,html5Clone:c.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0},i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete q.test}catch(s){b.deleteExpando=!1}!q.addEventListener&&q.attachEvent&&q.fireEvent&&(q.attachEvent("onclick",function(){b.noCloneEvent=!1}),q.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),b.radioValue=i.value==="t",i.setAttribute("checked","checked"),q.appendChild(i),k=c.createDocumentFragment(),k.appendChild(q.lastChild),b.checkClone=k.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,k.removeChild(i),k.appendChild(q),q.innerHTML="",a.getComputedStyle&&(j=c.createElement("div"),j.style.width="0",j.style.marginRight="0",q.style.width="2px",q.appendChild(j),b.reliableMarginRight=(parseInt((a.getComputedStyle(j,null)||{marginRight:0}).marginRight,10)||0)===0);if(q.attachEvent)for(o in{submit:1,change:1,focusin:1})n="on"+o,p=n in q,p||(q.setAttribute(n,"return;"),p=typeof q[n]=="function"),b[o+"Bubbles"]=p;k.removeChild(q),k=g=h=j=q=i=null,f(function(){var a,d,e,g,h,i,j,k,m,n,o,r=c.getElementsByTagName("body")[0];!r||(j=1,k="position:absolute;top:0;left:0;width:1px;height:1px;margin:0;",m="visibility:hidden;border:0;",n="style='"+k+"border:5px solid #000;padding:0;'",o="<div "+n+"><div></div></div>"+"<table "+n+" cellpadding='0' cellspacing='0'>"+"<tr><td></td></tr></table>",a=c.createElement("div"),a.style.cssText=m+"width:0;height:0;position:static;top:0;margin-top:"+j+"px",r.insertBefore(a,r.firstChild),q=c.createElement("div"),a.appendChild(q),q.innerHTML="<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>",l=q.getElementsByTagName("td"),p=l[0].offsetHeight===0,l[0].style.display="",l[1].style.display="none",b.reliableHiddenOffsets=p&&l[0].offsetHeight===0,q.innerHTML="",q.style.width=q.style.paddingLeft="1px",f.boxModel=b.boxModel=q.offsetWidth===2,typeof q.style.zoom!="undefined"&&(q.style.display="inline",q.style.zoom=1,b.inlineBlockNeedsLayout=q.offsetWidth===2,q.style.display="",q.innerHTML="<div style='width:4px;'></div>",b.shrinkWrapBlocks=q.offsetWidth!==2),q.style.cssText=k+m,q.innerHTML=o,d=q.firstChild,e=d.firstChild,h=d.nextSibling.firstChild.firstChild,i={doesNotAddBorder:e.offsetTop!==5,doesAddBorderForTableAndCells:h.offsetTop===5},e.style.position="fixed",e.style.top="20px",i.fixedPosition=e.offsetTop===20||e.offsetTop===15,e.style.position=e.style.top="",d.style.overflow="hidden",d.style.position="relative",i.subtractsBorderForOverflowNotVisible=e.offsetTop===-5,i.doesNotIncludeMarginInBodyOffset=r.offsetTop!==j,r.removeChild(a),q=a=null,f.extend(b,i))});return b}();var j=/^(?:\{.*\}|\[.*\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c=="string",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c==="events";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h=null;if(typeof a=="undefined"){if(this.length){h=f.data(this[0]);if(this[0].nodeType===1&&!f._data(this[0],"parsedAttrs")){e=this[0].attributes;for(var i=0,j=e.length;i<j;i++)g=e[i].name,g.indexOf("data-")===0&&(g=f.camelCase(g.substring(5)),l(this[0],g,h[g]));f._data(this[0],"parsedAttrs",!0)}}return h}if(typeof a=="object")return this.each(function(){f.data(this,a)});d=a.split("."),d[1]=d[1]?"."+d[1]:"";if(c===b){h=this.triggerHandler("getData"+d[1]+"!",[d[0]]),h===b&&this.length&&(h=f.data(this[0],a),h=l(this[0],a,h));return h===b&&d[1]?this.data(d[0]):h}return this.each(function(){var b=f(this),e=[d[0],c];b.triggerHandler("setData"+d[1]+"!",e),f.data(this,a,c),b.triggerHandler("changeData"+d[1]+"!",e)})},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||"fx")+"mark",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||"fx";var d=c+"mark",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,"mark"))}},queue:function(a,b,c){var d;if(a){b=(b||"fx")+"queue",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e={};d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),f._data(a,b+".run",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+"queue "+b+".run",!0),n(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){typeof a!="string"&&(c=a,a="fx");if(c===b)return f.queue(this[0],a);return this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks("once memory"),!0))h++,l.add(m);m();return d.promise()}});var o=/[\n\t\r]/g,p=/\s+/,q=/\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,a,b,!0,f.attr)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,a,b,!0,f.prop)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(o," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(o," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.nodeName.toLowerCase()]||f.valHooks[this.type];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}if(g){c=f.valHooks[g.nodeName.toLowerCase()]||f.valHooks[g.type];if(c&&"get"in c&&(d=c.get(g,"value"))!==b)return d;d=g.value;return typeof d=="string"?d.replace(q,""):d==null?"":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type==="select-one";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,"optgroup"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute=="undefined")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&"set"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,""+d);return d}if(h&&"get"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;h<g;h++)e=d[h],e&&(c=f.propFix[e]||e,f.attr(a,e,""),a.removeAttribute(v?e:c),u.test(e)&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,"button"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,"button"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&"set"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&"get"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!=="":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.attrHooks.tabindex.set=w.set,f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===""&&(b="false"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype="encoding"),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\.]*)?(?:\.(.+))?$/,B=/\bhover(\.\S+)?\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,G=function(a){var b=F.exec(a);b&&(b[1]=(b[1]||"").toLowerCase(),b[3]=b[3]&&new RegExp("(?:^|\\s)"+b[3]+"(?:\\s|$)"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c["class"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,"mouseenter$1 mouseleave$1")};
f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(" ");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||"").split(".").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:G(g),namespace:n.join(".")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent("on"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||"")).split(" ");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp("(^|\\.)"+l.split(".").sort().join("\\.(?:.*\\.)?")+"(\\.|$)"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d==="**"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,["events","handle"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf("!")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)"):null,o=h.indexOf(":")<0?"on"+h:"";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,"events")||{})[c.type]&&f._data(m,"handle"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)&&o&&e[h]&&(h!=="focus"&&h!=="blur"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,"events")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=[],j,k,l,m,n,o,p,q,r,s,t;g[0]=c,c.delegateTarget=this;if(e&&!c.target.disabled&&(!c.button||c.type!=="click")){m=f(this),m.context=this.ownerDocument||this;for(l=c.target;l!=this;l=l.parentNode||this){o={},q=[],m[0]=l;for(j=0;j<e;j++)r=d[j],s=r.selector,o[s]===b&&(o[s]=r.quick?H(l,r.quick):m.is(s)),o[s]&&q.push(r);q.length&&i.push({elem:l,matches:q})}}d.length>e&&i.push({elem:this,matches:d.slice(e)});for(j=0;j<i.length&&!c.isPropagationStopped();j++){p=i[j],c.currentTarget=p.elem;for(k=0;k<p.matches.length&&!c.isImmediatePropagationStopped();k++){r=p.matches[k];if(h||!c.namespace&&!r.namespace||c.namespace_re&&c.namespace_re.test(r.namespace))c.data=r.data,c.handleObj=r,n=((f.event.special[r.origType]||{}).handle||r.handler).apply(p.elem,g),n!==b&&(c.result=n,n===!1&&(c.preventDefault(),c.stopPropagation()))}}return c.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,"form"))return!1;f.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=f.nodeName(c,"input")||f.nodeName(c,"button")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,"submit._submit",function(a){this.parentNode&&!a.isTrigger&&f.event.simulate("submit",this.parentNode,a,!0)}),d._submit_attached=!0)})},teardown:function(){if(f.nodeName(this,"form"))return!1;f.event.remove(this,"._submit")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")f.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),f.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate("change",this,a,!0))});return!1}f.event.add(this,"beforeactivate._change",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate("change",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,"._change");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a=="object"){typeof c!="string"&&(d=c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on.call(this,a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.type+"."+e.namespace:e.type,e.selector,e.handler);return this}if(typeof a=="object"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c=="function")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||"**",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,"**"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,"lastToggle"+a.guid)||0)%d;f._data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!="string"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d="sizcache"+(Math.random()+"").replace(".",""),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\/g,k=/\r\n/g,l=/\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(""),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]==="~"||w[0]==="+")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q="",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)==="[object Array]")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!=="\\"){g[1]=(g[1]||"").replace(j,""),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)==="\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],"");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e="";if(d){if(d===1||d===9){if(typeof a.textContent=="string")return a.textContent;if(typeof a.innerText=="string")return a.innerText.replace(k,"");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},"":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("parentNode",b,f,a,d,c)},"~":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("previousSibling",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(j,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,"")},TAG:function(a,b){return a[1].replace(j,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,"");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(j,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||n([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case"only":case"first":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k==="first")return!0;l=a;case"last":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case"nth":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":!f&&m.attr?d!=null:f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return"\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\[]*\])(?![^\(]*\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[r].source.replace(/\\(\d+)/g,q));var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(o.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var k=e,l=e.getAttribute("id"),n=l||d,p=e.parentNode,q=/^\s*[+~]/.test(b);l?n=n.replace(/'/g,"\\$&"):e.setAttribute("id",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll("[id='"+n+"'] "+b),f)}catch(r){}finally{l||k.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;o.order.splice(1,0,"CLASS"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var y=function(a,b,c){var d,e=[],f="",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,"");a=o.relative[a]?a+"*":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[":"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\[\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.POS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),"not",a)},filter:function(a){return this.pushStack(T(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling(a.parentNode.firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V="abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp("<(?:"+V+")","i"),bd=/checked\s*(?:[^=]|=\s*.checked.)/i,be=/\/(java|ecma)script/i,bf=/^\s*<!(?:\[CDATA\[|\-\-)/,bg={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){if(f.isFunction(a))return this.each(function(b){var c=f(this);c.text(a.call(this,b,c.text()))});if(typeof a!="object"&&a!==b)return this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a));return f.text(this)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function()
{for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){if(a===b)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(var c=0,d=this.length;c<d;c++)this[c].nodeType===1&&(f.cleanData(this[c].getElementsByTagName("*")),this[c].innerHTML=a)}catch(e){this.empty().append(a)}}else f.isFunction(a)?this.each(function(b){var c=f(this);c.html(a.call(this,b,c.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,bp)}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j=="string"&&j.length<512&&i===c&&j.charAt(0)==="<"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||!bc.test("<"+a.nodeName)?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g;b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);var h=[],i;for(var j=0,k;(k=a[j])!=null;j++){typeof k=="number"&&(k+="");if(!k)continue;if(typeof k=="string")if(!_.test(k))k=b.createTextNode(k);else{k=k.replace(Y,"<$1></$2>");var l=(Z.exec(k)||["",""])[1].toLowerCase(),m=bg[l]||bg._default,n=m[0],o=b.createElement("div");b===c?bh.appendChild(o):U(b).appendChild(o),o.innerHTML=m[1]+k+m[2];while(n--)o=o.lastChild;if(!f.support.tbody){var p=$.test(k),q=l==="table"&&!p?o.firstChild&&o.firstChild.childNodes:m[1]==="<table>"&&!p?o.childNodes:[];for(i=q.length-1;i>=0;--i)f.nodeName(q[i],"tbody")&&!q[i].childNodes.length&&q[i].parentNode.removeChild(q[i])}!f.support.leadingWhitespace&&X.test(k)&&o.insertBefore(b.createTextNode(X.exec(k)[0]),o.firstChild),k=o.childNodes}var r;if(!f.support.appendChecked)if(k[0]&&typeof (r=k.length)=="number")for(i=0;i<r;i++)bn(k[i]);else bn(k);k.nodeType?h.push(k):h=f.merge(h,k)}if(d){g=function(a){return!a.type||be.test(a.type)};for(j=0;h[j];j++)if(e&&f.nodeName(h[j],"script")&&(!h[j].type||h[j].type.toLowerCase()==="text/javascript"))e.push(h[j].parentNode?h[j].parentNode.removeChild(h[j]):h[j]);else{if(h[j].nodeType===1){var s=f.grep(h[j].getElementsByTagName("script"),g);h.splice.apply(h,[j+1,0].concat(s))}d.appendChild(h[j])}}return h},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bq=/alpha\([^)]*\)/i,br=/opacity=([^)]*)/,bs=/([A-Z]|^ms)/g,bt=/^-?\d+(?:px)?$/i,bu=/^-?\d/,bv=/^([\-+])=([\-+.\de]+)/,bw={position:"absolute",visibility:"hidden",display:"block"},bx=["Left","Right"],by=["Top","Bottom"],bz,bA,bB;f.fn.css=function(a,c){if(arguments.length===2&&c===b)return this;return f.access(this,a,c,!0,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)})},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=bz(a,"opacity","opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=bv.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(bz)return bz(a,c)},swap:function(a,b,c){var d={};for(var e in b)d[e]=a.style[e],a.style[e]=b[e];c.call(a);for(e in b)a.style[e]=d[e]}}),f.curCSS=f.css,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){var e;if(c){if(a.offsetWidth!==0)return bC(a,b,d);f.swap(a,bw,function(){e=bC(a,b,d)});return e}},set:function(a,b){if(!bt.test(b))return b;b=parseFloat(b);if(b>=0)return b+"px"}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return br.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?"alpha(opacity="+b*100+")":"",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bq,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bq.test(g)?g.replace(bq,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){var c;f.swap(a,{display:"inline-block"},function(){b?c=bz(a,"margin-right","marginRight"):c=a.style.marginRight});return c}})}),c.defaultView&&c.defaultView.getComputedStyle&&(bA=function(a,b){var c,d,e;b=b.replace(bs,"-$1").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===""&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b)));return c}),c.documentElement.currentStyle&&(bB=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f===null&&g&&(e=g[b])&&(f=e),!bt.test(f)&&bu.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b==="fontSize"?"1em":f||0,f=g.pixelLeft+"px",g.left=c,d&&(a.runtimeStyle.left=d));return f===""?"auto":f}),bz=bA||bB,f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)});var bD=/%20/g,bE=/\[\]$/,bF=/\r?\n/g,bG=/#.*$/,bH=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bI=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bJ=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bK=/^(?:GET|HEAD)$/,bL=/^\/\//,bM=/\?/,bN=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bO=/^(?:select|textarea)/i,bP=/\s+/,bQ=/([?&])_=[^&]*/,bR=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bS=f.fn.load,bT={},bU={},bV,bW,bX=["*/"]+["*"];try{bV=e.href}catch(bY){bV=c.createElement("a"),bV.href="",bV=bV.href}bW=bR.exec(bV.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bS)return bS.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bN,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bO.test(this.nodeName)||bI.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bF,"\r\n")}}):{name:b.name,value:c.replace(bF,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?b_(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b_(a,b);return a},ajaxSettings:{url:bV,isLocal:bJ.test(bW[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bX},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bZ(bT),ajaxTransport:bZ(bU),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?cb(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=cc(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks("once memory"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bH.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bG,"").replace(bL,bW[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bP),d.crossDomain==null&&(r=bR.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bW[1]&&r[2]==bW[2]&&(r[3]||(r[1]==="http:"?80:443))==(bW[3]||(bW[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),b$(bT,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bK.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bM.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bQ,"$1_="+x);d.url=y+(y===d.url?(bM.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bX+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=b$(bU,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)ca(g,a[g],c,e);return d.join("&").replace(bD,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var cd=f.now(),ce=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+cd++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=b.contentType==="application/x-www-form-urlencoded"&&typeof b.data=="string";if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(ce.test(b.url)||e&&ce.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(ce,l),b.url===j&&(e&&(k=k.replace(ce,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var cf=a.ActiveXObject?function(){for(var a in ch)ch[a](0,1)}:!1,cg=0,ch;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ci()||cj()}:ci,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,cf&&delete ch[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n),m.text=h.responseText;try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cg,cf&&(ch||(ch={},f(a).unload(cf)),ch[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var ck={},cl,cm,cn=/^(?:toggle|show|hide)$/,co=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,cp,cq=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cr;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(cu("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),e===""&&f.css(d,"display")==="none"&&f._data(d,"olddisplay",cv(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(cu("hide",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,"display"),e!=="none"&&!f._data(d,"olddisplay")&&f._data(d,"olddisplay",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(cu("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]),h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(!f.support.inlineBlockNeedsLayout||cv(this.nodeName)==="inline"?this.style.display="inline-block":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)j=new f.fx(this,b,i),h=a[i],cn.test(h)?(o=f._data(this,"toggle"+i)||(h==="toggle"?d?"show":"hide":0),o?(f._data(this,"toggle"+i,o==="show"?"hide":"show"),j[o]()):j[h]()):(k=co.exec(h),l=j.cur(),k?(m=parseFloat(k[2]),n=k[3]||(f.cssNumber[i]?"":"px"),n!=="px"&&(f.style(this,i,(m||1)+n),l=(m||1)/j.cur()*l,f.style(this,i,l+n)),k[1]&&(m=(k[1]==="-="?-1:1)*m+l),j.custom(l,m,n)):j.custom(l,h,""));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(".run")===b.length-4&&h(this,g,b);else g[b=a+".run"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:cu("show",1),slideUp:cu("hide",1),slideToggle:cu("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a,b,c,d){return c+d*a},swing:function(a,b,c,d){return(-Math.cos(a*Math.PI)/2+.5)*d+c}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cr||cs(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?"":"px"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){e.options.hide&&f._data(e.elem,"fxshow"+e.prop)===b&&f._data(e.elem,"fxshow"+e.prop,e.start)},h()&&f.timers.push(h)&&!cp&&(cp=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,"fxshow"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,"fxshow"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cr||cs(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){h.style["overflow"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,"fxshow"+b,!0),f.removeData(h,"toggle"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(cp),cp=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(["width","height"],function(a,b){f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)}}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?f.fn.offset=function(a){var b=this[0],c;if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);try{c=b.getBoundingClientRect()}catch(d){}var e=b.ownerDocument,g=e.documentElement;if(!c||!f.contains(g,b))return c?{top:c.top,left:c.left}:{top:0,left:0};var h=e.body,i=cy(e),j=g.clientTop||h.clientTop||0,k=g.clientLeft||h.clientLeft||0,l=i.pageYOffset||f.support.boxModel&&g.scrollTop||h.scrollTop,m=i.pageXOffset||f.support.boxModel&&g.scrollLeft||h.scrollLeft,n=c.top+l-j,o=c.left+m-k;return{top:n,left:o}}:f.fn.offset=function(a){var b=this[0];if(a)return this.each(function(b){f.offset.setOffset(this,a,b)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return f.offset.bodyOffset(b);var c,d=b.offsetParent,e=b,g=b.ownerDocument,h=g.documentElement,i=g.body,j=g.defaultView,k=j?j.getComputedStyle(b,null):b.currentStyle,l=b.offsetTop,m=b.offsetLeft;while((b=b.parentNode)&&b!==i&&b!==h){if(f.support.fixedPosition&&k.position==="fixed")break;c=j?j.getComputedStyle(b,null):b.currentStyle,l-=b.scrollTop,m-=b.scrollLeft,b===d&&(l+=b.offsetTop,m+=b.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(b.nodeName))&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),e=d,d=b.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&c.overflow!=="visible"&&(l+=parseFloat(c.borderTopWidth)||0,m+=parseFloat(c.borderLeftWidth)||0),k=c}if(k.position==="relative"||k.position==="static")l+=i.offsetTop,m+=i.offsetLeft;f.support.fixedPosition&&k.position==="fixed"&&(l+=Math.max(h.scrollTop,i.scrollTop),m+=Math.max(h.scrollLeft,i.scrollLeft));return{top:l,left:m}},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each(["Left","Top"],function(a,c){var d="scroll"+c;f.fn[d]=function(c){var e,g;if(c===b){e=this[0];if(!e)return null;g=cy(e);return g?"pageXOffset"in g?g[a?"pageYOffset":"pageXOffset"]:f.support.boxModel&&g.document.documentElement[d]||g.document.body[d]:e[d]}return this.each(function(){g=cy(this),g?g.scrollTo(a?f(g).scrollLeft():c,a?c:f(g).scrollTop()):this[d]=c})}}),f.each(["Height","Width"],function(a,c){var d=c.toLowerCase();f.fn["inner"+c]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,d,"padding")):this[d]():null},f.fn["outer"+c]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,d,a?"margin":"border")):this[d]():null},f.fn[d]=function(a){var e=this[0];if(!e)return a==null?null:this;if(f.isFunction(a))return this.each(function(b){var c=f(this);c[d](a.call(this,b,c[d]()))});if(f.isWindow(e)){var g=e.document.documentElement["client"+c],h=e.document.body;return e.document.compatMode==="CSS1Compat"&&g||h&&h["client"+c]||g}if(e.nodeType===9)return Math.max(e.documentElement["client"+c],e.body["scroll"+c],e.documentElement["scroll"+c],e.body["offset"+c],e.documentElement["offset"+c]);if(a===b){var i=f.css(e,d),j=parseFloat(i);return f.isNumeric(j)?j:i}return this.css(d,typeof a=="string"?a:a+"px")}}),a.jQuery=a.$=f,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return f})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script><title>T2: Toucan 2 -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name">T2: Toucan 2</h1><h2 class="project-version">0.0.1-SNAPSHOT</h2><br /><p>A classy high-level Clojure library for defining application models and retrieving them from a DB</p>
</div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#toucan2.connection">toucan2.connection</a></li><li><a href="#toucan2.core">toucan2.core</a></li><li><a href="#toucan2.delete">toucan2.delete</a></li><li><a href="#toucan2.execute">toucan2.execute</a></li><li><a href="#toucan2.honeysql2">toucan2.honeysql2</a></li><li><a href="#toucan2.insert">toucan2.insert</a></li><li><a href="#toucan2.instance">toucan2.instance</a></li><li><a href="#toucan2.jdbc">toucan2.jdbc</a></li><li><a href="#toucan2.jdbc.connection">toucan2.jdbc.connection</a></li><li><a href="#toucan2.jdbc.mysql-mariadb">toucan2.jdbc.mysql-mariadb</a></li><li><a href="#toucan2.jdbc.options">toucan2.jdbc.options</a></li><li><a href="#toucan2.jdbc.pipeline">toucan2.jdbc.pipeline</a></li><li><a href="#toucan2.jdbc.postgres">toucan2.jdbc.postgres</a></li><li><a href="#toucan2.jdbc.query">toucan2.jdbc.query</a></li><li><a href="#toucan2.jdbc.read">toucan2.jdbc.read</a></li><li><a href="#toucan2.jdbc.result-set">toucan2.jdbc.result-set</a></li><li><a href="#toucan2.jdbc.row">toucan2.jdbc.row</a></li><li><a href="#toucan2.log">toucan2.log</a></li><li><a href="#toucan2.model">toucan2.model</a></li><li><a href="#toucan2.pipeline">toucan2.pipeline</a></li><li><a href="#toucan2.protocols">toucan2.protocols</a></li><li><a href="#toucan2.query">toucan2.query</a></li><li><a href="#toucan2.realize">toucan2.realize</a></li><li><a href="#toucan2.save">toucan2.save</a></li><li><a href="#toucan2.select">toucan2.select</a></li><li><a href="#toucan2.tools.after">toucan2.tools.after</a></li><li><a href="#toucan2.tools.after-insert">toucan2.tools.after-insert</a></li><li><a href="#toucan2.tools.after-select">toucan2.tools.after-select</a></li><li><a href="#toucan2.tools.after-update">toucan2.tools.after-update</a></li><li><a href="#toucan2.tools.before-delete">toucan2.tools.before-delete</a></li><li><a href="#toucan2.tools.before-insert">toucan2.tools.before-insert</a></li><li><a href="#toucan2.tools.before-select">toucan2.tools.before-select</a></li><li><a href="#toucan2.tools.before-update">toucan2.tools.before-update</a></li><li><a href="#toucan2.tools.compile">toucan2.tools.compile</a></li><li><a href="#toucan2.tools.debug">toucan2.tools.debug</a></li><li><a href="#toucan2.tools.default-fields">toucan2.tools.default-fields</a></li><li><a href="#toucan2.tools.disallow">toucan2.tools.disallow</a></li><li><a href="#toucan2.tools.hydrate">toucan2.tools.hydrate</a></li><li><a href="#toucan2.tools.identity-query">toucan2.tools.identity-query</a></li><li><a href="#toucan2.tools.named-query">toucan2.tools.named-query</a></li><li><a href="#toucan2.tools.simple-out-transform">toucan2.tools.simple-out-transform</a></li><li><a href="#toucan2.tools.transformed">toucan2.tools.transformed</a></li><li><a href="#toucan2.tools.with-temp">toucan2.tools.with-temp</a></li><li><a href="#toucan2.types">toucan2.types</a></li><li><a href="#toucan2.update">toucan2.update</a></li><li><a href="#toucan2.util">toucan2.util</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.connection" name="toucan2.connection"><h1 class="project-name">toucan2.connection</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h4>Connection Resolution</h4>

<p>The rules for determining which connection to use are as follows. These are tried in order until one returns
non-nil:</p>

<ol>
<li><p>The connectable specified in the function arguments.</p></li>
<li><p>The [[toucan2.connection/<em>current-connectable</em>]], if bound. This is bound automatically when
using [[with-connection]] or [[with-transaction]]</p></li>
<li><p>The [[toucan2.model/default-connectable]] for the model resolved from the <code>modelable</code> in the function arguments;</p></li>
<li><p>The <code>:default</code> implementation of [[toucan2.connection/do-with-connection]]</p></li>
</ol>

<p>You can define a 'named' connectable such as <code>::db</code> by adding an implementation
of [[toucan2.connection/do-with-connection]], or use things like JDBC URL connection strings or [[clojure.java.jdbc]]
connection properties maps directly.</p>

<p>IMPORTANT CAVEAT! Positional connectables will be used in preference to [[<em>current-connectable</em>]], even when it was
bound by [[with-transaction]] -- this means your query will run OUTSIDE of the current transaction! Sometimes, this is
what you want, because maybe a certain query is meant to run against a different database! Usually, however, it is
not! So in that case you can either do something like</p>

<p>```clj
(t2/query (or conn/<em>current-connectable</em> ::my-db) ...)
```</p>

<p>to use the current connection if it exists, or define your named connectable method like</p>

<p>```clj
(m/defmethod conn/do-with-connection ::my-db
  [_connectable f]
  (conn/do-with-connection
   (if (and conn/<em>current-connectable</em>
            (not= conn/<em>current-connectable</em> ::my-db))
       conn/<em>current-connectable</em>
       "jdbc:postgresql://...")
   f))
```</p>

<p>This, however, is super annoying! So I might reconsider this behavior in the future.</p>

<p>For reducible queries, the connection is not resolved until the query is executed, so you may create a reducible query
with no default connection available and execute it later with one bound. (This also means
that [[toucan2.execute/reducible-query]] does not capture dynamic bindings such
as [[toucan2.connection/<em>current-connectable</em>]] -- you probably wouldn't want it to, anyway, since we have no
guarantees and open connection will be around when we go to use the reducible query later.</p>

<p>The default JDBC implementations for methods here live in [[toucan2.jdbc.connection]].</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.connection
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [pretty.core :as pretty]
   [toucan2.log :as log]
   [toucan2.protocols :as protocols]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment types/keep-me)</pre></td></tr><tr><td class="docs"><p>The current connectable or connection. If you get a connection with [[with-connection]] or [[with-transaction]], it
will be bound here. You can also bind this yourself to a connectable or connection, and Toucan methods called without
an explicit will connectable will use it rather than the <code>:default</code> connection.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *current-connectable*
  nil)</pre></td></tr><tr><td class="docs"><p>Take a <em>connectable</em>, get a connection of some sort from it, and execute <code>(f connection)</code> with an open connection. A
normal implementation might look something like:</p>

<p>```clj
(m/defmethod t2.conn/do-with-connection ::my-connectable
  [_connectable f]
  (with-open [conn (get-connection)]
    (f conn)))
```</p>

<p>Another common use case is to define a 'named' connectable that acts as an alias for another more complicated
connectable, such as a JDBC connection string URL. You can do that like this:</p>

<p>```clj
(m/defmethod t2.conn/do-with-connection ::a-connectable
  [_connectable f]
  (t2.conn/do-with-connection
   "jdbc:postgresql://localhost:5432/toucan2?user=cam&amp;password=cam"
   f))
```</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti do-with-connection
  {:arglists            '([connectable f])
   :defmethod-arities   #{2}
   :dispatch-value-spec ::types/dispatch-value.keyword-or-class}
  u/dispatch-on-first-arg
  :default-value ::default)</pre></td></tr><tr><td class="docs"><p>Wrap functions as passed to [[do-with-connection]] or [[do-with-transaction]] in a way that
binds [[<em>current-connectable</em>]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn- bind-current-connectable-fn
  [f]
  {:pre [(fn? f)]}
  (^:once fn* [conn]
   (binding [*current-connectable* conn]
     (f conn))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod do-with-connection :around ::default
  &quot;Do some debug logging/context capture. Bind [[*current-connectable*]] to the connection `f` is called with inside of
  `f`.&quot;
  [connectable f]
  (assert (fn? f))
  ;; add the connection class or pretty representation rather than the connection type itself to avoid leaking sensitive
  ;; creds
  (let [connectable-class (if (instance? pretty.core.PrettyPrintable connectable)
                            (pretty/pretty connectable)
                            (protocols/dispatch-value connectable))]
    (log/debugf &quot;Resolve connection %s&quot; connectable-class)
    (u/try-with-error-context [&quot;resolve connection&quot; {::connectable connectable-class}]
      (next-method connectable (bind-current-connectable-fn f)))))</pre></td></tr><tr><td class="docs"><p>Execute <code>body</code> with an open connection. There are three ways to use this.</p>

<p>With no args in the bindings vector, <code>with-connection</code> will use the <em>current connection</em> -- [[<em>current-connectable</em>]]
if one is bound, or the <em>default connectable</em> if not. See docstring for [[toucan2.connection]] for more information.</p>

<p>```clj
(t2/with-connection []
  ...)
```</p>

<p>With one arg, <code>with-connection</code> still uses the <em>current connection</em>, but binds it to something (<code>conn</code> in the example
below):</p>

<p>```clj
(t2/with-connection [conn]
  ...)
```</p>

<p>If you're using the default JDBC backend, <code>conn</code> will be an instance of <code>java.sql.Connection</code>. Since Toucan 2 is also
written to work with other backend besides JDBC, <code>conn</code> does <em>not</em> include <code>java.sql.Connection</code> <code>:tag</code> metadata! If
you're doing Java interop with <code>conn</code>, make sure to tag it yourself:</p>

<p>```clj
 (t2/with-connection [^java.sql.Connection conn]
   (let [metadata (.getMetaData conn)]
     ...))
```</p>

<p>With a connection binding <em>and</em> a connectable:</p>

<p>```clj
(t2/with-connection [conn ::my-connectable]
  ...)
```</p>

<p>This example gets a connection by calling [[do-with-connection]] with <code>::my-connectable</code>, ignoring the *current
connection*.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-connection
  {:arglists '([[connection-binding]             &amp; body]
               [[connection-binding connectable] &amp; body])}
  [[connection-binding connectable] &amp; body]
  `(do-with-connection
    ~connectable
    (^:once fn* with-connection* [~(or connection-binding '_)] ~@body)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef with-connection
  :args (s/cat :bindings (s/spec (s/cat :connection-binding (s/? symbol?)
                                        :connectable        (s/? any?)))
               :body (s/+ any?))
  :ret  any?)</pre></td></tr><tr><td class="docs"><p>method if this is called with something we don't know how to handle or if no default connection is defined. This is
separate from <code>:default</code> so if you implement <code>:default</code> you don't accidentally have that get called for unknown
connectables</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmethod do-with-connection ::default
  [connectable _f]
  (throw (ex-info (format &quot;Don't know how to get a connection from ^%s %s. Do you need to implement %s for %s?&quot;
                          (some-&gt; connectable class .getCanonicalName)
                          (pr-str connectable)
                          `do-with-connection
                          (protocols/dispatch-value connectable))
                  {:connectable connectable})))</pre></td></tr><tr><td class="docs"><p>method called if there is no current connection.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmethod do-with-connection :default
  [_connectable _f]
  (throw (ex-info (str &quot;No default Toucan connection defined. &quot;
                       (format &quot;You can define one by implementing %s for :default. &quot;
                               `do-with-connection)
                       (format &quot;You can also implement %s for a model, or bind %s.&quot;
                               'toucan2.model/default-connectable
                               `*current-connectable*))
                  {})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod do-with-connection nil
  &quot;`nil` means use the current connection.
  The difference between `nil` and using [[*current-connectable*]] directly is that this waits until it gets resolved
  by [[do-with-connection]] to get the value for [[*current-connectable*]]. For a reducible query this means you'll get
  the value at the time you reduce the query rather than at the time you build the reducible query.&quot;
  [_connectable f]
  (let [current-connectable (if (nil? *current-connectable*)
                              :default
                              *current-connectable*)]
    (do-with-connection current-connectable f)))</pre></td></tr><tr><td class="docs"><p>connection string support</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Extract the protocol part of a <code>connection-string</code>.</p>

<p>```clj
(connection-string-protocol "jdbc:postgresql:...")
=>
"jdbc"
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn connection-string-protocol
  [connection-string]
  (when (string? connection-string)
    (second (re-find #&quot;^(?:([^:]+):)&quot; connection-string))))</pre></td></tr><tr><td class="docs"><p>Implementation of [[do-with-connection]] for strings. Dispatches on the [[connection-string-protocol]] of the string,
e.g. <code>"jdbc"</code> for <code>"jdbc:postgresql://localhost:3000/toucan"</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti do-with-connection-string
  {:arglists            '([^java.lang.String connection-string f])
   :defmethod-arities   #{2}
   :dispatch-value-spec string?}
  (fn [connection-string _f]
    (connection-string-protocol connection-string)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod do-with-connection String
  &quot;Implementation for Strings. Hands off to [[do-with-connection-string]].&quot;
  [connection-string f]
  (do-with-connection-string connection-string f))</pre></td></tr><tr><td class="docs"><p>JDBC implementations live in [[toucan2.jdbc.connection]]</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p><code>options</code> are options for determining what type of transaction we'll get. See dox for [[with-transaction]] for more
information.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti do-with-transaction
  {:arglists            '([connection options f])
   :defmethod-arities   #{3}
   :dispatch-value-spec ::types/dispatch-value.keyword-or-class}
  u/dispatch-on-first-arg
  :default-value ::default)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod do-with-transaction :around ::default
  &quot;Bind [[*current-connectable*]] to the connection `f` is called with inside of `f`.&quot;
  [connection options f]
  (log/debugf &quot;do with transaction %s %s&quot; options (some-&gt; connection class .getCanonicalName symbol))
  (next-method connection options (bind-current-connectable-fn f)))</pre></td></tr><tr><td class="docs"><p>Gets a connection with [[with-connection]], and executes <code>body</code> within that transaction.</p>

<p>An <code>options</code> map, if specified, determine what sort of transaction we're asking for (stuff like the read isolation
level and what not). One key, <code>:nested-transaction-rule</code>, is handled directly in Toucan 2; other options are passed
directly to the underlying implementation, such as [[next.jdbc.transaction]].</p>

<p><code>:nested-transaction-rule</code> must be one of <code>#{:allow :ignore :prohibit}</code>, a set of possibilities borrowed from
<code>next.jdbc</code>. For non-JDBC implementations, you should treat <code>:allow</code> as the default behavior if unspecified.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-transaction
  {:style/indent 1, :arglists '([[conn-binding connectable options?] &amp; body])}
  [[conn-binding connectable options] &amp; body]
  `(with-connection [conn# ~connectable]
     (do-with-transaction conn# ~options (^:once fn* with-transaction* [~(or conn-binding '_)] ~@body))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def :toucan2.with-transaction-options/nested-transaction-rule
  (s/nilable #{:allow :ignore :prohibit}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::with-transaction-options
  (s/keys :opt-un [:toucan2.with-transaction-options/nested-transaction-rule]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef with-transaction
  :args (s/cat :bindings (s/spec (s/cat :connection-binding (s/? symbol?)
                                        :connectable        (s/? any?)
                                        :options            (s/? ::with-transaction-options)))
               :body (s/+ any?))
  :ret  any?)</pre></td></tr><tr><td class="docs"><p>JDBC implementation lives in [[toucan2.jdbc.connection]]</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.core" name="toucan2.core"><h1 class="project-name">toucan2.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Convenience namespace exposing the most common parts of the library's public API for day-to-day usage (i.e., not
implementing anything advanced)</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^:no-doc toucan2.core
  (:refer-clojure :exclude [compile count instance?])
  (:require
   [potemkin :as p]
   [toucan2.connection]
   [toucan2.delete]
   [toucan2.execute]
   [toucan2.honeysql2]
   [toucan2.insert]
   [toucan2.instance]
   [toucan2.jdbc]
   [toucan2.model]
   [toucan2.protocols]
   [toucan2.save]
   [toucan2.select]
   [toucan2.tools.after-insert]
   [toucan2.tools.after-select]
   [toucan2.tools.after-update]
   [toucan2.tools.before-delete]
   [toucan2.tools.before-insert]
   [toucan2.tools.before-select]
   [toucan2.tools.before-update]
   [toucan2.tools.compile]
   [toucan2.tools.debug]
   [toucan2.tools.default-fields]
   [toucan2.tools.hydrate]
   [toucan2.tools.named-query]
   [toucan2.tools.transformed]
   [toucan2.update]
   [toucan2.util]))</pre></td></tr><tr><td class="docs"><p>this is so no one gets confused and thinks these namespaces are unused.</p>
</td><td class="codes"><pre class="brush: clojure">(comment
  toucan2.connection/keep-me
  toucan2.delete/keep-me
  toucan2.execute/keep-me
  toucan2.honeysql2/keep-me
  toucan2.insert/keep-me
  toucan2.instance/keep-me
  toucan2.jdbc/keep-me
  toucan2.model/keep-me
  toucan2.protocols/keep-me
  toucan2.save/keep-me
  toucan2.select/keep-me
  toucan2.tools.after-insert/keep-me
  toucan2.tools.after-select/keep-me
  toucan2.tools.after-update/keep-me
  toucan2.tools.before-delete/keep-me
  toucan2.tools.before-insert/keep-me
  toucan2.tools.before-select/keep-me
  toucan2.tools.before-update/keep-me
  toucan2.tools.compile/keep-me
  toucan2.tools.debug/keep-me
  toucan2.tools.default-fields/keep-me
  toucan2.tools.hydrate/keep-me
  toucan2.tools.named-query/keep-me
  toucan2.tools.transformed/keep-me
  toucan2.update/keep-me
  toucan2.util/keep-me)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(p/import-vars
 [toucan2.connection
  do-with-connection
  with-connection
  with-transaction]

 [toucan2.delete
  delete!]

 [toucan2.execute
  query
  query-one
  reducible-query
  with-call-count]

 [toucan2.insert
  insert!
  insert-returning-instance!
  insert-returning-pk!
  insert-returning-instances!
  insert-returning-pks!]

 [toucan2.instance
  instance
  instance-of?
  instance?]

 [toucan2.model
  default-connectable
  primary-key-values-map
  primary-keys
  resolve-model
  select-pks-fn
  table-name]

 [toucan2.protocols
  changes
  current
  model
  original]

 [toucan2.save
  save!]

 [toucan2.select
  count
  exists?
  reducible-select
  select
  select-fn-&gt;fn
  select-fn-&gt;pk
  select-fn-reducible
  select-fn-set
  select-fn-vec
  select-one
  select-one-fn
  select-one-pk
  select-pk-&gt;fn
  select-pks-set
  select-pks-vec]

 [toucan2.tools.after-insert
  define-after-insert]

 [toucan2.tools.after-select
  define-after-select]

 [toucan2.tools.after-update
  define-after-update]

 [toucan2.tools.before-delete
  define-before-delete]

 [toucan2.tools.before-insert
  define-before-insert]

 [toucan2.tools.before-select
  define-before-select]

 [toucan2.tools.before-update
  define-before-update]

 [toucan2.tools.compile
  build
  compile]

 [toucan2.tools.debug
  debug]

 [toucan2.tools.default-fields
  define-default-fields]

 [toucan2.tools.hydrate
  batched-hydrate
  hydrate
  model-for-automagic-hydration
  simple-hydrate]

 [toucan2.tools.named-query
  define-named-query]

 [toucan2.tools.transformed
  deftransforms
  transforms]

 [toucan2.update
  reducible-update
  reducible-update-returning-pks
  update!
  update-returning-pks!])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.delete" name="toucan2.delete"><h1 class="project-name">toucan2.delete</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation of [[delete!]].</p>

<p>Code for building Honey SQL for DELETE lives in [[toucan2.honeysql2]]</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.delete
  (:require
   [toucan2.pipeline :as pipeline]))</pre></td></tr><tr><td class="docs"><p>Delete instances of a model that match <code>conditions</code> or a <code>queryable</code>. Returns the number of rows deleted.</p>

<p>```clj
;; delete a row by primary key
(t2/delete! :models/venues 1)</p>

<p>;; Delete all rows matching a condition
(t2/delete! :models/venues :name "Bird Store")
```</p>

<p>Allowed syntax is identical to [[toucan2.select/select]], including optional positional parameters like <code>:conn</code>;
see [[toucan2.query/parse-args]] and the <code>:toucan2.query/default-args</code> spec.</p>
</td><td class="codes"><pre class="brush: clojure">(defn delete!
  {:arglists '([modelable &amp; conditions? queryable?]
               [:conn connectable modelable &amp; conditions? queryable?])}
  [&amp; unparsed-args]
  (pipeline/transduce-unparsed-with-default-rf :toucan.query-type/delete.update-count unparsed-args))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.execute" name="toucan2.execute"><h1 class="project-name">toucan2.execute</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Code for executing queries and statements, and reducing their results.</p>

<p>The functions here meant for use on a regular basis are:</p>

<ul>
<li><p>[[query]] -- resolve and compile a connectable, execute it using a connection from a connectable, and immediately
           fully realize the results.</p></li>
<li><p>[[query-one]] -- like [[query]], but only realizes the first result.</p></li>
<li><p>[[reducible-query]] -- like [[query]], but returns a [[clojure.lang.IReduceInit]] that can be reduced later rather
than immediately realizing the results.</p></li>
<li><p>[[with-call-count]] -- helper macro to count the number of queries executed within a <code>body</code>.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.execute
  (:require
   [clojure.spec.alpha :as s]
   [toucan2.pipeline :as pipeline]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- query* [f]
  (fn query**
    ([queryable]
     ;; `nil` connectable = use the current connection or `:default` if none is specified.
     (query** nil queryable))
    ([connectable queryable]
     (query** connectable nil queryable))
    ([connectable modelable queryable]
     ;; by passing `result-type/*` we'll basically get whatever the default is -- instances for `SELECT` or update counts
     ;; for `DML` stuff.
     (query** connectable :toucan.result-type/* modelable queryable))
    ([connectable query-type modelable queryable]
     (let [parsed-args {:connectable connectable
                        :modelable   modelable
                        :queryable   queryable}]
       (f query-type parsed-args)))))</pre></td></tr><tr><td class="docs"><p>Create a reducible query that when reduced with resolve and compile <code>queryable</code>, open a connection using <code>connectable</code>
and [[toucan2.connection/with-connection]], execute the query, and reduce the results.</p>

<p>Note that this query can be something like a <code>SELECT</code> query, or something that doesn't normally return results, like
an <code>UPDATE</code>; this works either way. Normally something like an <code>UPDATE</code> will reduce to the number of rows
updated/inserted/deleted, e.g. <code>[5]</code>.</p>

<p>You can specify <code>modelable</code> to execute the query in the context of a specific model; for queries returning rows, the
rows will be returned as an [[toucan2.instance/instance]] of the resolved model.</p>

<p>See [[toucan2.connection]] for Connection resolution rules.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:arglists '([queryable]
                   [connectable queryable]
                   [connectable modelable queryable]
                   [connectable query-type modelable queryable])}
  reducible-query
  (query* pipeline/reducible-parsed-args))</pre></td></tr><tr><td class="docs"><p>Util functions for running queries and immediately realizing the results.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Like [[reducible-query]], but immediately executes and fully reduces the query.</p>

<p>```clj
(query ::my-connectable ["SELECT * FROM venues;"])
;; => [{:id 1, :name "Tempest"}
       {:id 2, :name "BevMo"}]
```</p>

<p>Like [[reducible-query]], this may be used with either <code>SELECT</code> queries that return rows or things like <code>UPDATE</code> that
normally return the count of rows updated.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:arglists '([queryable]
                   [connectable queryable]
                   [connectable modelable queryable]
                   [connectable query-type modelable queryable])}
  query
  (query*
   (fn [query-type parsed-args]
     (let [rf (pipeline/default-rf query-type)]
       (pipeline/transduce-parsed rf query-type parsed-args)))))</pre></td></tr><tr><td class="docs"><p>Like [[query]], and immediately executes the query, but realizes and returns only the first result.</p>

<p>```clj
(query-one ::my-connectable ["SELECT * FROM venues;"])
;; => {:id 1, :name "Tempest"}
```</p>

<p>Like [[reducible-query]], this may be used with either <code>SELECT</code> queries that return rows or things like <code>UPDATE</code> that
normally return the count of rows updated.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:arglists '([queryable]
                   [connectable queryable]
                   [connectable modelable queryable]
                   [connectable query-type modelable queryable])}
  query-one
  (query*
   (fn [query-type parsed-args]
     (let [rf    (pipeline/default-rf query-type)
           xform (pipeline/first-result-xform-fn query-type)]
       (pipeline/transduce-parsed (xform rf) query-type parsed-args)))))</pre></td></tr><tr><td class="docs"><p>[[with-call-count]]</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Impl for [[with-call-count]] macro; don't call this directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc do-with-call-counts
  [f]
  (let [call-count (atom 0)
        old-thunk  pipeline/*call-count-thunk*]
    (binding [pipeline/*call-count-thunk* (fn []
                                            (when old-thunk
                                              (old-thunk))
                                            (swap! call-count inc))]
      (f (fn [] @call-count)))))</pre></td></tr><tr><td class="docs"><p>Execute <code>body</code>, trackingthe number of database queries and statements executed. This number can be fetched at any
time within <code>body</code> by calling function bound to <code>call-count-fn-binding</code>:</p>

<p>```clj
(with-call-count [call-count]
  (select ...)
  (println "CALLS:" (call-count))
  (insert! ...)
  (println "CALLS:" (call-count)))
;; -> CALLS: 1
;; -> CALLS: 2
```</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-call-count
  [[call-count-fn-binding] &amp; body]
  `(do-with-call-counts (^:once fn* [~call-count-fn-binding] ~@body)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef with-call-count
  :args (s/cat :bindings (s/spec (s/cat :call-count-binding symbol?))
               :body     (s/+ any?))
  :ret any?)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.honeysql2" name="toucan2.honeysql2"><h1 class="project-name">toucan2.honeysql2</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.honeysql2
  (:require
   [better-cond.core :as b]
   [clojure.string :as str]
   [honey.sql :as hsql]
   [honey.sql.helpers :as hsql.helpers]
   [methodical.core :as m]
   [toucan2.instance :as instance]
   [toucan2.log :as log]
   [toucan2.model :as model]
   [toucan2.pipeline :as pipeline]
   [toucan2.query :as query]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs"><p>Default global options to pass to [[honey.sql/format]].</p>
</td><td class="codes"><pre class="brush: clojure">(defonce  global-options
  (atom {:quoted true, :dialect :ansi, :quoted-snake true}))</pre></td></tr><tr><td class="docs"><p>Option override when to pass to [[honey.sql/format]].</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *options*
  nil)</pre></td></tr><tr><td class="docs"><p>Get combined Honey SQL options for building and compiling queries by merging [[global-options]] and [[<em>options</em>]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn options
  []
  (merge @global-options
         *options*))</pre></td></tr><tr><td class="docs"><p>Building queries</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- fn-condition-&gt;honeysql-where-clause
  [k [f &amp; args]]
  {:pre [(keyword? f) (seq args)]}
  (into [f k] args))</pre></td></tr><tr><td class="docs"><p>Something sequential like <code>:id [:&gt; 5]</code> becomes <code>[:&gt; :id 5]</code>. Other stuff like <code>:id 5</code> just becomes <code>[:= :id 5]</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn condition-&gt;honeysql-where-clause
  [k v]
  ;; don't think there's any situation where `nil` on the LHS is on purpose and not a bug.
  {:pre [(some? k)]}
  (if (sequential? v)
    (fn-condition-&gt;honeysql-where-clause k v)
    [:= k v]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod query/apply-kv-arg [#_model :default #_query clojure.lang.IPersistentMap #_k :default]
  &quot;Apply key-value args to a Honey SQL 2 query map.&quot;
  [_model honeysql k v]
  (log/debugf &quot;apply kv-arg %s %s&quot; k v)
  (let [result (update honeysql :where (fn [existing-where]
                                         (:where (hsql.helpers/where existing-where
                                                                     (condition-&gt;honeysql-where-clause k v)))))]
    (log/tracef &quot;=&gt; %s&quot; result)
    result))</pre></td></tr><tr><td class="docs"><p>Build an Honey SQL <code>[table]</code> or <code>[table alias]</code> (if the model has a [[toucan2.model/namespace]] form) for <code>model</code> for
use in something like a <code>:select</code> clause.</p>
</td><td class="codes"><pre class="brush: clojure">(defn table-and-alias
  [model]
  (b/cond
    :let [table-id (keyword (model/table-name model))
          alias-id (model/namespace model)
          alias-id (when alias-id
                     (keyword alias-id))]
    alias-id
    [table-id alias-id]
    :else
    [table-id]))</pre></td></tr><tr><td class="docs"><p>Qualify the (plain keyword) columns in [model &amp; columns] forms with the model table name, unless they are already
qualified. This apparently doesn't hurt anything and prevents ambiguous column errors if you're joining another
column or something like that. I wasn't going to put this in at first since I forgot it existed, but apparently
Toucan 1 did it (despite not being adequately tested) so I decided to preserve this behavior going forward since I
can't see any downsides to it.</p>

<p>In Honey SQL 2 I think using keyword namespaces is the preferred way to qualify stuff, so we'll go that route
instead of using <code>:a.b</code> style qualification like we generated in Toucan 1.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- qualified? [column]
  (or (namespace column)
      (str/includes? (name column) &quot;.&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- maybe-qualify [column table]
  (cond
    (not (keyword? column)) column
    (qualified? column)     column
    :else                   (keyword (name table) (name column))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- maybe-qualify-columns [columns [table-id alias-id]]
  (let [table (or alias-id table-id)]
    (assert (keyword? table))
    (mapv #(maybe-qualify % table)
          columns)))</pre></td></tr><tr><td class="docs"><p>Should we splice in the default <code>:select</code> clause for this <code>honeysql-query</code>? Only splice in the default <code>:select</code> if we
don't have <code>:union</code>, <code>:union-all</code>, or <code>:select-distinct</code> in the resolved query.</p>
</td><td class="codes"><pre class="brush: clojure">(defn include-default-select?
  [honeysql-query]
  (every? (fn [k]
            (not (contains? honeysql-query k)))
          [:union :union-all :select :select-distinct]))</pre></td></tr><tr><td class="docs"><p>Should we splice in the default <code>:from</code> clause for this <code>honeysql-query</code>? Only splice in the default <code>:from</code> if we
don't have <code>:union</code> or <code>:union-all</code> in the resolved query. It doesn't make sense to do a <code>x UNION y</code> query and then
include <code>FROM</code> as well.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- include-default-from?
  [honeysql-query]
  (every? (fn [k]
            (not (contains? honeysql-query k)))
          [:union :union-all]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type     :default
                             #_model          :default
                             #_resolved-query clojure.lang.IPersistentMap]
  &quot;Base map backend implementation. Applies the `:kv-args` in `parsed-args` using [[query/apply-kv-args]], and ignores
  other parsed args.&quot;
  [query-type model {:keys [kv-args], :as parsed-args} m]
  (let [m (query/apply-kv-args model m kv-args)]
    (next-method query-type model (dissoc parsed-args :kv-args) m)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type :toucan.query-type/select.*
                             #_model      :default
                             #_query      clojure.lang.IPersistentMap]
  &quot;Build a Honey SQL 2 SELECT query.&quot;
  [query-type model {:keys [columns], :as parsed-args} resolved-query]
  (log/debugf &quot;Building SELECT query for %s with columns %s&quot; model columns)
  (let [parsed-args    (dissoc parsed-args :columns)
        table+alias    (table-and-alias model)
        resolved-query (-&gt; (merge
                            (when (include-default-select? resolved-query)
                              {:select (or (some-&gt; (not-empty columns) (maybe-qualify-columns table+alias))
                                           [:*])})
                            (when (and model
                                       (include-default-from? resolved-query))
                              {:from [table+alias]})
                            resolved-query)
                           (with-meta (meta resolved-query)))]
    (log/debugf &quot;=&gt; %s&quot; resolved-query)
    (next-method query-type model parsed-args resolved-query)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type :toucan.query-type/select.count
                             #_model      :default
                             #_query      clojure.lang.IPersistentMap]
  &quot;Build an efficient `count(*)` query to power [[toucan2.select/count]].&quot;
  [query-type model parsed-args resolved-query]
  (let [parsed-args (assoc parsed-args :columns [[:%count.* :count]])]
    (next-method query-type model parsed-args resolved-query)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type :toucan.query-type/select.exists
                             #_model      :default
                             #_query      clojure.lang.IPersistentMap]
  &quot;Build an efficient query like `SELECT exists(SELECT 1 FROM ...)` query to power [[toucan2.select/exists?]].&quot;
  [query-type model parsed-args resolved-query]
  (let [parsed-args (assoc parsed-args :columns [[[:inline 1]]])
        subselect   (next-method query-type model parsed-args resolved-query)]
    {:select [[[:exists subselect] :exists]]}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- empty-insert [_model dialect]
  (if (#{:mysql :mariadb} dialect)
    {:columns []
     :values  [[]]}
    {:values :default}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type :toucan.query-type/insert.*
                             #_model      :default
                             #_query      clojure.lang.IPersistentMap]
  &quot;Build a Honey SQL 2 INSERT query.
  if `rows` is just a single empty row then insert it with
  ```sql
  INSERT INTO table DEFAULT VALUES
  ```
  (Postgres/H2/etc.)
  or
  ```sql
  INSERT INTO table () VALUES ()
  ```
  (MySQL/MariaDB)&quot;
  [query-type model parsed-args resolved-query]
  (log/debugf &quot;Building INSERT query for %s&quot; model)
  (let [rows        (some (comp not-empty :rows) [parsed-args resolved-query])
        built-query (-&gt; (merge {:insert-into [(keyword (model/table-name model))]}
                               (if (= rows [{}])
                                 (empty-insert model (:dialect (options)))
                                 {:values (map (partial instance/instance model)
                                               rows)}))
                        (with-meta (meta resolved-query)))]
    (log/debugf &quot;=&gt; %s&quot; built-query)
    ;; rows is only added so we can get the default methods' no-op logic if there are no rows at all.
    (next-method query-type model (assoc parsed-args :rows rows) built-query)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type :toucan.query-type/update.*
                             #_model      :default
                             #_query      clojure.lang.IPersistentMap]
  &quot;Build a Honey SQL 2 UPDATE query.&quot;
  [query-type model {:keys [kv-args changes], :as parsed-args} conditions-map]
  (log/debugf &quot;Building UPDATE query for %s&quot; model)
  (let [parsed-args (assoc parsed-args :kv-args (merge kv-args conditions-map))
        built-query (-&gt; {:update (table-and-alias model)
                         :set    changes}
                        (with-meta (meta conditions-map)))]
    (log/debugf &quot;=&gt; %s&quot; built-query)
    ;; `:changes` are added to `parsed-args` so we can get the no-op behavior in the default method.
    (next-method query-type model (assoc parsed-args :changes changes) built-query)))</pre></td></tr><tr><td class="docs"><p>For building a SELECT query using the args passed to something like [[toucan2.update/update!]]. This is needed to
implement [[toucan2.tools.before-update]]. The main syntax difference is a map 'resolved-query' is supposed to be
treated as a conditions map for update instead of as a raw Honey SQL query.</p>

<p>TODO -- a conditions map should probably not be given a type of <code>clojure.lang.IPersistentMap</code> -- conditions maps
should be a separate map backend I think.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type :toucan.query-type/select.instances.from-update
                             #_model      :default
                             #_query      clojure.lang.IPersistentMap]
  &quot;Treat the resolved query as a conditions map but otherwise behave the same as the `:toucan.query-type/select.instances`
  impl.&quot;
  [query-type model parsed-args conditions-map]
  (next-method query-type model (update parsed-args :kv-args #(merge % conditions-map)) {}))</pre></td></tr><tr><td class="docs"><p>Build the correct <code>DELETE ... FROM ...</code> or <code>DELETE FROM ...</code> Honey SQL for the current <code>dialect</code> (see docstring for
build method below).</p>
</td><td class="codes"><pre class="brush: clojure">(defn- delete-from
  [table+alias dialect]
  (if (= (count table+alias) 1)
    {:delete-from table+alias}
    (let [[_table table-alias] table+alias]
      (if (#{:mysql :mariadb} dialect)
        {:delete table-alias
         :from   [table+alias]}
        {:delete-from table+alias}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type :toucan.query-type/delete.*
                             #_model      :default
                             #_query      clojure.lang.IPersistentMap]
  &quot;Build a Honey SQL 2 DELETE query.
  If the table for `model` should not be aliased (i.e., [[toucan2.model/namespace]] returns `nil`), builds a query that
  compiles to something like:
  ```sql
  DELETE FROM my_table
  WHERE ...
  ```
  If the table is aliased, this looks like
  ```sql
  DELETE FROM my_table AS t1
  WHERE ...
  ```
  for Postgres/H2/etc., or like
  ```sql
  DELETE t1
  FROM my_table AS t1
  WHERE ...
  ```
  for MySQL/MariaDB. MySQL/MariaDB does not seem to support aliases in `DELETE FROM`, so we need to use this alternative
  syntax; H2 doesn't support it however. So it has to be compiled differently based on the DB.&quot;
  [query-type model parsed-args resolved-query]
  (log/debugf &quot;Building DELETE query for %s&quot; model)
  (let [built-query (-&gt; (merge (delete-from (table-and-alias model) (:dialect (options)))
                               resolved-query)
                        (with-meta (meta resolved-query)))]
    (log/debugf &quot;=&gt; %s&quot; built-query)
    (next-method query-type model parsed-args built-query)))</pre></td></tr><tr><td class="docs"><p>Query compilation</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/compile [#_query-type :default
                               #_model      :default
                               #_query      clojure.lang.IPersistentMap]
  &quot;Compile a Honey SQL 2 map to [sql &amp; args].&quot;
  [query-type model honeysql]
  (let [options-map (options)
        _           (log/debugf &quot;Compiling Honey SQL 2 with options %s&quot; options-map)
        sql-args    (u/try-with-error-context [&quot;compile Honey SQL to SQL&quot; {::honeysql honeysql, ::options-map options-map}]
                      (hsql/format honeysql options-map))]
    (log/debugf &quot;=&gt; %s&quot; sql-args)
    (pipeline/compile query-type model sql-args)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.insert" name="toucan2.insert"><h1 class="project-name">toucan2.insert</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation of [[insert!]].</p>

<p>The code for building an INSERT query as Honey SQL lives in [[toucan2.honeysql2]]</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.insert
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.log :as log]
   [toucan2.pipeline :as pipeline]
   [toucan2.query :as query]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::kv-args
  (s/+ (s/cat
        :k keyword?
        :v any?)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::args.rows
  (s/alt :nil               nil?
         :single-row-map    map?
         :multiple-row-maps (s/spec (s/* map?))
         :kv-pairs          ::kv-args
         :columns-rows      (s/cat :columns (s/spec (s/+ keyword?))
                                   :rows    (s/spec (s/+ sequential?)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::args
  (s/cat
   :connectable       ::query/default-args.connectable
   :modelable         ::query/default-args.modelable
   :rows-or-queryable (s/alt :rows      ::args.rows
                             :queryable some?)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod query/parse-args :toucan.query-type/insert.*
  &quot;Default args parsing method for [[toucan2.insert/insert!]]. Uses the spec `:toucan2.insert/args`.&quot;
  [query-type unparsed-args]
  (let [parsed                               (query/parse-args-with-spec query-type ::args unparsed-args)
        [rows-queryable-type rows-queryable] (:rows-or-queryable parsed)
        parsed                               (select-keys parsed [:modelable :columns :connectable])]
    (case rows-queryable-type
      :queryable
      (assoc parsed :queryable rows-queryable)
      :rows
      (assoc parsed :rows (let [[rows-type x] rows-queryable]
                            (condp = rows-type
                              :nil               nil
                              :single-row-map    [x]
                              :multiple-row-maps x
                              :kv-pairs          [(into {} (map (juxt :k :v)) x)]
                              :columns-rows      (let [{:keys [columns rows]} x]
                                                   (map (partial zipmap columns)
                                                        rows))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- can-skip-insert? [parsed-args resolved-query]
  (and (empty? (:rows parsed-args))
       ;; don't try to optimize out stuff like identity query.
       (or (and (map? resolved-query)
                (empty? (:rows resolved-query)))
           (nil? resolved-query))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type     :toucan.query-type/insert.*
                             #_model          :default
                             #_resolved-query :default]
  &quot;Default INSERT query method. No-ops if there are no `:rows` to insert in either `parsed-args` or `resolved-query`.&quot;
  [query-type model parsed-args resolved-query]
  (let [rows (some (comp not-empty :rows) [parsed-args resolved-query])]
    (if (can-skip-insert? parsed-args resolved-query)
      (do
        (log/debugf &quot;Query has no changes, skipping update&quot;)
        ::pipeline/no-op)
      (do
        (log/debugf &quot;Inserting %s rows into %s&quot; (if (seq rows) (count rows) &quot;?&quot;) model)
        (next-method query-type model parsed-args resolved-query)))))</pre></td></tr><tr><td class="docs"><p>Insert a row or rows into the database. Returns the number of rows inserted.</p>

<p>This function is pretty flexible in what it accepts:</p>

<p>Insert a single row with key-value args:</p>

<p>```clj
(t2/insert! :models/venues :name "Grant &amp; Green", :category "bar")
```</p>

<p>Insert a single row as a map:</p>

<p>```clj
(t2/insert! :models/venues {:name "Grant &amp; Green", :category "bar"})
```</p>

<p>Insert multiple row maps:</p>

<p>```clj
(t2/insert! :models/venues [{:name "Grant &amp; Green", :category "bar"}
                            {:name "Savoy Tivoli", :category "bar"}])
```</p>

<p>Insert rows with a vector of column names and a vector of value maps:</p>

<p>```clj
(t2/insert! :models/venues [:name :category] [["Grant &amp; Green" "bar"]
                                              ["Savoy Tivoli" "bar"]])
```</p>

<p>As with other Toucan 2 functions, you can optionally pass a connectable if you pass <code>:conn</code> as the first arg. Refer to
the <code>:toucan2.insert/args</code> spec for the complete syntax.</p>

<p>Named connectables can also be used to define the rows:</p>

<p>```clj
(t2/define-named-query ::named-rows
  {:rows [{:name "Grant &amp; Green", :category "bar"}
          {:name "North Beach Cantina", :category "restaurant"}]})</p>

<p>(t2/insert! :models/venues ::named-rows)
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn insert!
  {:arglists '([modelable row-or-rows-or-queryable]
               [modelable k v &amp; more]
               [modelable columns row-vectors]
               [:conn connectable modelable row-or-rows]
               [:conn connectable modelable k v &amp; more]
               [:conn connectable modelable columns row-vectors])}
  [&amp; unparsed-args]
  (pipeline/transduce-unparsed-with-default-rf :toucan.query-type/insert.update-count unparsed-args))</pre></td></tr><tr><td class="docs"><p>Like [[insert!]], but returns a vector of the primary keys of the newly inserted rows rather than the number of rows
inserted. The primary keys are determined by [[model/primary-keys]]. For models with a single primary key, this
returns a vector of single values, e.g. <code>[1 2]</code> if the primary key is <code>:id</code> and you've inserted rows 1 and 2; for
composite primary keys this returns a vector of tuples where each tuple has the value of corresponding primary key as
returned by [[model/primary-keys]], e.g. for composite PK <code>[:id :name]</code> you might get <code>[[1 "Cam"] [2 "Sam"]]</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn insert-returning-pks!
  {:arglists '([modelable row-or-rows-or-queryable]
               [modelable k v &amp; more]
               [modelable columns row-vectors]
               [:conn connectable modelable row-or-rows]
               [:conn connectable modelable k v &amp; more]
               [:conn connectable modelable columns row-vectors])}
  [&amp; unparsed-args]
  (pipeline/transduce-unparsed-with-default-rf :toucan.query-type/insert.pks unparsed-args))</pre></td></tr><tr><td class="docs"><p>Like [[insert-returning-pks!]], but for one-row insertions. For models with a single primary key, this returns just the
new primary key as a scalar value (e.g. <code>1</code>). For models with a composite primary key, it will return a single tuple
as determined by [[model/primary-keys]] (e.g. <code>[1 "Cam"]</code>).</p>
</td><td class="codes"><pre class="brush: clojure">(defn insert-returning-pk!
  {:arglists '([modelable row-or-rows-or-queryable]
               [modelable k v &amp; more]
               [modelable columns row-vectors]
               [:conn connectable modelable row-or-rows]
               [:conn connectable modelable k v &amp; more]
               [:conn connectable modelable columns row-vectors])}
  [&amp; unparsed-args]
  (first (apply insert-returning-pks! unparsed-args)))</pre></td></tr><tr><td class="docs"><p>Like [[insert!]], but returns a vector of maps representing the inserted objects.</p>
</td><td class="codes"><pre class="brush: clojure">(defn insert-returning-instances!
  {:arglists '([modelable-columns row-or-rows-or-queryable]
               [modelable-columns k v &amp; more]
               [modelable-columns columns row-vectors]
               [:conn connectable modelable-columns row-or-rows]
               [:conn connectable modelable-columns k v &amp; more]
               [:conn connectable modelable-columns columns row-vectors])}
  [&amp; unparsed-args]
  (pipeline/transduce-unparsed-with-default-rf :toucan.query-type/insert.instances unparsed-args))</pre></td></tr><tr><td class="docs"><p>Like [[insert-returning-instances!]], but for one-row insertions. Returns the inserted object as a map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn insert-returning-instance!
  {:arglists '([modelable row-or-rows-or-queryable]
               [modelable k v &amp; more]
               [modelable columns row-vectors]
               [:conn connectable modelable row-or-rows]
               [:conn connectable modelable k v &amp; more]
               [:conn connectable modelable columns row-vectors])}
  [&amp; unparsed-args]
  (first (apply insert-returning-instances! unparsed-args)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.instance" name="toucan2.instance"><h1 class="project-name">toucan2.instance</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Toucan 2 instances are a custom map type that does two things regular maps do not do:</p>

<ol>
<li><p>They are associated with a particular model; [[toucan2.protocols/model]] can be used to get it. This is usually set
when the instance comes out of that database.</p></li>
<li><p>They track their [[toucan2.protocols/original]] version when they come out of the application database. This can in
turn be used to calculate the [[toucan2.protocols/changes]] that have been made, which powers features
like [[toucan2.save/save!]].</p></li>
</ol>

<p>Normally a Toucan instance is considered equal to a plain map with the same
current (via [[toucan2.protocols/current]]) value. It is considered equal to other instances if they have the same
current value and their model is the same.</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.instance
  (:refer-clojure :exclude [instance?])
  (:require
   [potemkin :as p]
   [pretty.core :as pretty]
   [toucan2.protocols :as protocols]
   [toucan2.realize :as realize]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>For debugging purposes: whether to print the original version of an instance, in addition to the current version, when
printing an [[instance]].</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *print-original*
  false)</pre></td></tr><tr><td class="docs"><p>True if <code>x</code> is a Toucan2 instance, i.e. a <code>toucan2.instance.Instance</code> or some other class that satisfies the correct
interfaces.</p>

<p>Toucan instances need to implement [[protocols/IModel]], [[protocols/IWithModel]], and [[protocols/IRecordChanges]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn instance?
  [x]
  (every? #(clojure.core/instance? % x)
          [toucan2.protocols.IModel
           toucan2.protocols.IWithModel
           toucan2.protocols.IRecordChanges]))</pre></td></tr><tr><td class="docs"><p>True if <code>x</code> is a Toucan2 instance, and its [[protocols/model]] <code>isa?</code> <code>model</code>.</p>

<p>```clj
(instance-of? ::bird (instance ::toucan {})) ; -> true
(instance-of? ::toucan (instance ::bird {})) ; -> false
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn instance-of?
  [model x]
  (and (instance? x)
       (isa? (protocols/model x) model)))</pre></td></tr><tr><td class="docs"><p>Changes between <code>orig</code> and <code>m</code>. Unlike [[clojure.data/diff]], this is a shallow diff. Only columns that are added or
modified should be returned.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- changes*
  [original current]
  (if (or (not (map? original))
          (not (map? current)))
    current
    (not-empty
     (into
      (empty original)
      (map (fn [k]
             (let [original-value (get original k ::not-found)
                   current-value  (get current k)]
               (when-not (= original-value current-value)
                 [k current-value]))))
      (keys current)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare -&gt;TransientInstance)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(p/def-map-type Instance [model
                          ^clojure.lang.IPersistentMap orig
                          ^clojure.lang.IPersistentMap m
                          mta]
  (get [_ k default-value]
    (get m k default-value))
  (assoc [this k v]
    (let [m' (assoc m k v)]
      (if (identical? m m')
        this
        (Instance. model orig m' mta))))
  (dissoc [this k]
    (let [m' (dissoc m k)]
      (if (identical? m m')
        this
        (Instance. model orig m' mta))))
  (keys [_this]
    (keys m))
  (meta [_this]
    mta)
  (with-meta [this new-meta]
    (if (identical? mta new-meta)
      this
      (Instance. model orig m new-meta)))
  clojure.lang.IPersistentCollection
  (cons [this o]
    (cond
      (map? o)
      (reduce #(apply assoc %1 %2) this o)
      (clojure.core/instance? java.util.Map o)
      (reduce
       #(apply assoc %1 %2)
       this
       (into {} o))
      :else
      (if-let [[k v] (seq o)]
        (assoc this k v)
        this)))
  (equiv [_this another]
    (cond
      (clojure.core/instance? toucan2.protocols.IModel another)
      (and (= model (protocols/model another))
           (= m another))
      (map? another)
      (= m another)
      :else
      false))
  (empty [_this]
    (Instance. model (empty orig) (empty m) mta))
  java.util.Map
  (containsKey [_this k]
    (.containsKey m k))
  clojure.lang.IEditableCollection
  (asTransient [_this]
    (-&gt;TransientInstance model (transient m) mta))
  protocols/IModel
  (protocols/model [_this]
    model)
  protocols/IWithModel
  (with-model [this new-model]
    (if (= model new-model)
      this
      (Instance. new-model orig m mta)))
  protocols/IRecordChanges
  (original [_this]
    orig)
  (with-original [this new-original]
    (if (identical? orig new-original)
      this
      (let [new-original (if (nil? new-original)
                           {}
                           new-original)]
        (assert (map? new-original))
        (Instance. model new-original m mta))))
  (current [_this]
    m)
  (with-current [this new-current]
    (if (identical? m new-current)
      this
      (let [new-current (if (nil? new-current)
                          {}
                          new-current)]
        (assert (map? new-current))
        (Instance. model orig new-current mta))))
  (changes [_this]
    (not-empty (changes* orig m)))
  protocols/IDispatchValue
  (dispatch-value [_this]
    (protocols/dispatch-value model))
  realize/Realize
  (realize [_this]
    (if (identical? orig m)
      (let [m (realize/realize m)]
        (Instance. model m m mta))
      (Instance. model (realize/realize orig) (realize/realize m) mta)))
  pretty/PrettyPrintable
  (pretty [_this]
    (if *print-original*
      (list `instance model (symbol &quot;#_&quot;) orig m)
      (list `instance model m))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype ^:no-doc TransientInstance [model ^clojure.lang.ITransientMap m mta]
  clojure.lang.ITransientMap
  (conj [this v]
    (let [m' (conj! m v)]
      (if (identical? m m')
        this
        (TransientInstance. model m' mta))))
  (persistent [_this]
    (let [m (persistent! m)]
      (Instance. model m m mta)))
  (assoc [this k v]
    (let [m' (assoc! m k v)]
      (if (identical? m m')
        this
        (TransientInstance. model m' mta))))
  (without [this k]
    (let [m' (dissoc! m k)]
      (if (identical? m m')
        this
        (TransientInstance. model m' mta))))
  (valAt [_this k]
    (.valAt m k))
  (valAt [_this k not-found]
    (.valAt m k not-found))
  (count [_this]
    (count m))
  clojure.lang.Associative
  (containsKey [_this k]
    (contains? m k))
  pretty/PrettyPrintable
  (pretty [_this]
    (list `-&gt;TransientInstance model m mta)))</pre></td></tr><tr><td class="docs"><p>Create a new Toucan 2 instance. See the namespace docstring for [[toucan2.instance]] for more information about <em>what</em>
a Toucan 2 instance is.</p>

<p>This function has several arities:</p>

<ul>
<li><p>With no args, creates an empty instance with its <em>model</em> set to <code>nil</code></p></li>
<li><p>With one arg, creates an empty instance of a <em>model</em>.</p></li>
<li><p>With two args, creates an instance of a <em>model</em> from an existing map. This is optimized: if the map is already an
instance of the model, returns the map as-is.</p></li>
<li><p>With three or more args, creates an instance of a <em>model</em> with key-value args.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn instance
  (^toucan2.instance.Instance []
   (instance nil))
  (^toucan2.instance.Instance [model]
   (instance model {}))
  (^toucan2.instance.Instance [model m]
   (assert ((some-fn map? nil?) m)
           (format &quot;Expected a map or nil, got ^%s %s&quot; (.getCanonicalName (class m)) (pr-str m)))
   (cond
     ;; optimization: if `m` is already an instance with `model` return it as-is.
     (and (instance? m)
          (= (protocols/model m) model))
     m
     ;; DISABLED FOR NOW BECAUSE MAYBE THE OTHER MODEL HAS A DIFFERENT UNDERLYING EMPTY MAP OR KEY TRANSFORM
     ;;
     ;; ;; optimization 2: if `m` is an instance of something else use [[protocols/with-model]]
     ;; (instance? m)
     ;; (protocols/with-model m model)
     ;; Strip any customizations, e.g. a different underlying empty map or key transform.
     (u/custom-map? m)
     (let [m* (into {} m)]
       (-&gt;Instance model m* m* (meta m)))
     :else
     (-&gt;Instance model m m (meta m))))
  (^toucan2.instance.Instance [model k v &amp; more]
   (let [m (into {} (partition-all 2) (list* k v more))]
     (instance model m))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol protocols/IWithModel
  nil
  (with-model [_this model]
    (instance model))

  clojure.lang.IPersistentMap
  (with-model [m model]
    (instance model m)))</pre></td></tr><tr><td class="docs"><p>Return a copy of <code>an-instance</code> with its <code>original</code> value set to its current value, discarding the previous original
value. No-ops if <code>an-instance</code> is not a Toucan 2 instance.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reset-original
  [an-instance]
  (if (instance? an-instance)
    (protocols/with-original an-instance (protocols/current an-instance))
    an-instance))</pre></td></tr><tr><td class="docs"><p>TODO -- should we have a revert-changes helper function as well?</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Applies <code>f</code> directly to the underlying <code>original</code> map of <code>an-instance</code>. No-ops if <code>an-instance</code> is not
an [[Instance]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-original
  [an-instance f &amp; args]
  (if (instance? an-instance)
    (protocols/with-original an-instance (apply f (protocols/original an-instance) args))
    an-instance))</pre></td></tr><tr><td class="docs"><p>Applies <code>f</code> directly to the underlying <code>current</code> map of <code>an-instance</code>; useful if you need to operate on it directly.
Acts like regular <code>(apply f instance args)</code> if <code>an-instance</code> is not an [[Instance]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-current
  [an-instance f &amp; args]
  (protocols/with-current an-instance (apply f (protocols/current an-instance) args)))</pre></td></tr><tr><td class="docs"><p>Like <code>(apply f instance args)</code>, but affects both the <code>original</code> map and <code>current</code> map of <code>an-instance</code> rather than
just the current map. Acts like regular <code>(apply f instance args)</code> if <code>instance</code> is not an <code>Instance</code>.</p>

<p><code>f</code> is applied directly to the underlying <code>original</code> and <code>current</code> maps of <code>instance</code> itself. <code>f</code> is only applied
once if <code>original</code> and <code>current</code> are currently the same object (i.e., the new <code>original</code> and <code>current</code> will also be
the same object). If <code>current</code> and <code>original</code> are not the same object, <code>f</code> is applied twice.</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-original-and-current
  [an-instance f &amp; args]
  (if (identical? (protocols/original an-instance) (protocols/current an-instance))
    (reset-original (apply update-current an-instance f args))
    (as-&gt; an-instance an-instance
      (apply update-original an-instance f args)
      (apply update-current  an-instance f args))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.jdbc" name="toucan2.jdbc"><h1 class="project-name">toucan2.jdbc</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.jdbc
  (:require
   [toucan2.jdbc.connection :as jdbc.conn]
   [toucan2.jdbc.pipeline :as jdbc.pipeline]
   [toucan2.protocols :as protocols]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment jdbc.conn/keep-me
         jdbc.pipeline/keep-me)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>load the miscellaneous integrations</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- class-for-name ^Class [^String class-name]
  (try
    (Class/forName class-name)
    (catch Throwable _)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(when (class-for-name &quot;org.postgresql.jdbc.PgConnection&quot;)
  (require 'toucan2.jdbc.postgres))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(when (some class-for-name [&quot;org.mariadb.jdbc.Connection&quot;
                           &quot;org.mariadb.jdbc.MariaDbConnection&quot;
                           &quot;com.mysql.cj.MysqlConnection&quot;])
  (require 'toucan2.jdbc.mysql-mariadb))</pre></td></tr><tr><td class="docs"><p>c3p0 and Hikari integration: when we encounter a wrapped connection pool connection, dispatch off of the class of
connection it wraps</p>
</td><td class="codes"><pre class="brush: clojure">(doseq [pool-connection-class-name [&quot;com.mchange.v2.c3p0.impl.NewProxyConnection&quot;
                                    &quot;com.zaxxer.hikari.pool.HikariProxyConnection&quot;]]
  (when-let [pool-connection-class (class-for-name pool-connection-class-name)]
    (extend pool-connection-class
      protocols/IDispatchValue
      {:dispatch-value (fn [^java.sql.Wrapper conn]
                         (try
                           (protocols/dispatch-value (.unwrap conn java.sql.Connection))
                           (catch Throwable _
                             pool-connection-class)))})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.jdbc.connection" name="toucan2.jdbc.connection"><h1 class="project-name">toucan2.jdbc.connection</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.jdbc.connection
  (:require
   [methodical.core :as m]
   [next.jdbc]
   [next.jdbc.transaction]
   [toucan2.connection :as conn]
   [toucan2.log :as log]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod conn/do-with-connection java.sql.Connection
  [conn f]
  (f conn))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod conn/do-with-connection javax.sql.DataSource
  [^javax.sql.DataSource data-source f]
  (with-open [conn (.getConnection data-source)]
    (f conn)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod conn/do-with-connection clojure.lang.IPersistentMap
  &quot;Implementation for map connectables. Treats them as a `clojure.java.jdbc`-style connection spec map, converting them to
  a `java.sql.DataSource` with [[next.jdbc/get-datasource]].&quot;
  [m f]
  (conn/do-with-connection (next.jdbc/get-datasource m) f))</pre></td></tr><tr><td class="docs"><p>for record types that implement <code>DataSource</code>, prefer the <code>DataSource</code> impl over the map impl.</p>
</td><td class="codes"><pre class="brush: clojure">(m/prefer-method! #'conn/do-with-connection javax.sql.DataSource clojure.lang.IPersistentMap)</pre></td></tr><tr><td class="docs"><p>jdbc</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmethod conn/do-with-connection-string 
  &quot;Implementation of `do-with-connection-string` (and thus [[do-with-connection]]) for all strings starting with `jdbc:`.
  Calls `java.sql.DriverManager/getConnection` on the connection string.&quot;
  [^String connection-string f]
  (with-open [conn (java.sql.DriverManager/getConnection connection-string)]
    (f conn)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod conn/do-with-transaction java.sql.Connection
  [^java.sql.Connection conn options f]
  (let [nested-tx-rule (get options :nested-transaction-rule next.jdbc.transaction/*nested-tx*)
        options        (dissoc options :nested-transaction-rule)]
    (log/debugf &quot;do with JDBC transaction (nested rule: %s) with options %s&quot; nested-tx-rule options)
    (binding [next.jdbc.transaction/*nested-tx* nested-tx-rule]
      (next.jdbc/with-transaction [t-conn conn options]
        (f t-conn)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.jdbc.mysql-mariadb" name="toucan2.jdbc.mysql-mariadb"><h1 class="project-name">toucan2.jdbc.mysql-mariadb</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>MySQL and MariaDB integration (mostly workarounds for broken stuff).</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.jdbc.mysql-mariadb
  (:require
   [methodical.core :as m]
   [toucan2.jdbc.options :as jdbc.options]
   [toucan2.jdbc.read :as jdbc.read]
   [toucan2.jdbc.result-set :as jdbc.rs]
   [toucan2.log :as log]
   [toucan2.model :as model]
   [toucan2.pipeline :as pipeline]
   [toucan2.util :as u])
  (:import
   (java.sql ResultSet ResultSetMetaData Types)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>TODO -- need the MySQL class here too.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doseq [^String connection-class-name [&quot;org.mariadb.jdbc.Connection&quot;
                                       &quot;org.mariadb.jdbc.MariaDbConnection&quot;
                                       &quot;com.mysql.cj.MysqlConnection&quot;]]
  (when-let [connection-class (try
                                (Class/forName connection-class-name)
                                (catch Throwable _))]
    (derive connection-class ::connection)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod jdbc.read/read-column-thunk [#_conn  ::connection
                                          #_model :default
                                          #_type  Types/TIMESTAMP]
  &quot;MySQL/MariaDB `timestamp` is normalized to UTC, so return it as an `OffsetDateTime` rather than a `LocalDateTime`.
  `datetime` columns should be returned as `LocalDateTime`. Both `timestamp` and `datetime` seem to come back as
  `java.sql.Types/TIMESTAMP`, so check the actual database column type name so we can fetch objects as the correct
  class.&quot;
  [_conn _model ^ResultSet rset ^ResultSetMetaData rsmeta ^Long i]
  (let [^Class klass (if (= (u/lower-case-en (.getColumnTypeName rsmeta i)) &quot;timestamp&quot;)
                       java.time.OffsetDateTime
                       java.time.LocalDateTime)]
    (jdbc.read/get-object-of-class-thunk rset i klass)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/prefer-method! #'jdbc.read/read-column-thunk
                  [::connection :default Types/TIMESTAMP]
                  [java.sql.Connection :default Types/TIMESTAMP])</pre></td></tr><tr><td class="docs"><p>INSERT RETURN<em>GENERATED</em>KEYS with explicit non-integer PK value workaround</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-execute-with-connection [#_conn       ::connection
                                                         #_query-type :toucan.query-type/insert.pks
                                                         #_model      :default]
  &quot;Apparently `RETURN_GENERATED_KEYS` doesn't work for MySQL/MariaDB if:
  1. Values for the primary key are specified in the INSERT itself, *and*
  2. The primary key is not an integer.
  So to work around this we will look at the rows we're inserting: if every rows specifies the primary key
  column(s) (including `nil` values), we'll transduce those specified values rather than what JDBC returns.
  This seems like it won't work if these values were arbitrary Honey SQL expressions. I suppose we could work around
  THAT problem by running the primary key values thru another SELECT query... but that just seems like too much. I guess
  we can cross that bridge when we get there.&quot;
  [rf conn query-type model compiled-query]
  (let [rows                 (:rows pipeline/*parsed-args*)
        pks                  (model/primary-keys model)
        return-pks-directly? (and (seq rows)
                                  (every? (fn [row]
                                            (every? (fn [k]
                                                      (contains? row k))
                                                    pks))
                                          rows))]
    (if return-pks-directly?
      (do
        (pipeline/transduce-execute-with-connection (pipeline/default-rf :toucan.query-type/insert.update-count)
                                                    conn
                                                    :toucan.query-type/insert.update-count
                                                    model
                                                    compiled-query)
        (transduce
         (map (model/select-pks-fn model))
         rf
         rows))
      (next-method rf conn query-type model compiled-query))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/prefer-method! #'pipeline/transduce-execute-with-connection
                  [::connection :toucan.query-type/insert.pks :default]
                  [java.sql.Connection :toucan.result-type/pks :default])</pre></td></tr><tr><td class="docs"><p>UPDATE returning PKs workaround</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>MySQL and MariaDB don't support returning PKs for UPDATE, so we'll have to hack it as follows:</p>

<ol>
<li><p>Rework the original query to be a SELECT, run it, and record the matching PKs somewhere. Currently only supported
for queries we can manipulate e.g. Honey SQL</p></li>
<li><p>Run the original UPDATE query</p></li>
<li><p>Return the PKs from the rewritten SELECT query</p></li>
</ol>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-execute-with-connection [#_connection ::connection
                                                         #_query-type :toucan.query-type/update.pks
                                                         #_model      :default]
  &quot;MySQL and MariaDB don't support returning PKs for UPDATE. Execute a SELECT query to capture the PKs of the rows that
  will be affected BEFORE performing the UPDATE. We need to capture PKs for both `:toucan.query-type/update.pks` and for
  `:toucan.query-type/update.instances`, since ultimately the latter is implemented on top of the former.&quot;
  [original-rf conn _query-type model sql-args]
  ;; if for some reason we've already captured PKs, don't do it again.
  (let [conditions-map pipeline/*resolved-query*
        _              (log/debugf &quot;update-returning-pks workaround: doing SELECT with conditions %s&quot;
                                   conditions-map)
        parsed-args    (update pipeline/*parsed-args* :kv-args merge conditions-map)
        select-rf      (pipeline/with-init conj [])
        xform          (map (model/select-pks-fn model))
        pks            (pipeline/transduce-query (xform select-rf)
                                                 :toucan.query-type/select.instances.fns
                                                 model
                                                 parsed-args
                                                 {})]
    (log/debugf &quot;update-returning-pks workaround: got PKs %s&quot; pks)
    (let [update-rf (pipeline/default-rf :toucan.query-type/update.update-count)]
      (log/debugf &quot;update-returning-pks workaround: performing original UPDATE&quot;)
      (pipeline/transduce-execute-with-connection update-rf conn :toucan.query-type/update.update-count model sql-args))
    (log/debugf &quot;update-returning-pks workaround: transducing PKs with original reducing function&quot;)
    (transduce
     identity
     original-rf
     pks)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/prefer-method! #'pipeline/transduce-execute-with-connection
                  [::connection :toucan.query-type/update.pks :default]
                  [java.sql.Connection :toucan.result-type/pks :default])</pre></td></tr><tr><td class="docs"><p>Builder function</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod jdbc.rs/builder-fn [::connection :default]
  &quot;This is an icky hack for MariaDB/MySQL. Inserted rows come back with the newly inserted ID as `:insert-id` rather than
  the actual name of the primary key column. So tweak the `:label-fn` we pass to `next.jdbc` to rename `:insert-id` to
  the actual PK name we'd expect. This only works for tables with a single-column PK.&quot;
  [conn model rset opts]
  (let [opts               (jdbc.options/merge-options opts)
        label-fn           (get opts :label-fn name)
        model-pks          (model/primary-keys model)
        insert-id-label-fn (if (= (count model-pks) 1)
                             (fn [label]
                               (if (= label &quot;insert_id&quot;)
                                 (let [pk (first model-pks)
                                       ;; there is some weirdness afoot. If we return a keyword without a namespace
                                       ;; then `next.jdbc` seems to qualify it regardless of whether the
                                       ;; `:qualifier-fn` returns `nil` or not -- so a PK like `:id` gets returned
                                       ;; as `(keyword  &quot;id&quot;)`. But that doesn't happen if the label function
                                       ;; returns a String.
                                       ;;
                                       ;; It seems like returning a string is the preferred thing to do, but in some
                                       ;; cases [[model/primary-keys]] returns a namespaced keyword, and we want to
                                       ;; preserve that namespace; `next.jdbc` does not try to change keywords that
                                       ;; already have namespaces.
                                       ;;
                                       ;; So return the PK name as a keyword if the PK keyword is namespaced;
                                       ;; otherwise return a string.
                                       pk (if (namespace pk)
                                            pk
                                            (name pk))]
                                   (log/debugf &quot;MySQL/MariaDB inserted ID workaround: fetching insert_id as %s&quot; pk)
                                   pk)
                                 label))
                             identity)
        label-fn'          (comp label-fn insert-id-label-fn)]
    (next-method conn model rset (assoc opts :label-fn label-fn'))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.jdbc.options" name="toucan2.jdbc.options"><h1 class="project-name">toucan2.jdbc.options</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.jdbc.options
  (:require
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs"><p>Default options automatically passed to all <code>next.jdbc</code> queries and builder functions. This is stored
as an atom; <code>reset!</code> or <code>swap!</code> it to define other default options.</p>
</td><td class="codes"><pre class="brush: clojure">(defonce  global-options
  (atom {:label-fn u/lower-case-en}))</pre></td></tr><tr><td class="docs"><p>Options to pass to <code>next.jdbc</code> when executing queries or statements. Overrides the [[global-options]].</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *options*
  nil)</pre></td></tr><tr><td class="docs"><p>Merge maps of <code>next.jdbc</code> options together. <code>extra-options</code> are ones passed in as part of the query execution pipeline
and override [[<em>options</em>]], which in turn override the default [[global-options]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn merge-options
  [extra-options]
  (merge @global-options
         *options*
         extra-options))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.jdbc.pipeline" name="toucan2.jdbc.pipeline"><h1 class="project-name">toucan2.jdbc.pipeline</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.jdbc.pipeline
  (:require
   [methodical.core :as m]
   [toucan2.jdbc.query :as jdbc.query]
   [toucan2.model :as model]
   [toucan2.pipeline :as pipeline]
   [toucan2.types :as types]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-execute-with-connection [#_connection java.sql.Connection
                                                         #_query-type :default
                                                         #_model      :default]
  &quot;Default impl for the JDBC query execution backend.&quot;
  [rf conn query-type model sql-args]
  {:pre [(sequential? sql-args) (string? (first sql-args))]}
  ;; `:return-keys` is passed in this way instead of binding a dynamic var because we don't want any additional queries
  ;; happening inside of the `rf` to return keys or whatever.
  (let [extra-options (when (isa? query-type :toucan.result-type/pks)
                        {:return-keys true})
        result        (jdbc.query/reduce-jdbc-query rf (rf) conn model sql-args extra-options)]
    (rf result)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-execute-with-connection [#_connection java.sql.Connection
                                                         #_query-type :toucan.result-type/pks
                                                         #_model      :default]
  &quot;JDBC query execution backend for executing queries that return PKs (`:toucan.result-type/pks`).
  Applies transducer to call [[toucan2.model/select-pks-fn]] on each result row.&quot;
  [rf conn query-type model sql-args]
  (let [xform (map (model/select-pks-fn model))]
    (next-method (xform rf) conn query-type model sql-args)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- transduce-instances-from-pks
  [rf model columns pks]
  ;; make sure [[toucan2.select]] is loaded so we get the impls for `:toucan.query-type/select.instances`
  (when-not (contains? (loaded-libs) 'toucan2.select)
    (locking clojure.lang.RT/REQUIRE_LOCK
      (require 'toucan2.select)))
  (if (empty? pks)
    []
    (let [kv-args     {:toucan/pk [:in pks]}
          parsed-args {:columns columns
                       :kv-args kv-args}]
      (pipeline/transduce-query rf :toucan.query-type/select.instances-from-pks model parsed-args {}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(derive ::DML-queries-returning-instances :toucan.result-type/instances)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doseq [query-type [:toucan.query-type/delete.instances
                    :toucan.query-type/update.instances
                    :toucan.query-type/insert.instances]]
  (derive query-type ::DML-queries-returning-instances))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-execute-with-connection [#_connection java.sql.Connection
                                                         #_query-type ::DML-queries-returning-instances
                                                         #_model      :default]
  &quot;DML queries like `UPDATE` or `INSERT` don't usually support returning instances, at least not with JDBC. So for these
  situations we'll fake it by first running an equivalent query returning inserted/affected PKs, and then do a
  subsequent SELECT to get those rows. Then we'll reduce the rows with the original reducing function.&quot;
  [rf conn query-type model sql-args]
  ;; We're using `conj` here instead of `rf` so no row-transform nonsense or whatever is done. We will pass the
  ;; actual instances to the original `rf` once we get them.
  (let [pk-query-type (types/similar-query-type-returning query-type :toucan.result-type/pks)
        pks           (pipeline/transduce-execute-with-connection conj conn pk-query-type model sql-args)
        ;; this is sort of a hack but I don't know of any other way to pass along `:columns` information with the
        ;; original parsed args
        columns       (:columns pipeline/*parsed-args*)]
    ;; once we have a sequence of PKs then get instances as with `select` and do our magic on them using the
    ;; ORIGINAL `rf`.
    (transduce-instances-from-pks rf model columns pks)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.jdbc.postgres" name="toucan2.jdbc.postgres"><h1 class="project-name">toucan2.jdbc.postgres</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>PostgreSQL integration.</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.jdbc.postgres
  (:require
   [methodical.core :as m]
   [toucan2.jdbc.read :as jdbc.read]
   [toucan2.util :as u])
  (:import
   (java.sql ResultSet ResultSetMetaData Types)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(when-let [pg-connection-class (try
                                 (Class/forName &quot;org.postgresql.jdbc.PgConnection&quot;)
                                 (catch Throwable _
                                   nil))]
  (derive pg-connection-class ::connection))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod jdbc.read/read-column-thunk [#_conn  ::connection
                                          #_model :default
                                          #_type  Types/TIMESTAMP]
  &quot;Both Postgres `timestamp` and `timestamp with time zone` come back as `java.sql.Types/TIMESTAMP`; check the actual
  database column type name so we can fetch objects as the correct class.&quot;
  [_conn _model ^ResultSet rset ^ResultSetMetaData rsmeta ^Long i]
  (let [^Class klass (if (= (u/lower-case-en (.getColumnTypeName rsmeta i)) &quot;timestamptz&quot;)
                       java.time.OffsetDateTime
                       java.time.LocalDateTime)]
    (jdbc.read/get-object-of-class-thunk rset i klass)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/prefer-method! #'jdbc.read/read-column-thunk
                  [::connection :default Types/TIMESTAMP]
                  [java.sql.Connection :default Types/TIMESTAMP])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.jdbc.query" name="toucan2.jdbc.query"><h1 class="project-name">toucan2.jdbc.query</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns ^:no-doc toucan2.jdbc.query
  (:require
   [next.jdbc]
   [toucan2.jdbc.options :as jdbc.options]
   [toucan2.jdbc.result-set :as jdbc.rs]
   [toucan2.log :as log]
   [toucan2.util :as u])
  (:import java.sql.ResultSet))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>TODO: it's a little silly having a one-function namespace. Maybe we should move this into one other ones</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>We normally only read in a forward direction, and treat result sets as read-only. So make sure the JDBC can optimize
things when possible. Note that you're apparently not allowed to do this when <code>:return-keys</code> is set. So this only is
merged in otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:private read-forward-options
  {:concurrency :read-only
   :cursors     :close
   :result-type :forward-only})</pre></td></tr><tr><td class="docs"><p>Execute <code>sql-args</code> against a JDBC connection <code>conn</code>, and reduce results with reducing function <code>rf</code> and initial value
<code>init</code>. Part of the implementation of the JDBC backend; you shouldn't need to call this directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc reduce-jdbc-query
  [rf init ^java.sql.Connection conn model sql-args extra-options]
  {:pre [(instance? java.sql.Connection conn) (sequential? sql-args) (string? (first sql-args)) (ifn? rf)]}
  (let [opts (jdbc.options/merge-options extra-options)
        opts (merge (when-not (:return-keys opts)
                      read-forward-options)
                    opts)]
    (log/debugf &quot;Preparing JDBC query with next.jdbc options %s&quot; opts)
    (u/try-with-error-context [(format &quot;execute SQL with %s&quot; (class conn)) {::sql-args sql-args}]
      (with-open [stmt (next.jdbc/prepare conn sql-args opts)]
        (when-not (= (.getFetchDirection stmt) ResultSet/FETCH_FORWARD)
          (try
            (.setFetchDirection stmt ResultSet/FETCH_FORWARD)
            (catch Throwable e
              (log/debugf e &quot;Error setting fetch direction&quot;))))
        (log/tracef &quot;Executing statement with %s&quot; (class conn))
        (let [result-set? (.execute stmt)]
          (cond
            (:return-keys opts)
            (do
              (log/debugf &quot;Query was executed with %s; returning generated keys&quot; :return-keys)
              (with-open [rset (.getGeneratedKeys stmt)]
                (jdbc.rs/reduce-result-set rf init conn model rset opts)))
            result-set?
            (with-open [rset (.getResultSet stmt)]
              (log/debugf &quot;Query returned normal result set&quot;)
              (jdbc.rs/reduce-result-set rf init conn model rset opts))
            :else
            (do
              (log/debugf &quot;Query did not return a ResultSet; nothing to reduce. Returning update count.&quot;)
              (reduce rf init [(.getUpdateCount stmt)]))))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.jdbc.read" name="toucan2.jdbc.read"><h1 class="project-name">toucan2.jdbc.read</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>[[read-column-thunk]] method, which is used to determine how to read values of columns in results, and default
implementations</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.jdbc.read
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [next.jdbc.result-set :as next.jdbc.rs]
   [toucan2.log :as log]
   [toucan2.protocols :as protocols]
   [toucan2.types :as types]
   [toucan2.util :as u])
  (:import
   (java.sql Connection ResultSet ResultSetMetaData Types)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment s/keep-me
         types/keep-me)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>Map of <code>java.sql.Types</code> enum integers (e.g. <code>java.sql.Types/FLOAT</code>, whose value is <code>6</code>) to the string type name e.g.
<code>FLOAT</code>.</p>

<p>```clj
(type-name java.sql.Types/FLOAT) -> (type-name 6) -> "FLOAT"
```</p>

<p>arglists metadata is mostly so (theoretically) Kondo can catch if you try to call this with the wrong type or wrong
number of args.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:arglists '(^String [^Integer i] ^String [^Integer i not-found])} type-name
  (into {} (for [^java.lang.reflect.Field field (.getDeclaredFields Types)]
             [(.getLong field Types) (.getName field)])))</pre></td></tr><tr><td class="docs"><p>Return a zero-arg function that, when called, will fetch the value of the column from the current row.</p>

<p>Dispatches on <code>java.sql.Connection</code> class, <code>model</code>, and the <code>java.sql.Types</code> mapping for the column, e.g.
<code>java.sql.Types/TIMESTAMP</code>.</p>

<h3>TODO -- dispatch for this method is busted.</h3>

<ol>
<li><p>The <code>java.sql.Types</code> column type should be an explicit parameter. A little weird to dispatch off of something
that's not even one of the parameters</p></li>
<li><p>Should this also dispatch off of the actual underlying column name? So you can read a column in different ways for
different models.</p></li>
<li><p>Should this dispatch off of the underlying database column type name string, e.g. <code>timestamp</code> or <code>timestamptz</code>? It
seems like a lot of the time we need to do different things based on that type name.</p></li>
</ol>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti read-column-thunk
  {:arglists            '([^Connection conn model ^ResultSet rset ^ResultSetMetaData rsmeta ^Long i])
   :defmethod-arities   #{5}
   :dispatch-value-spec (types/or-default-spec
                         (s/cat :connection-class ::types/dispatch-value.keyword-or-class
                                :model            ::types/dispatch-value.model
                                :column-type      any?))}
  (fn [^Connection conn model _rset ^ResultSetMetaData rsmeta ^Long i]
    (let [col-type (.getColumnType rsmeta i)]
      (log/debugf
       &quot;Column %s %s is of JDBC type %s, native type %s&quot;
       i
       (let [table-name  (some-&gt;&gt; (.getTableName rsmeta i) not-empty)
             column-name (.getColumnLabel rsmeta i)]
         (if table-name
           (str table-name \. column-name)
           column-name))
       (symbol &quot;java.sql.Types&quot; (type-name col-type))
       (.getColumnTypeName rsmeta i))
      [(protocols/dispatch-value conn) (protocols/dispatch-value model) col-type])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod read-column-thunk :default
  [_conn _model ^ResultSet rset _rsmeta ^Long i]
  (log/debugf &quot;Fetching values in column %s with %s&quot; i (list '.getObject 'rs i))
  (fn default-read-column-thunk []
    (log/tracef &quot;col %s =&gt; %s&quot; i (list '.getObject 'rset i))
    (.getObject rset i)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod read-column-thunk :after :default
  [_conn model _rset _rsmeta thunk]
  (fn []
    (u/try-with-error-context [&quot;read column&quot; {:thunk thunk, :model model}]
      (thunk))))</pre></td></tr><tr><td class="docs"><p>Return a thunk that will be used to fetch values at column index <code>i</code> from ResultSet <code>rset</code> as a given class. Calling
this thunk is equivalent to</p>

<p>```clj
(.getObject rset i klass)
```</p>

<p>but includes extra logging.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-object-of-class-thunk
  [^ResultSet rset ^Long i ^Class klass]
  (log/debugf
              &quot;Fetching values in column %s with %s&quot;
              i
              (list '.getObject 'rs i klass))
  (fn get-object-of-class-thunk []
    ;; what's the overhead of this? A million rows with 10 columns each = 10 million calls =(
    ;;
    ;; from Criterium: a no-op call takes about 20ns locally. So 10m rows =&gt; 200ms from this no-op call. That's a little
    ;; expensive, but probably not as bad as the overhead we get from other nonsense here in Toucan 2. We'll have to do
    ;; some general performance tuning in the future.
    (log/tracef &quot;col %s =&gt; %s&quot; i (list '.getObject 'rset i klass))
    (.getObject rset i klass)))</pre></td></tr><tr><td class="docs"><p>Default column read methods</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod read-column-thunk [:default :default Types/CLOB]
  [_conn _model ^ResultSet rset _ ^Long i]
  (fn get-string-thunk []
    (.getString rset i)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod read-column-thunk [:default :default Types/TIMESTAMP]
  [_conn _model rset _rsmeta i]
  (get-object-of-class-thunk rset i java.time.LocalDateTime))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod read-column-thunk [:default :default Types/TIMESTAMP_WITH_TIMEZONE]
  [_conn _model rset _rsmeta i]
  (get-object-of-class-thunk rset i java.time.OffsetDateTime))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod read-column-thunk [:default :default Types/DATE]
  [_conn _model rset _rsmeta i]
  (get-object-of-class-thunk rset i java.time.LocalDate))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod read-column-thunk [:default :default Types/TIME]
  [_conn _model rset _rsmeta i]
  (get-object-of-class-thunk rset i java.time.LocalTime))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod read-column-thunk [:default :default Types/TIME_WITH_TIMEZONE]
  [_conn _model rset _rsmeta i]
  (get-object-of-class-thunk rset i java.time.OffsetTime))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- make-column-thunk [conn model ^ResultSet rset i]
  (log/tracef &quot;Building thunk to read column %s&quot; i)
  (fn column-thunk []
    (let [rsmeta (.getMetaData rset)
          thunk  (read-column-thunk conn model rset rsmeta i)
          v      (thunk)]
      (next.jdbc.rs/read-column-by-index v rsmeta i))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- make-i-&gt;thunk [conn model rset]
  (comp (memoize (fn [i]
                   (make-column-thunk conn model rset i)))
        int))</pre></td></tr><tr><td class="docs"><p>Returns a function that, given the current row number, returns a function that, given a column number, returns a cached
thunk to fetch values of that column. Confusing, huh? Here's a chart to make it a bit easier to visualize:</p>

<p>```clj
(make-cached-row-num->i->thunk conn model rset)
=>
(f current-row-number)
=>
(f column-index)
=>
(column-value-thunk)
```</p>

<p>What's the point of this? The main point is to cache values that come out of the database, so we only fetch them once.
This is used to implement our transient rows in [[toucan2.jdbc.result-set]] -- accessing the value of a transient row
twice should not result in two calls to <code>.getObject</code>.</p>

<p>The row number is used for cache-busting purposes, so we can reset the cache after each row is returned (so we don't
accidentally cache values from the first row and return them for all the rows). The row number passed in here doesn't
need to correspond to the actual row number from a JDBC standpoint; it's used only for cache-busting purposes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc make-cached-row-num-&gt;i-&gt;thunk
  [conn model ^ResultSet rset]
  (let [i-&gt;thunk       (make-i-&gt;thunk conn model rset)
        cached-row-num (atom -1)
        cached-values  (atom {})]
    (fn row-num-&gt;i-&gt;thunk* [current-row-num]
      (when-not (= current-row-num @cached-row-num)
        (reset! cached-row-num current-row-num)
        (reset! cached-values {}))
      (fn i-&gt;thunk* [i]
        (fn cached-column-thunk []
          (let [cached-value (get @cached-values i ::not-found)]
            (if-not (= cached-value ::not-found)
              (log/tracef &quot;Using cached value for column %s: %s&quot; i cached-value)
              cached-value)
            (let [thunk (i-&gt;thunk i)
                  v     (thunk)]
              (swap! cached-values assoc i v)
              v)))))))</pre></td></tr><tr><td class="docs"><p>Given a <code>java.sql.Connection</code> <code>conn</code>, a <code>model</code>, and a <code>java.sql.ResultSet</code> <code>rset</code>, return a function that can be used
with [[next.jdbc.result-set/builder-adapter]]. The function has the signature</p>

<p>```clj
(f builder rset i) => result
```</p>

<p>When this function is called with a <code>next.jdbc</code> result set <code>builder</code>, a <code>java.sql.ResultSet</code> <code>rset</code>, and column
index <code>i</code>, it will return the value of that column for the current row.</p>

<p>The function used to fetch the column is built by combining [[read-column-thunk]]
and [[next.jdbc.result-set/read-column-by-index]]; the function is built once and used repeatedly for each new row.</p>

<p>Values are cached for the current row -- fetching the same column twice for a given row will only result in fetching
it from the database once.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc read-column-by-index-fn
  ([conn model ^ResultSet rset]
   (read-column-by-index-fn (make-cached-row-num-&gt;i-&gt;thunk conn model rset)))
  ([row-num-&gt;i-&gt;thunk]
   (fn read-column-by-index-fn* [_builder ^ResultSet rset ^Integer i]
     (assert (not (.isClosed ^ResultSet rset))
             &quot;ResultSet is already closed. Do you need call toucan2.realize/realize on the row before the Connection is closed?&quot;)
     (let [i-&gt;thunk (row-num-&gt;i-&gt;thunk (.getRow rset))
           thunk    (i-&gt;thunk i)
           result   (thunk)]
       (log/tracef &quot;col %s =&gt; %s&quot; i result)
       result))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.jdbc.result-set" name="toucan2.jdbc.result-set"><h1 class="project-name">toucan2.jdbc.result-set</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation of a custom <code>next.jdbc</code> result set builder function, [[builder-fn]], and the default
implementation; [[reduce-result-set]] which is used to reduce results from JDBC databases.</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.jdbc.result-set
  (:require
   [better-cond.core :as b]
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [next.jdbc.result-set :as next.jdbc.rs]
   [toucan2.instance :as instance]
   [toucan2.jdbc.options :as jdbc.options]
   [toucan2.jdbc.read :as jdbc.read]
   [toucan2.jdbc.row :as jdbc.row]
   [toucan2.log :as log]
   [toucan2.model :as model]
   [toucan2.types :as types]
   [toucan2.util :as u])
  (:import
   (java.sql ResultSet ResultSetMetaData)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment s/keep-me
         types/keep-me)</pre></td></tr><tr><td class="docs"><p>Return the <code>next.jdbc</code> builder function to use to create the results when querying a model. By default, this
uses [[instance-builder-fn]], and returns Toucan 2 instances; but if you want to use plain maps you can use one of the
other builder functions that ships with <code>next.jdbc</code>, or write your own custom builder function.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti builder-fn
  {:arglists            '([^java.sql.Connection conn model ^java.sql.ResultSet rset opts])
   :defmethod-arities   #{4}
   :dispatch-value-spec (types/or-default-spec
                         (s/cat :conn  ::types/dispatch-value.keyword-or-class
                                :model ::types/dispatch-value.model))}
  u/dispatch-on-first-two-args)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord ^:no-doc InstanceBuilder [model ^ResultSet rset ^ResultSetMetaData rsmeta cols]
  next.jdbc.rs/RowBuilder
  (-&gt;row [_this]
    (log/tracef &quot;Fetching row %s&quot; (.getRow rset))
    (transient (instance/instance model)))
  (column-count [_this]
    (count cols))
  ;; this is purposefully not implemented because we should never get here; if we do it is an error and we want an
  ;; Exception thrown.
  #_(with-column [this row i]
      (println (pr-str (list 'with-column 'this 'row i)))
      (next.jdbc.rs/with-column-value this row (nth cols (dec i))
        (next.jdbc.rs/read-column-by-index (.getObject rset ^Integer i) rsmeta i)))
  (with-column-value [_this row col v]
    (assert (some? col) &quot;Invalid col&quot;)
    (assoc! row col v))
  (row! [_this row]
    (log/tracef &quot;Converting transient row to persistent row&quot;)
    (persistent! row))
  next.jdbc.rs/ResultSetBuilder
  (-&gt;rs [_this]
    (transient []))
  (with-row [_this acc row]
    (conj! acc row))
  (rs! [_this acc]
    (persistent! acc)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- make-column-name-&gt;index [cols label-fn]
  {:pre [(fn? label-fn)]}
  (if (empty? cols)
    (constantly nil)
    (memoize
     (fn [column-name]
       (when (or (string? column-name)
                 (instance? clojure.lang.Named column-name))
         ;; TODO FIXME -- it seems like the column name we get here has already went thru the label fn/qualifying
         ;; functions. The `(originally ...)` in the log message is wrong. Are we applying label function twice?!
         (let [column-name' (keyword
                             (when (instance? clojure.lang.Named column-name)
                               (when-let [col-ns (namespace column-name)]
                                 (label-fn (name col-ns))))
                             (label-fn (name column-name)))
               i            (when column-name'
                              (first (keep-indexed
                                      (fn [i col]
                                        (when (= col column-name')
                                          (inc i)))
                                      cols)))]
           (log/tracef &quot;Index of column named %s (originally %s) is %s&quot; column-name' column-name i)
           (when-not i
             (log/debugf &quot;Could not determine index of column name %s. Found: %s&quot; column-name cols))
           i))))))</pre></td></tr><tr><td class="docs"><p>Create a result set map builder function appropriate for passing as the <code>:builder-fn</code> option to <code>next.jdbc</code> that
will create [[toucan2.instance]]s of <code>model</code> using namespaces determined
by [[toucan2.model/table-name->namespace]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn instance-builder-fn
  [model ^ResultSet rset opts]
  (let [table-name-&gt;ns (model/table-name-&gt;namespace model)
        label-fn       (get opts :label-fn name)
        qualifier-fn   (memoize
                        (fn [table]
                          (let [table    (some-&gt; table not-empty name label-fn)
                                table-ns (some-&gt; (get table-name-&gt;ns table) name)]
                            (log/tracef &quot;Using namespace %s for columns in table %s&quot; table-ns table)
                            table-ns)))
        opts           (merge {:label-fn     label-fn
                               :qualifier-fn qualifier-fn}
                              opts)
        rsmeta         (.getMetaData rset)
        _              (log/debugf &quot;Getting modified column names with next.jdbc options %s&quot; opts)
        col-names      (next.jdbc.rs/get-modified-column-names rsmeta opts)]
    (log/debugf &quot;Column names: %s&quot; col-names)
    (constantly
     (assoc (-&gt;InstanceBuilder model rset rsmeta col-names) :opts opts))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod builder-fn :default
  &quot;Default `next.jdbc` builder function. Uses [[instance-builder-fn]] to return Toucan 2 instances.&quot;
  [_conn model rset opts]
  (let [merged-opts (jdbc.options/merge-options opts)]
    (instance-builder-fn model rset merged-opts)))</pre></td></tr><tr><td class="docs"><p>Reduce a <code>java.sql.ResultSet</code> using reducing function <code>rf</code> and initial value <code>init</code>. <code>conn</code> is an instance of
<code>java.sql.Connection</code>. <code>conn</code> and <code>model</code> are used mostly for dispatch value purposes for things like [[builder-fn]],
and for creating instances with the correct model.</p>

<p>Part of the low-level implementation of the JDBC query execution backend -- you probably shouldn't be using this
directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc reduce-result-set
  [rf init conn model ^ResultSet rset opts]
  (log/debugf &quot;Reduce JDBC result set for model %s with rf %s and init %s&quot; model rf init)
  (let [row-num-&gt;i-&gt;thunk (jdbc.read/make-cached-row-num-&gt;i-&gt;thunk conn model rset)
        builder-fn*       (next.jdbc.rs/builder-adapter
                           (builder-fn conn model rset opts)
                           (jdbc.read/read-column-by-index-fn row-num-&gt;i-&gt;thunk))
        builder           (builder-fn* rset opts)
        combined-opts     (jdbc.options/merge-options (merge (:opts builder) opts))
        label-fn          (get combined-opts :label-fn)
        _                 (assert (fn? label-fn) &quot;Options must include :label-fn&quot;)
        col-names         (get builder :cols (next.jdbc.rs/get-modified-column-names
                                              (.getMetaData rset)
                                              combined-opts))
        col-name-&gt;index   (make-column-name-&gt;index col-names label-fn)]
    (log/tracef &quot;column name -&gt; index = %s&quot; col-name-&gt;index)
    (loop [acc init]
      (b/cond
        (not (.next rset))
        (do
          (log/tracef &quot;Result set has no more rows.&quot;)
          acc)
        :let [row-num  (.getRow rset)
              _        (log/tracef &quot;Fetch row %s&quot; row-num)
              i-&gt;thunk (row-num-&gt;i-&gt;thunk row-num)
              row      (jdbc.row/row model rset builder i-&gt;thunk col-name-&gt;index)
              acc'     (rf acc row)]
        (reduced? acc')
        @acc'
        :else
        (recur acc')))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.jdbc.row" name="toucan2.jdbc.row"><h1 class="project-name">toucan2.jdbc.row</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Custom [[TransientRow]] type. This is mostly in a separate namespace so I don't have to look at it when working on
unrelated [[toucan2.jdbc.result-set]] stuff.</p>

<p>This is roughly adapted from [[next.jdbc.result-set/mapify-result-set]] in a somewhat-successful attempt to make
Toucan 2 be <code>next.jdbc</code>-compatible.</p>
</td><td class="codes"><pre class="brush: clojure">(ns ^:no-doc toucan2.jdbc.row
  (:require
   [better-cond.core :as b]
   [clojure.core.protocols :as core-p]
   [clojure.datafy :as d]
   [clojure.pprint :as pprint]
   [clojure.string :as str]
   [next.jdbc.result-set :as next.jdbc.rs]
   [puget.printer :as puget]
   [toucan2.instance :as instance]
   [toucan2.log :as log]
   [toucan2.protocols :as protocols]
   [toucan2.realize :as realize]
   [toucan2.util :as u])
  (:import
   (java.sql ResultSet)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare print-representation-parts)</pre></td></tr><tr><td class="docs"><p>Fetch the column with <code>column-name</code>. Returns <code>not-found</code> if no such column exists.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- fetch-column-with-name
  [column-name-&gt;index i-&gt;thunk column-name not-found]
  ;; this might get called with some other non-string or non-keyword key, in that case just return `not-found`
  ;; immediately since we're not going to find it by hitting the database.
  (let [i      (column-name-&gt;index column-name)
        result (b/cond
                 (not i)     not-found
                 :let        [thunk (i-&gt;thunk i)]
                 (not thunk) not-found
                 :else       (thunk))]
    (log/tracef &quot;=&gt; %s&quot; result)
    result))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private ^:dynamic *fetch-all-columns* true)</pre></td></tr><tr><td class="docs"><p>One of these is built for every row in the results.</p>

<p>TODO -- maybe we can combine the</p>
</td><td class="codes"><pre class="brush: clojure">(deftype ^:no-doc TransientRow [model
                                ^ResultSet rset
                                ;; `next.jdbc` result set builder, usually an instance
                                ;; of [[toucan2.jdbc.result_set.InstanceBuilder]] or
                                ;; whatever [[toucan2.jdbc.result-set/builder-fn]] returns. Should have the key `:cols`
                                builder
                                ;; a function that given a column name key will normalize it and return the
                                ;; corresponding JDBC index. This should probably be memoized for the whole result set.
                                column-name-&gt;index
                                ;; an atom with a set of realized column name keywords.
                                realized-keys
                                ;; ATOM with map. Given a JDBC column index (starting at 1) return a thunk that can be
                                ;; used to fetch the column. This usually comes
                                ;; from [[toucan2.jdbc.read/make-cached-i-&gt;thunk]].
                                i-&gt;thunk
                                ;; underlying transient map representing this row.
                                ^clojure.lang.ITransientMap transient-row
                                ;; a delay that should return a persistent map for the current row. Once this is called
                                ;; we should return the realized row directly and work with that going forward.
                                realized-row]
  next.jdbc.result_set.InspectableMapifiedResultSet
  (row-number   [_this] (.getRow rset))
  (column-names [_this] (:cols builder))
  (metadata     [_this] (d/datafy (.getMetaData rset)))
  clojure.lang.IPersistentMap
  (assoc [this k v]
    (log/tracef &quot;.assoc %s %s&quot; k v)
    (if (realized? realized-row)
      (assoc @realized-row k v)
      (let [^clojure.lang.ITransientMap transient-row' (assoc! transient-row k v)]
        (swap! realized-keys conj k)
        (assert (= (.valAt transient-row' k) v)
                (format &quot;assoc! did not do what we expected. k = %s v = %s row = %s .valAt = %s&quot;
                        (pr-str k)
                        (pr-str v)
                        (pr-str transient-row')
                        (pr-str (.valAt transient-row' k))))
        ;; `assoc!` might return a different object. In practice, I think it usually doesn't; optimize for that case
        ;; and return `this` rather than creating a new instance of `TransientRow`.
        (if (identical? transient-row transient-row')
          this
          ;; If `assoc!` did return a different object, then we need to create a new `TransientRow` with the new value
          (TransientRow. model
                         rset
                         builder
                         column-name-&gt;index
                         realized-keys
                         i-&gt;thunk
                         transient-row'
                         realized-row)))))
  ;; TODO -- can we `assocEx` the transient row?
  (assocEx [_this k v]
    (log/tracef &quot;.assocEx %s %s&quot; k v)
    (.assocEx ^clojure.lang.IPersistentMap @realized-row k v))
  (without [this k]
    (log/tracef &quot;.without %s&quot; k)
    (if (realized? realized-row)
      (dissoc @realized-row k)
      (let [transient-row'      (dissoc! transient-row k)
            k-index             (column-name-&gt;index k)
            column-name-&gt;index' (if-not k-index
                                  column-name-&gt;index
                                  (fn [column-name]
                                    (let [index (column-name-&gt;index column-name)]
                                      (when-not (= index k-index)
                                        index))))]
        (when k-index
          (swap! i-&gt;thunk (fn [i-&gt;thunk]
                            (fn [index]
                              (if (= index k-index)
                                (constantly ::not-found)
                                (i-&gt;thunk index))))))
        (swap! realized-keys disj k)
        ;; as in the `assoc` method above, we can optimize a bit and return `this` instead of creating a new object if
        ;; `assoc!` returned the original `transient-row` rather than a different object
        (if (and (identical? transient-row      transient-row')
                 (identical? column-name-&gt;index column-name-&gt;index'))
          this
          (TransientRow. model
                         rset
                         builder
                         column-name-&gt;index'
                         realized-keys
                         i-&gt;thunk
                         transient-row'
                         realized-row)))))
  ;; Java 7 compatible: no forEach / spliterator
  ;;
  ;; TODO -- not sure if we need/want this
  java.lang.Iterable
  (iterator [_this]
    (log/tracef &quot;.iterator&quot;)
    (.iterator ^java.lang.Iterable @realized-row))
  clojure.lang.Associative
  (containsKey [_this k]
    (log/tracef &quot;.containsKey %s&quot; k)
    (if (realized? realized-row)
      (contains? @realized-row k)
      (or (contains? transient-row k)
          (boolean (column-name-&gt;index k)))))
  (entryAt [this k]
    (log/tracef &quot;.entryAt %s&quot; k)
    (let [v (.valAt this k ::not-found)]
      (when-not (= v ::not-found)
        (clojure.lang.MapEntry. k v))))
;;; TODO -- this should probably also include any extra keys added with `assoc` or whatever
  clojure.lang.Counted
  (count [_this]
    (log/tracef &quot;.count&quot;)
    (let [cols (:cols builder)]
      (assert (seq cols))
      (count cols)))
  clojure.lang.IPersistentCollection
  (cons [this o]
    (log/tracef &quot;.cons %s&quot; o)
    (cond
      (map? o)
      (reduce #(apply assoc %1 %2) this o)
      (instance? java.util.Map o)
      (reduce #(apply assoc %1 %2) this (into {} o))
      :else
      (if-let [[k v] (seq o)]
        (assoc this k v)
        this)))
  (empty [_this]
    (log/tracef &quot;.empty&quot;)
    (instance/instance model))
  (equiv [_this obj]
    (log/tracef &quot;.equiv %s&quot; obj)
    (.equiv ^clojure.lang.IPersistentCollection @realized-row obj))
  ;; we support get with a numeric key for array-based builders:
  clojure.lang.ILookup
  (valAt [this k]
    (log/tracef &quot;.valAt %s&quot; k)
    (.valAt this k nil))
  (valAt [this k not-found]
    (log/tracef &quot;.valAt %s %s&quot; k not-found)
    (cond
      (realized? realized-row)
      (get @realized-row k not-found)
      (number? k)
      (let [i (inc k)]
        (if-let [thunk (@i-&gt;thunk i)]
          (thunk)
          not-found))
      ;; non-number column name
      :else
      (let [existing-value (.valAt transient-row k ::not-found)]
        (if-not (= existing-value ::not-found)
          existing-value
          (let [fetched-value (fetch-column-with-name column-name-&gt;index @i-&gt;thunk k ::not-found)]
            (if (= fetched-value ::not-found)
              not-found
              (do
                (.assoc this k fetched-value)
                fetched-value)))))))
  clojure.lang.Seqable
  (seq [_this]
    (log/tracef &quot;.seq&quot;)
    (seq @realized-row))
  ;; calling [[persistent!]] on a transient row will convert it to a persistent object WITHOUT realizing all the columns.
  clojure.lang.ITransientCollection
  (persistent [_this]
    (log/tracef &quot;.persistent&quot;)
    (binding [*fetch-all-columns* false]
      @realized-row))
  next.jdbc.rs/DatafiableRow
  (datafiable-row [_this connectable opts]
    ;; since we have to call these eagerly, we trap any exceptions so
    ;; that they can be thrown when the actual functions are called
    (let [row   (try (.getRow rset)  (catch Throwable t t))
          cols  (try (:cols builder) (catch Throwable t t))
          metta (try (d/datafy (.getMetaData rset)) (catch Throwable t t))]
      (vary-meta
       @realized-row
       assoc
       `core-p/datafy (#'next.jdbc.rs/navize-row connectable opts)
       `core-p/nav    (#'next.jdbc.rs/navable-row connectable opts)
       `row-number    (fn [_this] (if (instance? Throwable row) (throw row) row))
       `column-names  (fn [_this] (if (instance? Throwable cols) (throw cols) cols))
       `metadata      (fn [_this] (if (instance? Throwable metta) (throw metta) metta)))))
  protocols/IModel
  (model [_this]
    model)
  protocols/IDispatchValue
  (dispatch-value [_this]
    (protocols/dispatch-value model))
  protocols/IDeferrableUpdate
  (deferrable-update [this k f]
    (log/tracef &quot;Doing deferrable update of %s with %s&quot; k f)
    (b/cond
      (realized? realized-row)
      (update @realized-row k f)
      :let [existing-value (.valAt transient-row k ::not-found)]
      ;; value already exists: update the value in the transient row and call it a day
      (not= existing-value ::not-found)
      (assoc this k (f existing-value))
      ;; otherwise compose the column thunk with `f`
      :else
      (let [col-index (column-name-&gt;index k)]
        (assert col-index (format &quot;No column named %s in results. Got: %s&quot; (pr-str k) (pr-str (:cols builder))))
        (swap! i-&gt;thunk (fn [i-&gt;thunk]
                          (fn [i]
                            (let [thunk (i-&gt;thunk i)]
                              (if (= i col-index)
                                (comp f thunk)
                                thunk)))))
        this)))
  realize/Realize
  (realize [_this]
    @realized-row)
  u/IsCustomMap
  (custom-map? [_] true)
  (toString [this]
    (str/join \space (map str (print-representation-parts this)))))</pre></td></tr><tr><td class="docs"><p>We don't use [[pretty.core/PrettyPrintable]] for this like we do for everything else because we want to print TWO
things, the [[print-symbol]] and a map.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a sequence of things to print to represent a [[TransientRow]]. Avoids realizing the entire row if we're still in
'transient' mode.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- print-representation-parts
  [^toucan2.jdbc.row.TransientRow row]
  (try
    (let [transient-row (.transient_row row)
          realized-keys (.realized_keys row)]
      [(symbol (format &quot;^%s &quot; `TransientRow))
       ;; (instance? pretty.core.PrettyPrintable transient-row) (pretty/pretty transient-row)
       (zipmap @realized-keys
               (map #(get transient-row %) @realized-keys))])
    (catch Exception _
      [&quot;unrealized result set {row} -- do you need to call toucan2.realize/realize ?&quot;])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-method toucan2.jdbc.row.TransientRow
  [row writer]
  (doseq [part (print-representation-parts row)]
    (print-method part writer)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod pprint/simple-dispatch toucan2.jdbc.row.TransientRow
  [row]
  (doseq [part (print-representation-parts row)]
    (pprint/simple-dispatch part)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod log/print-handler toucan2.jdbc.row.TransientRow
  [_klass]
  (fn [printer row]
    (for [part (print-representation-parts row)]
      (puget/format-doc printer part))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doseq [methodd [print-method
                 pprint/simple-dispatch]]
  (prefer-method methodd toucan2.jdbc.row.TransientRow clojure.lang.IPersistentMap))</pre></td></tr><tr><td class="docs"><p>A lot of the stuff below is an adapted/custom version of the code in [[next.jdbc.result-set]] -- I would have
preferred to not have to do this but a lot of it was necessary to make things work in the Toucan 2 work. See this
Slack thread for more information: https://clojurians.slack.com/archives/C1Q164V29/p1662494291800529</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- fetch-column! [builder i-&gt;thunk ^clojure.lang.ITransientMap transient-row i]
  ;; make sure the key is not already present. If it is we don't want to stomp over existing values.
  (let [col-name (nth (:cols builder) (dec i))]
    (if (= (.valAt transient-row col-name ::not-found) ::not-found)
      (let [thunk (@i-&gt;thunk i)]
        (assert (fn? thunk))
        (let [value (thunk)]
          (if (= value ::not-found)
            transient-row
            (next.jdbc.rs/with-column-value builder transient-row col-name value))))
      transient-row)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- fetch-all-columns! [builder i-&gt;thunk transient-row]
  (log/tracef &quot;Fetching all columns&quot;)
  (reduce
   (partial fetch-column! builder i-&gt;thunk)
   transient-row
   (range 1 (inc (next.jdbc.rs/column-count builder)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- make-realized-row-delay [builder i-&gt;thunk transient-row]
  (delay
    (log/tracef &quot;Fully realizing row. *fetch-all-columns* = %s&quot; *fetch-all-columns*)
    (let [row (cond-&gt;&gt; transient-row
                *fetch-all-columns* (fetch-all-columns! builder i-&gt;thunk))]
      (next.jdbc.rs/row! builder row))))</pre></td></tr><tr><td class="docs"><p>Create a new <code>TransientRow</code>. Part of the low-level implementation of the JDBC query execution backend. You probably
shouldn't be using this directly!</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc row
  [model ^ResultSet rset builder i-&gt;thunk col-name-&gt;index]
  (assert (not (.isClosed rset)) &quot;ResultSet is already closed&quot;)
  (let [transient-row      (next.jdbc.rs/-&gt;row builder)
        i-&gt;thunk           (atom i-&gt;thunk)
        realized-row-delay (make-realized-row-delay builder i-&gt;thunk transient-row)
        realized-keys      (atom #{})]
    ;; this is a gross amount of positional args. But using `reify` makes debugging things too hard IMO.
    (-&gt;TransientRow model
                    rset
                    builder
                    col-name-&gt;index
                    realized-keys
                    i-&gt;thunk
                    transient-row
                    realized-row-delay)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.log" name="toucan2.log"><h1 class="project-name">toucan2.log</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Toucan 2 logging utilities. This is basically just a fancy wrapper around <code>clojure.tools.logging</code> that supports some
additional debugging facilities, such as dynamically enabling logging for different topics or levels from the REPL.</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.log
  (:require
   [clojure.spec.alpha :as s]
   [clojure.string :as str]
   [clojure.tools.logging :as tools.log]
   [clojure.tools.logging.impl :as tools.log.impl]
   [environ.core :as env]
   [pretty.core :as pretty]
   [puget.color]
   [puget.printer :as puget]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>The current log level (as a keyword) to log messages directly to stdout with. By default this is <code>nil</code>, which means
don't log any messages to stdout regardless of their level. (They are still logged via <code>clojure.tools.logging</code>.)</p>

<p>You can dynamically bind this to enable logging at a higher level in the REPL for debugging purposes. You can also set
a default value for this by setting the atom [[level]].</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *level*
  nil)</pre></td></tr><tr><td class="docs"><p>The default log level to log messages directly to stdout with. Takes the value of the env var
<code>TOUCAN_DEBUG_LEVEL</code>, if set. Can be overridden with [[<em>level</em>]]. This is stored as an atom, so you can <code>swap!</code> or
<code>reset!</code> it.</p>
</td><td class="codes"><pre class="brush: clojure">(defonce  level
  (atom (some-&gt; (env/env :toucan-debug-level) keyword)))</pre></td></tr><tr><td class="docs"><p>Whether or not to print the trace in color. True by default, unless the env var <code>NO_COLOR</code> is true.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:private ^:dynamic *color*
  (if-let [env-var-value (env/env :no-color)]
    (complement (Boolean/parseBoolean env-var-value))
    true))</pre></td></tr><tr><td class="docs"><p>Puget printer method used when logging. Dispatches on class.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti ^:no-doc print-handler
  {:arglists '([klass])}
  (fn [klass]
    klass))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-handler :default
  [_klass]
  nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-handler pretty.core.PrettyPrintable
  [_klass]
  (fn [printer x]
    (puget/format-doc printer (pretty/pretty x))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-handler clojure.core.Eduction
  [_klass]
  (fn [printer ^clojure.core.Eduction ed]
    (puget/format-doc printer (list 'eduction (.xform ed) (.coll ed)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-handler clojure.lang.IRecord
  [klass]
  (when (isa? klass clojure.lang.IReduceInit)
    (fn [_printer x]
      [:text (str x)])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord ^:no-doc Doc [forms])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-handler Doc
  [_klass]
  (fn [printer {:keys [forms ns-symb]}]
    (let [ns-symb (when ns-symb
                    (symbol (last (str/split (name ns-symb) #&quot;\.&quot;))))]
      [:group
       (when ns-symb
         [:span
          (puget.color/document printer :number (name ns-symb))
          [:text &quot; &quot;]])
       [:align
        (for [form forms]
          (puget/format-doc printer form))]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-handler Class
  [_klass]
  (fn [printer ^Class klass]
    (puget.color/document printer :class-name (.getCanonicalName klass))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord ^:no-doc Text [s])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod print-handler Text
  [_klass]
  (fn [_printer {:keys [s]}]
    [:span
     [:text s]
     [:line]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(prefer-method print-handler pretty.core.PrettyPrintable clojure.lang.IRecord)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private printer-options
  {:print-handlers print-handler
   :width          120
   :print-meta     true
   :coll-limit     5})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- default-color-printer [x]
  ;; don't print in black. I can't see it
  (puget/cprint x (assoc printer-options :color-scheme {:nil [:green]})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- default-boring-printer [x]
  (puget/pprint x printer-options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pretty-printer []
  (if *color*
    default-color-printer
    default-boring-printer))</pre></td></tr><tr><td class="docs"><p>Pretty print a <code>doc</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc -pprint-doc
  ([doc]
   (-pprint-doc nil doc))
  ([ns-symb doc]
   (try
     ((pretty-printer) (assoc doc :ns-symb ns-symb))
     (catch Throwable e
       (throw (ex-info (format &quot;Error pretty printing doc: %s&quot; (ex-message e))
                       {:doc doc}
                       e))))))</pre></td></tr><tr><td class="docs"><p>Implementation of the <code>log</code> macros. You shouldn't need to use this directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc -pprint-doc-to-str
  [doc]
  (str/trim (with-out-str (-pprint-doc doc))))</pre></td></tr><tr><td class="docs"><p>Exactly like [[interleave]] but includes the entirety of both collections even if the other collection is shorter. If
one collection 'runs out', the remaining elements of the other collection are appended directly to the end of the
resulting collection.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- interleave-all
  [x y]
  (loop [acc [], x x, y y]
    (let [acc (cond-&gt; acc
                (seq x) (conj (first x))
                (seq y) (conj (first y)))
          x   (next x)
          y   (next y)]
      (if (and (empty? x) (empty? y))
        acc
        (recur acc x y)))))</pre></td></tr><tr><td class="docs"><p>Convert <code>format-string</code> and <code>args</code> into something that can be pretty-printed by puget.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- build-doc
  [format-string &amp; args]
  (let [-&gt;Text* (fn [s]
                  (list `-&gt;Text (str/trimr s)))
        texts   (map -&gt;Text* (str/split format-string #&quot;%s&quot;))]
    `(-&gt;Doc ~(vec (interleave-all texts args)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- level-&gt;int [a-level default]
  (case a-level
    :disabled 5
    :error    4
    :warn     3
    :info     2
    :debug    1
    :trace    0
    default))</pre></td></tr><tr><td class="docs"><p>Current log level, as an integer.</p>

<p>TODO -- better idea, why don't we just change [[<em>level</em>]] and [[level]] to store ints so we don't have to convert
them over and over again. We could introduce a <code>with-level</code> macro or something to make changing the level
convenient.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc -current-level-int
  []
  (level-&gt;int (or *level* @level) Integer/MAX_VALUE))</pre></td></tr><tr><td class="docs"><p>Whether to enable logging for <code>a-level</code>. This is a macro for performance reasons, so we can do the [[level->int]]
conversion at compile time rather than on every call.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^:no-doc -enable-level?
  [a-level]
  (let [a-level-int (level-&gt;int a-level 0)]
    `(&gt;= ~a-level-int (-current-level-int))))</pre></td></tr><tr><td class="docs"><p>Get a logger factor for the namespace named by symbol <code>ns-symb</code> at <code>a-level</code>, <strong>iff</strong> logging is enabled for that
namespace and level. The logger returned is something that satisfies the <code>clojure.tools.logging.impl.LoggerFactory</code>
protocol.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc -enabled-logger
  [ns-symb a-level]
  (let [logger (tools.log.impl/get-logger tools.log/*logger-factory* ns-symb)]
    (when (tools.log.impl/enabled? logger a-level)
      logger)))</pre></td></tr><tr><td class="docs"><p>Implementation of various <code>log</code> macros. Don't use this directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^:no-doc -log
  [a-level e doc]
  `(let [doc# (delay ~doc)]
     (when (-enable-level? ~a-level)
       (-pprint-doc '~(ns-name *ns*) @doc#))
     (when-let [logger# (-enabled-logger '~(ns-name *ns*) ~a-level)]
       (tools.log/log* logger# ~a-level ~e (-pprint-doc-to-str @doc#)))))</pre></td></tr><tr><td class="docs"><p>Implementation of various <code>log</code> macros. Don't use this directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^:no-doc logf
  [a-level &amp; args]
  (let [[e format-string &amp; args] (if (string? (first args))
                                   (cons nil args)
                                   args)]
    (assert (string? format-string))
    (let [doc (apply build-doc format-string args)]
      `(-log ~a-level ~e ~doc))))</pre></td></tr><tr><td class="docs"><p>The log macros only work with <code>%s</code> for now.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- correct-number-of-args-for-format-string? [{:keys [msg args]}]
  (let [matcher                 (re-matcher #&quot;%s&quot; msg)
        format-string-arg-count (count (take-while some? (repeatedly #(re-find matcher))))]
    (= (count args) format-string-arg-count)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- pr-str-form? [form]
  (and (seq? form)
       (= (first form) 'pr-str)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::args
  (s/&amp; (s/cat :e    (s/? (complement string?))
              :msg  string?
              :args (s/* (complement pr-str-form?)))
       correct-number-of-args-for-format-string?))</pre></td></tr><tr><td class="docs"><p>Log an error message for a <code>topic</code>. Optionally include a <code>throwable</code>. Only things that are actually serious errors
should be logged at this level.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro errorf
  {:arglists '([throwable? s] [throwable? format-string &amp; args])}
  [&amp; args]
  `(logf :error ~@args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef errorf
  :args ::args
  :ret  any?)</pre></td></tr><tr><td class="docs"><p>Log a warning for a <code>topic</code>. Optionally include a <code>throwable</code>. Bad things that can be worked around should be logged at
this level.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro warnf
  {:arglists '([throwable? s] [throwable? format-string &amp; args])}
  [&amp; args]
  `(logf :warn ~@args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef warnf
  :args ::args
  :ret  any?)</pre></td></tr><tr><td class="docs"><p>Only things that all users should see by default without configuring a logger should be this level.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro infof
  {:arglists '([throwable? s] [throwable? format-string &amp; args])}
  [&amp; args]
  `(logf :info ~@args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef infof
  :args ::args
  :ret  any?)</pre></td></tr><tr><td class="docs"><p>Most log messages should be this level.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro debugf
  {:arglists '([throwable? s] [throwable? format-string &amp; args])}
  [&amp; args]
  `(logf :debug ~@args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef debugf
  :args ::args
  :ret  any?)</pre></td></tr><tr><td class="docs"><p>Log messages that are done once-per-row should be this level.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro tracef
  {:arglists '([throwable? s] [throwable? format-string &amp; args])}
  [&amp; args]
  `(logf :trace ~@args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef tracef
  :args ::args
  :ret  any?)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (reset! level :debug)
  (tracef &quot;VERY NICE MESSAGE %s 1000&quot; :abc)
  (debugf &quot;VERY NICE MESSAGE %s 1000&quot; :abc))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.model" name="toucan2.model"><h1 class="project-name">toucan2.model</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Methods related to resolving Toucan 2 models, appropriate table names to use when building queries for them, and
namespaces to use for columns in query results.</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.model
  (:refer-clojure :exclude [namespace])
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.log :as log]
   [toucan2.protocols :as protocols]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment s/keep-me
         types/keep-me)</pre></td></tr><tr><td class="docs"><p>Resolve a <em>modelable</em> to an actual Toucan <em>model</em> (usually a keyword). A modelable is anything that can be resolved to
a model via this method. You can implement this method to define special model resolution behavior, for example
<code>toucan2-toucan1</code> defines a method for <code>clojure.lang.Symbol</code> that does namespace resolution to return an appropriate
model keyword.</p>

<p>You can also implement this method to do define behaviors when a model is used, for example making sure some namespace
with method implementation for the model is loaded, logging some information, etc.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti resolve-model
  {:arglists '([modelable]), :defmethod-arities #{1}}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod resolve-model :default
  &quot;Default implementation. Return `modelable` as is, i.e., there is nothing to resolve, and we can use it directly as a
  model.&quot;
  [modelable]
  modelable)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod resolve-model :around :default
  &quot;Log model resolution as it happens for debugging purposes.&quot;
  [modelable]
  (let [model (next-method modelable)]
    (log/debugf &quot;Resolved modelable %s =&gt; model %s&quot; modelable model)
    model))</pre></td></tr><tr><td class="docs"><p>The default connectable that should be used when executing queries for <code>model</code> if
no [[toucan2.connection/<em>current-connectable</em>]] is currently bound. By default, this just returns the global default
connectable, <code>:default</code>, but you can tell Toucan to use a different default connectable for a model by implementing
this method.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti default-connectable
  {:arglists '([model]), :defmethod-arities #{1}}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod default-connectable :default
  &quot;Return `nil`, so we can fall thru to something else (presumably `:default` anyway)?&quot;
  [_model]
  nil)</pre></td></tr><tr><td class="docs"><p>Return the actual underlying table name that should be used to query a <code>model</code>.</p>

<p>By default for things that implement <code>name</code>, the table name is just <code>(keyword (name x))</code>.</p>

<p>```clj
(t2/table-name :models/user)
;; =>
:user
```</p>

<p>You can write your own implementations for this for models whose table names do not match their <code>name</code>.</p>

<p>This is guaranteed to return a keyword, so it can easily be used directly in Honey SQL queries and the like; if you
return something else, the default <code>:after</code> method will convert it to a keyword for you.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti table-name
  {:arglists            '([model])
   :defmethod-arities   #{1}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod table-name :default
  &quot;Fallback implementation. Redirects keywords to the implementation for `clojure.lang.Named` (use the `name` of the
  keyword). For everything else, throws an error, since we don't know how to get a table name from it.&quot;
  [model]
  (if (instance? clojure.lang.Named model)
    ((m/effective-method table-name clojure.lang.Named) model)
    (throw (ex-info (format &quot;Invalid model %s: don't know how to get its table name.&quot; (pr-str model))
                    {:model model}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod table-name :after :default
  &quot;Always return table names as keywords. This will facilitate using them directly inside Honey SQL, e.g.
    {:select [:*], :from [(t2/table-name MyModel)]}&quot;
  [a-table-name]
  (keyword a-table-name))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod table-name clojure.lang.Named
  &quot;Default implementation for anything that is a `clojure.lang.Named`, such as a keywords or symbols. Use the `name` as
  the table name.
  ```clj
  (t2/table-name :models/user) =&gt; :user
  ```&quot;
  [model]
  (name model))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod table-name String
  &quot;Implementation for strings. Use the string name as-is.&quot;
  [table]
  table)</pre></td></tr><tr><td class="docs"><p>Return a sequence of the primary key columns names, as keywords, for a model. The default primary keys for a model are
<code>[:id]</code>; implement this method if your model has different primary keys.</p>

<p>```clj
;; tell Toucan that :model/bird has a composite primary key consisting of the columns :id and :name
(m/defmethod primary-keys :model/bird
  [_model]
  [:id :name])
```</p>

<p>If an implementation returns a single keyword, the default <code>:around</code> method will automatically wrap it in a vector. It
also validates that the ultimate result is a sequence of keywords, so it is safe to assume that calls to this will
always return a sequence of keywords.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti primary-keys
  {:arglists            '([model])
   :defmethod-arities   #{1}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod primary-keys :around :default
  &quot;If the PK comes back unwrapped, wrap it -- make sure results are always returned as a vector of keywords. Throw an
  error if results are in the incorrect format.&quot;
  [model]
  (let [pk-or-pks (next-method model)
        pks       (if (sequential? pk-or-pks)
                    pk-or-pks
                    [pk-or-pks])]
    (when-not (every? keyword? pks)
      (throw (ex-info (format &quot;Bad %s for model %s: should return keyword or sequence of keywords, got %s&quot;
                              `primary-keys
                              (pr-str model)
                              (pr-str pk-or-pks))
                      {:model model, :result pk-or-pks})))
    pks))</pre></td></tr><tr><td class="docs"><p>Return a map of primary key values for a Toucan 2 <code>instance</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn primary-key-values-map
  ([instance]
   (primary-key-values-map (protocols/model instance) instance))
  ([model m]
   (select-keys m (primary-keys model))))</pre></td></tr><tr><td class="docs"><p>Return a function to get the value(s) of the primary key(s) from a row, as a single value or vector of values. Used
by [[toucan2.select/select-pks-reducible]] and thus
by [[toucan2.select/select-pks-set]], [[toucan2.select/select-pks-vec]], etc.</p>

<p>The primary keys are determined by [[primary-keys]]. By default this is simply the keyword <code>:id</code>.</p>

<p>TODO -- consider renaming this to something better. What?</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-pks-fn
  [modelable]
  (let [model   (resolve-model modelable)
        pk-keys (primary-keys model)]
    (if (= (count pk-keys) 1)
      (first pk-keys)
      (apply juxt pk-keys))))</pre></td></tr><tr><td class="docs"><p>Return a map of namespaces to use when fetching results with this model.</p>

<p>```clj
(m/defmethod model->namespace ::my-model
  [_model]
  {::my-model      "x"
   ::another-model "y"})
```</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti model-&gt;namespace
  {:arglists            '([model])
   :defmethod-arities   #{1}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod model-&gt;namespace :default
  &quot;By default, don't namespace column names when fetching rows.&quot;
  [_model]
  nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod model-&gt;namespace :after :default
  &quot;Validate the results.&quot;
  [namespace-map]
  (when (some? namespace-map)
    (assert (map? namespace-map)
            (format &quot;model-&gt;namespace should return a map. Got: ^%s %s&quot;
                    (some-&gt; namespace-map class .getCanonicalName)
                    (pr-str namespace-map))))
  namespace-map)</pre></td></tr><tr><td class="docs"><p>Take the [[model->namespace]] map for a model and return a map of string table name -> namespace. This is used to
determine how to prefix columns in results based on their table name;
see [[toucan2.jdbc.result-set/instance-builder-fn]] for an example of this usage.</p>
</td><td class="codes"><pre class="brush: clojure">(defn table-name-&gt;namespace
  [model]
  (not-empty
   (into {}
         (comp (filter (fn [[model _a-namespace]]
                         (not= (m/effective-primary-method table-name model)
                               (m/default-effective-method table-name))))
               (map (fn [[model a-namespace]]
                      [(name (table-name model)) a-namespace])))
         (model-&gt;namespace model))))</pre></td></tr><tr><td class="docs"><p>Get the namespace that should be used to prefix keys associated with a <code>model</code> in query results. This is taken from the
model's implementation of [[model->namespace]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn namespace
  [model]
  (some
   (fn [[a-model a-namespace]]
     (when (isa? model a-model)
       a-namespace))
   (model-&gt;namespace model)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod primary-keys :default
  &quot;By default the primary key for a model is the column `:id`; or `:some-namespace/id` if the model defines a namespace
  for itself with [[model-&gt;namespace]].&quot;
  [model]
  (if-let [model-namespace (namespace model)]
    [(keyword (name model-namespace) &quot;id&quot;)]
    [:id]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.pipeline" name="toucan2.pipeline"><h1 class="project-name">toucan2.pipeline</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>This is a low-level namespace implementing our query execution pipeline. Most of the stuff you'd use on a regular basis
are implemented on top of stuff here.</p>

<p>Pipeline order is</p>

<ol>
<li>[[toucan2.query/parse-args]]    (entrypoint fn: [[transduce-unparsed]])</li>
<li>[[toucan2.model/resolve-model]] (entrypoint fn: [[transduce-parsed]])</li>
<li>[[resolve]]</li>
<li>[[transduce-query]]</li>
<li>[[build]]</li>
<li>[[compile]]</li>
<li>[[results-transform]]</li>
<li>[[transduce-execute-with-connection]]</li>
</ol>

<p>The main pipeline entrypoint is [[transduce-unparsed]].</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.pipeline
  (:refer-clojure :exclude [compile resolve])
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [pretty.core :as pretty]
   [toucan2.connection :as conn]
   [toucan2.model :as model]
   [toucan2.query :as query]
   [toucan2.realize :as realize]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment s/keep-me)</pre></td></tr><tr><td class="docs"><p>pipeline</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Thunk function to call every time a query is executed if [[toucan2.execute/with-call-count]] is in use. Implementees
of [[transduce-execute-with-connection]] should invoke this every time a query gets executed. You can
use [[increment-call-count!]] to simplify the chore of making sure it's non-<code>nil</code> before invoking it.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic ^:no-doc *call-count-thunk*
  nil)</pre></td></tr><tr><td class="docs"><p>The final stage of the Toucan 2 query execution pipeline. Execute a compiled query (as returned by [[compile]]) with a
database connection, e.g. a <code>java.sql.Connection</code>, and transduce results with reducing function <code>rf</code>.</p>

<p>The only reason you should need to implement this method is if you are writing a new query execution backend.</p>

<p>TODO -- This name is a little long, maybe this should be called <code>transduce-execute</code> and the function should get
called something else</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti transduce-execute-with-connection
  {:arglists            '([rf conn query-type model compiled-query])
   :defmethod-arities   #{5}
   :dispatch-value-spec (types/or-default-spec
                         (s/cat :conn       ::types/dispatch-value.keyword-or-class
                                :query-type ::types/dispatch-value.query-type
                                :model      ::types/dispatch-value.model))}
  (fn [_rf conn query-type model _compiled-query]
    (u/dispatch-on-first-three-args conn query-type model)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod transduce-execute-with-connection :before :default
  &quot;Count all queries that are executed by calling [[*call-count-thunk*]] if bound.&quot;
  [_rf _conn _query-type _model query]
  (when *call-count-thunk*
    (*call-count-thunk*))
  query)</pre></td></tr><tr><td class="docs"><p>Get a connection from the current connection and call [[transduce-execute-with-connection]]. For DML queries, this
uses [[conn/with-transaction]] to get a connection and ensure we are in a transaction, if we're not already in one.
For non-DML queries this uses the usual [[conn/with-connection]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn- transduce-execute
  [rf query-type model compiled-query]
  (u/try-with-error-context {::rf rf}
    (if (isa? query-type :toucan.statement-type/DML)
      ;; For DML stuff we will run the whole thing in a transaction if we're not already in one. Not 100% sure this is
      ;; necessary since we would probably already be in one if we needed to be because stuff
      ;; like [[toucan2.tools.before-delete]] have to put us in one much earlier.
      (conn/with-transaction [conn nil {:nested-transaction-rule :ignore}]
        (transduce-execute-with-connection rf conn query-type model compiled-query))
      ;; otherwise we can just execute with a normal non-transaction query.
      (conn/with-connection [conn]
        (transduce-execute-with-connection rf conn query-type model compiled-query)))))</pre></td></tr><tr><td class="docs"><p>The transducer that should be applied to the reducing function executed when running a query of
<code>query-type</code> (see [[toucan2.types]]) for <code>model</code> (<code>nil</code> if the query is ran without a model, e.g.
with [[toucan2.execute/query]]). The default implementation returns <code>identity</code>; add your own implementations as
desired to apply additional results transforms.</p>

<p>Be sure to <code>comp</code> the transform from <code>next-method</code>:</p>

<p>```clj
(m/defmethod t2/results-transform [:toucan.query-type/select.* :my-model]
  [query-type model]
  (comp (next-method query-type model)
        (map (fn [instance]
               (assoc instance :num-cans 2)))))
```</p>

<p>It's probably better to put the transducer returned by <code>next-method</code> first in the call to <code>comp</code>, because <code>cond</code> works
like <code>-&gt;</code> when composing transducers, and since <code>next-method</code> is by definition the less-specific method, it makes
sense to call that transform before we apply our own. This means our own transforms will get to see the results of the
previous stage, rather than vice-versa.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti results-transform
  {:arglists            '([query-type model])
   :defmethod-arities   #{2}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.query-type-model)}
  u/dispatch-on-first-two-args)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod results-transform :default
  [_query-type _model]
  identity)</pre></td></tr><tr><td class="docs"><p>Compile a <code>built-query</code> to something that can be executed natively by the query execution backend, e.g. compile a Honey
SQL map to a <code>[sql &amp; args]</code> vector.</p>

<p>You can implement this method to write a custom query compilation backend, for example to compile some certain record
type in a special way. See [[toucan2.honeysql2]] for an example implementation.</p>

<p>In addition to dispatching on <code>query-type</code> and <code>model</code>, this dispatches on the type of <code>built-query</code>, in a special
way: for plain maps this will dispatch on the current [[map/backend]].</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti compile
  {:arglists            '([query-type model built-query])
   :defmethod-arities   #{3}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.query-type-model-query)}
  u/dispatch-on-first-three-args)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod compile :default
  &quot;Default implementation: return query as-is (i.e., consider it to already be compiled). Check that the query is non-nil
  and, if it is a collection, non-empty. Everything else is fair game.&quot;
  [_query-type _model query]
  (assert (and (some? query)
               (or (not (coll? query))
                   (seq query)))
          (format &quot;Compiled query should not be nil/empty. Got: %s&quot; (pr-str query)))
  query)</pre></td></tr><tr><td class="docs"><p>TODO -- this is a little JDBC-specific. What if some other query engine wants to run plain string queries without us
wrapping them in a vector? Maybe this is something that should be handled at the query execution level in
[[transduce-execute-with-connection]] instead. I guess that wouldn't actually work because we need to attach
metadata to compiled queries</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmethod compile [#_query-type :default #_model :default #_built-query String]
  &quot;Compile a string query. Default impl wraps the string in a vector and recursively calls [[compile]].&quot;
  [query-type model sql]
  (compile query-type model [sql]))</pre></td></tr><tr><td class="docs"><p>default implementation of [[compile]] for maps lives in [[toucan2.honeysql2]]</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Build a query by applying <code>parsed-args</code> to <code>resolved-query</code> into something that can be compiled by [[compile]], e.g.
build a Honey SQL query by applying <code>parsed-args</code> to an initial <code>resolved-query</code> map.</p>

<p>You can implement this method to write a custom query compilation backend, for example to compile some certain record
type in a special way. See [[toucan2.honeysql2]] for an example implementation.</p>

<p>In addition to dispatching on <code>query-type</code> and <code>model</code>, this dispatches on the type of <code>resolved-query</code>, in a special
way: for plain maps this will dispatch on the current [[map/backend]].</p>

<p>TODO -- does this belong here, or in [[toucan2.query]]?</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti build
  {:arglists            '([query-type model parsed-args resolved-query])
   :defmethod-arities   #{4}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.query-type-model-query)}
  (fn [query-type model _parsed-args resolved-query]
    (u/dispatch-on-first-three-args query-type model resolved-query)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod build :default
  [_query-type _model _parsed-args resolved-query]
  resolved-query)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod build [#_query-type :default #_model :default #_resolved-query nil]
  &quot;Something like (select my-model nil) should basically mean SELECT * FROM my_model WHERE id IS NULL&quot;
  [query-type model parsed-args _nil]
  ;; if `:query` is present but equal to `nil`, treat that as if the pk value IS NULL
  (let [parsed-args (assoc-in parsed-args [:kv-args :toucan/pk] nil)]
    (build query-type model parsed-args {})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod build [#_query-type :default #_model :default #_resolved-query Integer]
  &quot;Treat lone integers as queries to select an integer primary key.&quot;
  [query-type model parsed-args n]
  (build query-type model parsed-args (long n)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod build [#_query-type :default #_model :default #_resolved-query Long]
  &quot;Treat lone integers as queries to select an integer primary key.&quot;
  [query-type model parsed-args pk]
  (build query-type model (update parsed-args :kv-args assoc :toucan/pk pk) {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod build [#_query-type :default #_model :default #_query String]
  &quot;Default implementation for plain strings. Wrap the string in a vector and recurse.&quot;
  [query-type model parsed-args sql]
  (build query-type model parsed-args [sql]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod build [#_query-type :default #_model :default #_query clojure.lang.Sequential]
  &quot;Default implementation of vector [query &amp; args] queries.&quot;
  [query-type model {:keys [kv-args], :as parsed-args} sql-args]
  (when (seq kv-args)
    (throw (ex-info &quot;key-value args are not supported for [query &amp; args].&quot;
                    {:query-type     query-type
                     :model          model
                     :parsed-args    parsed-args
                     :method         #'build
                     :dispatch-value (m/dispatch-value build query-type model parsed-args sql-args)})))
  (next-method query-type model parsed-args sql-args))</pre></td></tr><tr><td class="docs"><p>default implementation of [[build]] for maps lives in [[toucan2.honeysql2]]</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Resolve a <code>queryable</code> to an actual query, e.g. resolve a named query defined by [[toucan2.tools.named-query]] to an
actual Honey SQL map.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti resolve
  {:arglists            '([query-type model queryable])
   :defmethod-arities   #{3}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.query-type-model-query)}
  u/dispatch-on-first-three-args)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod resolve :default
  &quot;The default implementation considers a query to already be resolved, and returns it as-is.&quot;
  [_query-type _model queryable]
  queryable)</pre></td></tr><tr><td class="docs"><p>The function to use when building a query. Normally [[build]], but you can bind this to intercept build behavior to
do something different.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic ^{:arglists '([query-type model parsed-args resolved-query])} *build*
  #'build)</pre></td></tr><tr><td class="docs"><p>The function to use when compiling a query. Normally [[compile]], but you can bind this to intercept normal
compilation behavior to do something different.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic ^{:arglists '([query-type model built-query])} *compile*
  #'compile)</pre></td></tr><tr><td class="docs"><p>The function to use to open a connection, execute, and transduce a query. Normally [[transduce-execute]]. The primary
use case for binding this is to intercept query execution and return some results without opening any connections.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:no-doc ^:dynamic ^{:arglists '([rf query-type model compiled-query])}
  *transduce-execute*
  #'transduce-execute)</pre></td></tr><tr><td class="docs"><p>The parsed args seen at the beginning of the pipeline. This is bound in case methods in later stages of the pipeline,
such as [[results-transform]], need it for one reason or another. (See for example [[toucan2.tools.default-fields]],
which applies different behavior if a query was initiated with <code>[model &amp; columns]</code> syntax vs. if it was not.)</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *parsed-args*
  nil)</pre></td></tr><tr><td class="docs"><p>The query after it has been resolved. This is bound in case methods in the later stages of the pipeline need it for one
reason or another.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *resolved-query*
  nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- transduce-compiled-query [rf query-type model compiled-query]
  (u/try-with-error-context [&quot;with compiled query&quot; {::compiled-query compiled-query}]
    (let [xform (results-transform query-type model)
          rf    (xform rf)]
      (*transduce-execute* rf query-type model compiled-query))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- transduce-built-query [rf query-type model built-query]
  (u/try-with-error-context [&quot;with built query&quot; {::built-query built-query}]
    (if (isa? built-query ::no-op)
      (let [init (rf)]
        (rf init))
      (let [compiled-query (*compile* query-type model built-query)]
        (transduce-compiled-query rf query-type model compiled-query)))))</pre></td></tr><tr><td class="docs"><p>One of the primary customization points for the Toucan 2 query execution pipeline. [[build]] and [[compile]] a
<code>resolved-query</code>, then open a connection, execute the query, and transduce the results
with [[transduce-execute-with-connection]] (using the [[results-transform]]).</p>

<p>You can implement this method to introduce custom behavior that should happen before a query is built or compiled,
e.g. transformations to the <code>parsed-args</code> or other shenanigans like changing underlying query type being
executed (e.g. [[toucan2.tools.after]], which 'upgrades' queries returning update counts or PKs to ones returning
instances so [[toucan2.tools.after-update]] and [[toucan2.tools.after-insert]] can be applied to affected rows).</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti transduce-query
  {:arglists            '([rf query-type model parsed-args resolved-query])
   :defmethod-arities   #{5}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.query-type-model-query)}
  (fn [_rf query-type model _parsed-args resolved-query]
    (u/dispatch-on-first-three-args query-type model resolved-query)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod transduce-query :default
  [rf query-type model parsed-args resolved-query]
  (let [built-query (*build* query-type model parsed-args resolved-query)]
    (transduce-built-query rf query-type model built-query)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- transduce-query* [rf query-type model parsed-args resolved-query]
  (let [parsed-args (dissoc parsed-args :queryable)]
    (binding [*resolved-query* resolved-query]
      (u/try-with-error-context [&quot;with resolved query&quot; {::resolved-query resolved-query}]
        (transduce-query rf query-type model parsed-args resolved-query)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- transduce-with-model
  [rf query-type model {:keys [queryable], :as parsed-args}]
  ;; if `*current-connectable*` is unbound but `model` has a default connectable, bind `*current-connectable*` and recur
  (if-let [model-connectable (when-not conn/*current-connectable*
                               (model/default-connectable model))]
    (binding [conn/*current-connectable* model-connectable]
      (transduce-with-model rf query-type model parsed-args))
    (binding [*parsed-args* parsed-args]
      (u/try-with-error-context [&quot;with parsed args&quot; {::query-type query-type, ::parsed-args parsed-args}]
        (let [queryable      (if (contains? parsed-args :queryable)
                               queryable
                               (or queryable {}))
              resolved-query (resolve query-type model queryable)]
          (transduce-query* rf query-type model parsed-args resolved-query))))))</pre></td></tr><tr><td class="docs"><p>Like [[transduce-unparsed]], but called with already-parsed args rather than unparsed args.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc transduce-parsed
  [rf query-type {:keys [modelable connectable], :as parsed-args}]
  ;; if `:connectable` was specified, bind it to [[conn/*current-connectable*]]; it should always override the current
  ;; connection (if one is bound). See docstring for [[toucan2.query/reducible-query]] for more info.
  ;;
  ;; TODO -- I'm not 100% sure this makes sense -- if we specify `:conn ::my-connection` and then want to do something
  ;; in a transaction for `::my-connection`? Shouldn't it still be done in a transaction?
  (if connectable
    (binding [conn/*current-connectable* connectable]
      (transduce-parsed rf query-type (dissoc parsed-args :connectable)))
    ;; if [[conn/*current-connectable*]] is not yet bound, then get the default connectable for the model and recur.
    (let [model (model/resolve-model modelable)]
      (u/try-with-error-context [&quot;with model&quot; {::model model}]
        (transduce-with-model rf query-type model (dissoc parsed-args :modelable))))))</pre></td></tr><tr><td class="docs"><p>Entrypoint to the Toucan 2 query execution pipeline. Parse <code>unparsed-args</code> for a <code>query-type</code>, then resolve model and
query, build and compile query, then open a connection, execute the query, and transduce the results.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc transduce-unparsed
  [rf query-type unparsed-args]
  (let [parsed-args (query/parse-args query-type unparsed-args)]
    (u/try-with-error-context [&quot;with unparsed args&quot; {::query-type query-type, ::unparsed-args unparsed-args}]
      (transduce-parsed rf query-type parsed-args))))</pre></td></tr><tr><td class="docs"><p>rf helper functions</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a version of reducing function <code>rf</code> with a zero-arity (initial value arity) that returns <code>init</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc with-init
  [rf init]
  (fn
    ([]    init)
    ([x]   (rf x))
    ([x y] (rf x y))))</pre></td></tr><tr><td class="docs"><p>The default reducing function for queries of <code>query-type</code>. Used for non-reducible operations
like [[toucan2.select/select]] or [[toucan2.execute/query]].</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti default-rf
  {:arglists            '([query-type])
   :defmethod-arities   #{1}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.query-type)}
  keyword)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod default-rf :toucan.result-type/update-count
  &quot;The reducing function for queries returning an update count. Sums all numbers passed in.&quot;
  [_query-type]
  (-&gt; (fnil + 0 0)
      (with-init 0)
      completing))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod default-rf :toucan.result-type/pks
  &quot;The reducing function for queries returning PKs. Presumably these will come back as a map, but that map doesn't need to
  be realized. This needs to be combined with a transducer like `map` [[toucan2.model/select-pks-fn]] to get the PKs
  themselves.&quot;
  [_query-type]
  conj)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod default-rf :toucan.result-type/*
  &quot;The default reducing function for all query types unless otherwise specified. Returns realized maps (by default, Toucan
  2 instances).&quot;
  [_query-type]
  ((map realize/realize) conj))</pre></td></tr><tr><td class="docs"><p>Return a transducer that transforms a reducing function <code>rf</code> so it always takes at most one value and returns the first
value from the results. This doesn't work for things that return update counts!</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc first-result-xform-fn
  [query-type]
  (if (isa? query-type :toucan.result-type/update-count)
    identity
    (fn [rf]
      (completing ((take 1) rf) first))))</pre></td></tr><tr><td class="docs"><p>Helper functions for implementing stuff like [[toucan2.select/select]]</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Helper for implementing things like [[toucan2.select/select]]. Transduce <code>unparsed-args</code> using the [[default-rf]] for
this <code>query-type</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc transduce-unparsed-with-default-rf
  [query-type unparsed-args]
  (assert (types/query-type? query-type))
  (let [rf (default-rf query-type)]
    (transduce-unparsed rf query-type unparsed-args)))</pre></td></tr><tr><td class="docs"><p>reducible versions for implementing stuff like [[toucan2.select/reducible-select]]</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Create a reducible with one of the functions in this namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- reducible-fn
  [f &amp; args]
  (reify
    clojure.lang.IReduceInit
    (reduce [_this rf init]
      ;; wrap the rf in `completing` so we don't end up doing any special one-arity TRANSDUCE stuff inside of REDUCE
      (apply f (completing (with-init rf init)) args))
    pretty/PrettyPrintable
    (pretty [_this]
      (list* `reducible-fn f args))))</pre></td></tr><tr><td class="docs"><p>Helper for implementing things like [[toucan2.select/reducible-select]]. A reducible version
of [[transduce-unparsed]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc reducible-unparsed
  [query-type unparsed]
  (reducible-fn transduce-unparsed query-type unparsed))</pre></td></tr><tr><td class="docs"><p>Helper for implementing things like [[toucan2.execute/reducible-query]] that don't need arg parsing. A reducible
version of [[transduce-parsed]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc reducible-parsed-args
  [query-type parsed-args]
  (reducible-fn transduce-parsed query-type parsed-args))</pre></td></tr><tr><td class="docs"><p>Misc util functions. TODO -- I don't think this belongs here; hopefully this can live somewhere where we can call
it <code>compile</code> instead.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Helper for compiling a <code>built-query</code> to something that can be executed natively.</p>
</td><td class="codes"><pre class="brush: clojure">(defn compile*
  ([built-query]
   (compile* nil built-query))
  ([query-type built-query]
   (compile* query-type nil built-query))
  ([query-type model built-query]
   (compile query-type model built-query)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.protocols" name="toucan2.protocols"><h1 class="project-name">toucan2.protocols</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.protocols
  (:require
   [potemkin :as p]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(p/defprotocol+ IModel
  :extend-via-metadata true
  &quot;Protocol for something that is-a or has-a model.&quot;
  (model [this]
    &quot;Get the Toucan model associated with `this`.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol IModel
  nil
  (model [_this]
    nil)

  Object
  (model [_this]
    nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(p/defprotocol+ IWithModel
  :extend-via-metadata true
  &quot;Protocol for something that has-a model that supports creating a copy with a different model.&quot;
  (^{:style/indent nil} with-model [this new-model]
    &quot;Return a copy of `instance` with its model set to `new-model.`&quot;))</pre></td></tr><tr><td class="docs"><p>there are some default impls of [[with-model]] in [[toucan2.instance]]</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Protocol for something that records the changes made to it, e.g. a Toucan instance.</p>
</td><td class="codes"><pre class="brush: clojure">(p/defprotocol+ IRecordChanges
  (original [instance]
    &quot;Get the original version of `instance` as it appeared when it first came out of the DB.&quot;)
  (^{:style/indent nil} with-original [instance new-original]
   &quot;Return a copy of `instance` with its `original` map set to `new-original`.&quot;)
  (current [instance]
    &quot;Return the underlying map representing the current state of an `instance`.&quot;)
  (^{:style/indent nil} with-current [instance new-current]
   &quot;Return a copy of `instance` with its underlying `current` map set to `new-current`.&quot;)
  (changes [instance]
    &quot;Get a map with any changes made to `instance` since it came out of the DB. Only includes keys that have been
    added or given different values; keys that were removed are not counted. Returns `nil` if there are no changes.&quot;))</pre></td></tr><tr><td class="docs"><p><code>nil</code> and <code>IPersistentMap</code> can implement the methods that make sense for them: <code>nil</code> or a plain map doesn't have any
changes, so [[changes]] can return <code>nil</code>. I don't know what sort of implementation for stuff like
[[with-original]] or [[with-current]] makes sense so I'm not implementing those for now.</p>
</td><td class="codes"><pre class="brush: clojure">(extend-protocol IRecordChanges
  nil
  (original [_this]
    nil)
  ;; (with-original [this])
  (current [_this]
    nil)
  ;; (with-current [this])
  (changes [_this]
    nil)

  ;; generally just treat a plain map like an instance with nil model/and original = nil,
  ;; and no-op for anything that would require &quot;upgrading&quot; the map to an actual instance in such a way that if
  ;;
  ;;    (= plain-map instance)
  ;;
  ;; then
  ;;
  ;;    (= (f plain-map) (f instance))
  clojure.lang.IPersistentMap
  (original [_this]
    nil)
  (with-original [this _m]
    this)
  (current [this]
    this)
  (with-current [_this new-current]
    new-current)

  ;; treat the entire map as `changes` -- that way if you accidentally do something like
  ;;
  ;; (merge plain-map instance)
  ;;
  ;; in a `before-update` method, you don't accidentally shoot yourself in the foot and break `update!` or the like.
  (changes [this]
    this))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(p/defprotocol+ IDispatchValue
  :extend-via-metadata true
  &quot;Protocol to get the value to use for multimethod dispatch in Toucan from something.&quot;
  (dispatch-value
   [this]
   &quot;Get the value that we should dispatch off of in multimethods for `this`. By default, the dispatch of a keyword is
    itself while the dispatch value of everything else is its [[type]].&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol IDispatchValue
  Object
  (dispatch-value [x]
    (type x))

  nil
  (dispatch-value [_nil]
    nil)

  clojure.lang.Keyword
  (dispatch-value [k]
    k))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(p/defprotocol+ IDeferrableUpdate
  (deferrable-update [this k f]
    &quot;Like [[clojure.core/update]], but this update can be deferred until later. For things like transient rows where you
  might want to apply transforms to values that ultimately get realized, but not *cause* them to be realized. Unlike
  [[clojure.core/update]], does not support additional args to pass to `f`.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol IDeferrableUpdate
  nil
  (deferrable-update [_this k f]
    (update nil k f))

  clojure.lang.IPersistentMap
  (deferrable-update [m k f]
    (update m k f)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.query" name="toucan2.query"><h1 class="project-name">toucan2.query</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.query
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.log :as log]
   [toucan2.model :as model]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment types/keep-me)</pre></td></tr><tr><td class="docs"><p>[[parse-args]]</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::default-args.connectable
  (s/? (s/cat :key         (partial = :conn)
              :connectable any?)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::default-args.modelable.column
  (s/or :column      keyword?
        :expr-column (s/cat :expr   any?
                            :column (s/? keyword?))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::default-args.modelable
  (s/or
   :modelable         (complement sequential?)
   :modelable-columns (s/cat :modelable some? ; can't have a nil model. Or can you?
                             :columns   (s/* (s/nonconforming ::default-args.modelable.column)))))</pre></td></tr><tr><td class="docs"><p>TODO -- can we use [[s/every-kv]] for this stuff?</p>
</td><td class="codes"><pre class="brush: clojure">(s/def ::default-args.kv-args
  (s/* (s/cat
        :k any?
        :v any?)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::default-args.queryable
  (s/? any?))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::default-args
  (s/cat
   :connectable ::default-args.connectable
   :modelable   ::default-args.modelable
   :kv-args     ::default-args.kv-args
   :queryable   ::default-args.queryable))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def :toucan2.query.parsed-args/modelable
  some?)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def :toucan2.query.parsed-args/kv-args
  (some-fn nil? map?))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def :toucan2.query.parsed-args/columns
  (some-fn nil? sequential?))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::parsed-args
  (s/keys :req-un [:toucan2.query.parsed-args/modelable]
          :opt-un [:toucan2.query.parsed-args/kv-args
                   :toucan2.query.parsed-args/columns]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- validate-parsed-args [parsed-args]
  (u/try-with-error-context [&quot;validate parsed args&quot; {::parsed-args parsed-args}]
    (let [result (s/conform ::parsed-args parsed-args)]
      (when (s/invalid? result)
        (throw (ex-info (format &quot;Invalid parsed args: %s&quot; (s/explain-str ::parsed-args parsed-args))
                        (s/explain-data ::parsed-args parsed-args)))))))</pre></td></tr><tr><td class="docs"><p>Parse <code>unparsed-args</code> for <code>query-type</code> with the given <code>spec</code>. See documentation for [[parse-args]] for more details.</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse-args-with-spec
  [query-type spec unparsed-args]
  (u/try-with-error-context [&quot;parse args&quot; {::query-type query-type, ::unparsed-args unparsed-args}]
    (log/debugf &quot;Parse args for query type %s %s&quot; query-type unparsed-args)
    (let [parsed (s/conform spec unparsed-args)]
      (when (s/invalid? parsed)
        (throw (ex-info (format &quot;Don't know how to interpret %s args: %s&quot;
                                (pr-str query-type)
                                (s/explain-str spec unparsed-args))
                        (s/explain-data spec unparsed-args))))
      (log/tracef &quot;Conformed args: %s&quot; parsed)
      (let [parsed (cond-&gt; parsed
                     (:modelable parsed)                 (merge (let [[modelable-type x] (:modelable parsed)]
                                                                  (case modelable-type
                                                                    :modelable         {:modelable x}
                                                                    :modelable-columns x)))
                     (:connectable parsed)               (update :connectable :connectable)
                     (not (contains? parsed :queryable)) (assoc :queryable {})
                     (seq (:kv-args parsed))             (update :kv-args (fn [kv-args]
                                                                            (into {} (map (juxt :k :v)) kv-args))))]
        (log/debugf &quot;Parsed =&gt; %s&quot; parsed)
        (validate-parsed-args parsed)
        parsed))))</pre></td></tr><tr><td class="docs"><p><code>parse-args</code> takes a sequence of unparsed args passed to something like [[toucan2.select/select]] and parses them into
a parsed args map. The default implementation uses [[clojure.spec.alpha]] to parse the args according to <code>args-spec</code>.</p>

<p>These keys are commonly returned by several of the different implementations <code>parse-args</code>, and other tooling is
build to leverage them:</p>

<ul>
<li><p><code>:modelable</code> -- usually the first of the <code>unparsed-args</code>, this is the thing that should get resolved to a model
with [[toucan2.model/resolve-model]].</p></li>
<li><p><code>:queryable</code> -- something that can be resolved to a query, for example a map or integer or 'named query' keyword.
The resolved query is ultimately combined with other parsed args and built into something like a Honey SQL map, then
compiled to something like SQL.</p></li>
<li><p><code>:kv-args</code> -- map of key-value pairs. When [[build]] builds a query, it calls [[apply-kv-arg]] for each of the
key-value pairs. The default behavior is to append a Honey SQL <code>:where</code> clause based on the pair; but you can
customize the behavior for specific keywords to do other things -- <code>:toucan/pk</code> is one such example.</p></li>
<li><p><code>:columns</code> -- for things that return instances, <code>:columns</code> is a sequence of columns to return. These are commonly
specified by wrapping the modelable in a <code>[modelable &amp; columns]</code> vector.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti parse-args
  {:arglists            '([query-type unparsed-args])
   :defmethod-arities   #{2}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.query-type)}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod parse-args :default
  &quot;The default implementation calls [[parse-args-with-spec]] with the `:toucan2.query/default-args` spec.&quot;
  [query-type unparsed-args]
  (parse-args-with-spec query-type ::default-args unparsed-args))</pre></td></tr><tr><td class="docs"><p>Part of the default [[pipeline/build]] for maps: applying key-value args</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Merge a key-value pair into a <code>query</code>, presumably a map. What this means depends on
the [[toucan2.protocols/dispatch-value]] of <code>query</code> -- for a plain map, the default Honey SQL backend applies <code>k</code> and
<code>v</code> as a <code>:where</code> condition:</p>

<p>```clj
(apply-kv-arg :default {} :k :v)
;; =>
{:where [:= :k :v]}
```</p>

<p>You can add new implementations of this method to special behaviors for support arbitrary keys, or to support new
query backends. <code>:toucan/pk</code> support is implemented this way.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti apply-kv-arg
  {:arglists            '([model resolved-query k v])
   :defmethod-arities   #{4}
   :dispatch-value-spec (types/or-default-spec
                         (s/cat :model          ::types/dispatch-value.model
                                :resolved-query ::types/dispatch-value.query
                                :k              keyword?))}
  u/dispatch-on-first-three-args)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  ;; with a composite PK like
  [:id :name]
  ;; we need to be able to handle either
  [:in [[&quot;BevMo&quot; 4] [&quot;BevLess&quot; 5]]]
  ;; or
  [:between [&quot;BevMo&quot; 4] [&quot;BevLess&quot; 5]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- toucan-pk-composite-values** [pk-columns tuple]
  {:pre [(= (count pk-columns) (count tuple))]}
  (map-indexed (fn [i col]
                 {:col col, :v (nth tuple i)})
               pk-columns))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- toucan-pk-nested-composite-values [pk-columns tuples]
  (-&gt;&gt; (mapcat (fn [tuple]
                 (toucan-pk-composite-values** pk-columns tuple))
               tuples)
       (group-by :col)
       (map (fn [[col ms]]
              {:col col, :v (mapv :v ms)}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- toucan-pk-composite-values* [pk-columns tuple]
  (if (some sequential? tuple)
    (toucan-pk-nested-composite-values pk-columns tuple)
    (toucan-pk-composite-values** pk-columns tuple)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- toucan-pk-fn-values [pk-columns fn-name tuples]
  (-&gt;&gt; (mapcat (fn [tuple]
                 (toucan-pk-composite-values* pk-columns tuple))
               tuples)
       (group-by :col)
       (map (fn [[col ms]]
              {:col col, :v (into [fn-name] (map :v) ms)}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- toucan-pk-composite-values [pk-columns tuple]
  {:pre [(sequential? tuple)], :post [(sequential? %) (every? map? %) (every? :col %)]}
  (if (keyword? (first tuple))
    (toucan-pk-fn-values pk-columns (first tuple) (rest tuple))
    (toucan-pk-composite-values* pk-columns tuple)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- apply-non-composite-toucan-pk [model m pk-column v]
  ;; unwrap the value if we got something like `:toucan/pk [1]`
  (let [v (if (and (sequential? v)
                   (not (keyword? (first v)))
                   (= (count v) 1))
            (first v)
            v)]
    (apply-kv-arg model m pk-column v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- apply-composite-toucan-pk [model m pk-columns v]
  (reduce
   (fn [m {:keys [col v]}]
     (apply-kv-arg model m col v))
   m
   (toucan-pk-composite-values pk-columns v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod apply-kv-arg :around [#_model :default #_query :default #_k :toucan/pk]
  &quot;Implementation for handling key-value args for `:toucan/pk`.
  This is an `:around` so we can intercept the normal handler. This 'unpacks' the PK and ultimately uses the normal
  calls to [[apply-kv-arg]].&quot;
  [model honeysql _k v]
  ;; `fn-name` here would be if you passed something like `:toucan/pk [:in 1 2]` -- the fn name would be `:in` -- and we
  ;; pass that to [[condition-&gt;honeysql-where-clause]]
  (let [pk-columns (model/primary-keys model)]
    (log/debugf &quot;apply :toucan/pk %s for primary keys&quot; v)
    (if (= (count pk-columns) 1)
      (apply-non-composite-toucan-pk model honeysql (first pk-columns) v)
      (apply-composite-toucan-pk model honeysql pk-columns v))))</pre></td></tr><tr><td class="docs"><p>Convenience. Merge a map of <code>kv-args</code> into a resolved <code>query</code> with repeated calls to [[apply-kv-arg]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn apply-kv-args
  [model query kv-args]
  (log/debugf &quot;Apply kv-args %s&quot; kv-args)
  (reduce
   (fn [query [k v]]
     (apply-kv-arg model query k v))
   query
   kv-args))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.realize" name="toucan2.realize"><h1 class="project-name">toucan2.realize</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.realize
  (:require
   [potemkin :as p]
   [toucan2.log :as log]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>TODO -- this should probably be moved to [[toucan2.protocols]], and be renamed <code>IRealize</code> for consistency.</p>
</td><td class="codes"><pre class="brush: clojure">(p/defprotocol+ Realize
  (realize [x]
    &quot;Fully realize either a reducible query, or a result row from that query.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- realize-IReduceInit [this]
  (log/tracef &quot;realize IReduceInit %s&quot; (symbol (.getCanonicalName (class this))))
  (u/try-with-error-context [&quot;realize IReduceInit&quot; {::reducible this}]
    (into []
          (map (fn [row]
                 (log/tracef &quot;realize row ^%s %s&quot; (some-&gt; row class .getCanonicalName symbol) row)
                 (u/try-with-error-context [&quot;realize row&quot; {::row row}]
                   (realize row))))
          this)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol Realize
  Object
  (realize [this]
    (log/tracef &quot;Already realized: %s&quot; (class this))
    this)

  ;; Eduction is assumed to be for query results.
  ;; TODO -- isn't an Eduction an IReduceInit??
  clojure.core.Eduction
  (realize [this]
    (into [] (map realize) this))

  clojure.lang.IReduceInit
  (realize [this]
    (realize-IReduceInit this))

  nil
  (realize [_]
    nil))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.save" name="toucan2.save"><h1 class="project-name">toucan2.save</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.save
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.connection :as conn]
   [toucan2.instance :as instance]
   [toucan2.log :as log]
   [toucan2.model :as model]
   [toucan2.protocols :as protocols]
   [toucan2.types :as types]
   [toucan2.update :as update]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment s/keep-me
         types/keep-me)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmulti save!*
  {:arglists            '([object])
   :defmethod-arities   #{1}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}
  (fn [object]
    (protocols/dispatch-value (protocols/model object))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod save!* :around :default
  [object]
  (u/try-with-error-context [&quot;save changes&quot; {::model   (protocols/model object)
                                             ::object  object
                                             ::changes (protocols/changes object)}]
    (log/debugf &quot;Save %s %s changes %s&quot; (protocols/model object) object (protocols/changes object))
    (next-method object)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod save!* :default
  [object]
  (assert (instance/instance? object)
          (format &quot;Don't know how to save something that's not a Toucan instance. Got: ^%s %s&quot;
                  (some-&gt; object class .getCanonicalName)
                  (pr-str object)))
  (if-let [changes (not-empty (protocols/changes object))]
    (let [model         (protocols/model object)
          pk-values     (select-keys object (model/primary-keys (protocols/model object)))
          rows-affected (update/update! model pk-values changes)]
      (when-not (pos? rows-affected)
        (throw (ex-info (format &quot;Unable to save object: %s with primary key %s does not exist.&quot;
                                (pr-str model)
                                (pr-str pk-values))
                        {:object object
                         :pk     pk-values})))
      (when (&gt; rows-affected 1)
        (log/warnf &quot;Warning: more than 1 row affected when saving %s with primary key %s&quot; model pk-values))
      (instance/reset-original object))
    object))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn save!
  ([object]
   (save!* object))
  ([connectable object]
   (if connectable
     (binding [conn/*current-connectable* connectable]
       (save!* object))
     (save!* object))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.select" name="toucan2.select"><h1 class="project-name">toucan2.select</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation of [[select]] and variations.</p>

<p>The args spec used by [[select]] lives in [[toucan2.query]], specifically <code>:toucan2.query/default-args</code>.</p>

<p>Code for building Honey SQL for a SELECT lives in [[toucan2.honeysql2]].</p>

<h3>Functions that return primary keys</h3>

<p>Functions that return primary keys such as [[select-pks-set]] determine which primary keys to return by
calling [[toucan2.model/select-pks-fn]], which is based on the model's implementation
of [[toucan2.model/primary-keys]]. Models with just a single primary key column will return primary keys 'unwrapped',
i.e., the values of that column will be returned directly. Models with compound primary keys (i.e., primary keys
consisting of more than one column) will be returned in vectors as if by calling <code>juxt</code>.</p>

<p>```clj
;; A model with a one-column primary key, :id
(t2/select-pks-vec :models/venues :category "bar")
;; => [1 2]</p>

<p>;; A model with a compound primary key, [:id :name]
(t2/select-pks-vec :models/venues.compound-key :category "bar")
;; => [[1 "Tempest"] [2 "Ho's Tavern"]]
```</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.select
  (:refer-clojure :exclude [count])
  (:require
   [clojure.spec.alpha :as s]
   [toucan2.log :as log]
   [toucan2.model :as model]
   [toucan2.pipeline :as pipeline]
   [toucan2.realize :as realize]
   [toucan2.types :as types]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment s/keep-me
         types/keep-me)</pre></td></tr><tr><td class="docs"><p>Like [[select]], but returns an <code>IReduceInit</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reducible-select
  {:arglists '([modelable-columns &amp; kv-args? query?]
               [:conn connectable modelable-columns &amp; kv-args? query?])}
  [&amp; unparsed-args]
  (pipeline/reducible-unparsed :toucan.query-type/select.instances unparsed-args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn select
  {:arglists '([modelable-columns &amp; kv-args? query?]
               [:conn connectable modelable-columns &amp; kv-args? query?])}
  [&amp; unparsed-args]
  (pipeline/transduce-unparsed-with-default-rf :toucan.query-type/select.instances unparsed-args))</pre></td></tr><tr><td class="docs"><p>Like [[select]], but only fetches a single row, and returns only that row.</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-one
  {:arglists '([modelable-columns &amp; kv-args? query?]
               [:conn connectable modelable-columns &amp; kv-args? query?])}
  [&amp; unparsed-args]
  (let [query-type :toucan.query-type/select.instances
        rf         (pipeline/default-rf query-type)
        xform      (pipeline/first-result-xform-fn query-type)]
    (pipeline/transduce-unparsed (xform rf) query-type unparsed-args)))</pre></td></tr><tr><td class="docs"><p>Like [[reducible-select]], but returns a reducible sequence of results of <code>(f row)</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-fn-reducible
  {:arglists '([f modelable-columns &amp; kv-args? query?]
               [f :conn connectable modelable-columns &amp; kv-args? query?])}
  [f &amp; unparsed-args]
  (eduction
   (map f)
   (pipeline/reducible-unparsed :toucan.query-type/select.instances.fns unparsed-args)))</pre></td></tr><tr><td class="docs"><p>Like [[select]], but returns a <em>set</em> of values of <code>(f instance)</code> for the results. Returns <code>nil</code> if the set is empty.</p>

<p>```clj
(t2/select-fn-set (comp str/upper-case :category) :models/venues :category "bar")
;; =></p>

<h1>{"BAR"}</h1>

<p>```</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-fn-set
  {:arglists '([f modelable-columns &amp; kv-args? query?]
               [f :conn connectable modelable-columns &amp; kv-args? query?])}
  [f &amp; unparsed-args]
  (let [f     (comp realize/realize f)
        rf    (pipeline/with-init conj #{})
        xform (map f)]
    (not-empty (pipeline/transduce-unparsed (xform rf) :toucan.query-type/select.instances.fns unparsed-args))))</pre></td></tr><tr><td class="docs"><p>Like [[select]], but returns a <em>vector</em> of values of <code>(f instance)</code> for the results. Returns <code>nil</code> if the vector is
empty.</p>

<p>```clj
(t2/select-fn-vec (comp str/upper-case :category) :models/venues :category "bar")
;; =>
["BAR" "BAR"]
```</p>

<p>NOTE: If your query does not specify an <code>:order-by</code> clause (or equivalent), the results are like indeterminate. Keep
this in mind!</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-fn-vec
  {:arglists '([f modelable-columns &amp; kv-args? query?]
               [f :conn connectable modelable-columns &amp; kv-args? query?])}
  [f &amp; unparsed-args]
  (let [f     (comp realize/realize f)
        rf    (pipeline/with-init conj [])
        xform (map f)]
    (not-empty (pipeline/transduce-unparsed (xform rf) :toucan.query-type/select.instances.fns unparsed-args))))</pre></td></tr><tr><td class="docs"><p>Like [[select-one]], but applies <code>f</code> to the result.</p>

<p>```clj
(t2/select-one-fn :id :models/people :name "Cam")
;; => 1
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-one-fn
  {:arglists '([f modelable-columns &amp; kv-args? query?]
               [f :conn connectable modelable-columns &amp; kv-args? query?])}
  [f &amp; unparsed-args]
  (let [query-type :toucan.query-type/select.instances.fns
        f          (comp realize/realize f)
        rf         (pipeline/with-init conj [])
        xform      (comp (map f)
                         (pipeline/first-result-xform-fn query-type))]
    (pipeline/transduce-unparsed (xform rf) query-type unparsed-args)))</pre></td></tr><tr><td class="docs"><p>Returns a reducible sequence of all primary keys</p>

<p>```clj
(into [] (t2/select-pks-reducible :models/venues :category "bar"))
;; => [1 2]
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-pks-reducible
  {:arglists '([modelable-columns &amp; kv-args? query?]
               [:conn connectable modelable-columns &amp; kv-args? query?])}
  [modelable &amp; unparsed-args]
  (apply select-fn-reducible (model/select-pks-fn modelable) modelable unparsed-args))</pre></td></tr><tr><td class="docs"><p>Returns a <em>set</em> of all primary keys (as determined by [[toucan2.model/primary-keys]]
and [[toucan2.model/select-pks-fn]]) of instances matching the query. Models with just a single primary key columns
will be 'unwrapped' (i.e., the values of that column will be returned); models with compound primary keys (i.e., more
than one column) will be returned in vectors as if by calling <code>juxt</code>.</p>

<p>```clj
(t2/select-pks-set :models/venues :category "bar")
;; => #{1 2}
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-pks-set
  {:arglists '([modelable-columns &amp; kv-args? query?]
               [:conn connectable modelable-columns &amp; kv-args? query?])}
  [modelable &amp; unparsed-args]
  (apply select-fn-set (model/select-pks-fn modelable) modelable unparsed-args))</pre></td></tr><tr><td class="docs"><p>Returns a <em>vector</em> of all primary keys (as determined by [[toucan2.model/primary-keys]]
and [[toucan2.model/select-pks-fn]]) of instances matching the query. Models with just a single primary key columns
will be 'unwrapped' (i.e., the values of that column will be returned); models with compound primary keys (i.e., more
than one column) will be returned in vectors as if by calling <code>juxt</code>.</p>

<p>```clj
(t2/select-pks-vec :models/venues :category "bar")
;; => [1 2]
```</p>

<p>NOTE: If your query does not specify an <code>:order-by</code> clause (or equivalent), the results are like indeterminate. Keep
this in mind!</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-pks-vec
  {:arglists '([modelable-columns &amp; kv-args? query?]
               [:conn connectable modelable-columns &amp; kv-args? query?])}
  [modelable &amp; unparsed-args]
  (apply select-fn-vec (model/select-pks-fn modelable) modelable unparsed-args))</pre></td></tr><tr><td class="docs"><p>Return the primary key of the first row matching the query. Models with just a single primary key columns will be
'unwrapped' (i.e., the values of that column will be returned); models with compound primary keys (i.e., more than one
column) will be returned in vectors as if by calling <code>juxt</code>.</p>

<p>```clj
(t2/select-one-pk :models/people :name "Cam")
;; => 1
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-one-pk
  {:arglists '([modelable-columns &amp; kv-args? query?]
               [:conn connectable modelable-columns &amp; kv-args? query?])}
  [modelable &amp; unparsed-args]
  (apply select-one-fn (model/select-pks-fn modelable) modelable unparsed-args))</pre></td></tr><tr><td class="docs"><p>Return a map of <code>(f1 instance)</code> -> <code>(f2 instance)</code> for instances matching the query.</p>

<p>```clj
(t2/select-fn->fn :id (comp str/upper-case :name) :models/people)
;; => {1 "CAM", 2 "SAM", 3 "PAM", 4 "TAM"}
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-fn-&gt;fn
  {:arglists '([f1 f2 modelable-columns &amp; kv-args? query?]
               [f1 f2 :conn connectable modelable-columns &amp; kv-args? query?])}
  [f1 f2 &amp; unparsed-args]
  (let [f1    (comp realize/realize f1)
        f2    (comp realize/realize f2)
        rf    (pipeline/with-init conj {})
        xform (map (juxt f1 f2))]
    (pipeline/transduce-unparsed (xform rf) :toucan.query-type/select.instances unparsed-args)))</pre></td></tr><tr><td class="docs"><p>The inverse of [[select-pk->fn]]. Return a map of <code>(f instance)</code> -> <em>primary key</em> for instances matching the query.</p>

<p>```clj
(t2/select-fn->pk (comp str/upper-case :name) :models/people)
;; => {"CAM" 1, "SAM" 2, "PAM" 3, "TAM" 4}
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-fn-&gt;pk
  {:arglists '([f modelable-columns &amp; kv-args? query?]
               [f :conn connectable modelable-columns &amp; kv-args? query?])}
  [f modelable &amp; args]
  (let [pks-fn (model/select-pks-fn modelable)]
    (apply select-fn-&gt;fn f pks-fn modelable args)))</pre></td></tr><tr><td class="docs"><p>The inverse of [[select-fn->pk]]. Return a map of <em>primary key</em> -> <code>(f instance)</code> for instances matching the query.</p>

<p>```clj
(t2/select-pk->fn (comp str/upper-case :name) :models/people)
;; => {1 "CAM", 2 "SAM", 3 "PAM", 4 "TAM"}
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn select-pk-&gt;fn
  {:arglists '([f modelable-columns &amp; kv-args? query?]
               [f :conn connectable modelable-columns &amp; kv-args? query?])}
  [f modelable &amp; args]
  (let [pks-fn (model/select-pks-fn modelable)]
    (apply select-fn-&gt;fn pks-fn f modelable args)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- count-rf []
  (let [logged-warning? (atom false)
        log-warning     (fn []
                          (when-not @logged-warning?
                            (log/warnf &quot;Warning: inefficient count query. See documentation for toucan2.select/count.&quot;)
                            (reset! logged-warning? true)))]
    (fn count-rf*
      ([] 0)
      ([acc] acc)
      ([acc row]
       (if (:count row)
         (+ acc (:count row))
         (do (log-warning)
             (inc acc)))))))</pre></td></tr><tr><td class="docs"><p>Like [[select]], but returns the number of rows that match in an efficient way.</p>

<h3>Implementation note:</h3>

<p>The default Honey SQL 2 map query compilation backend builds an efficient</p>

<p>```sql
SELECT count(*) AS "count" FROM ...
```</p>

<p>query. Custom query compilation backends should do the equivalent by implementing [[toucan2.pipeline/build]] for the
query type <code>:toucan.query-type/select.count</code> and build a query that returns the key <code>:count</code>, If an efficient
implementation does not exist, this will fall back to simply counting all matching rows.</p>
</td><td class="codes"><pre class="brush: clojure">(defn count
  {:arglists '([modelable-columns &amp; kv-args? query?]
               [:conn connectable modelable-columns &amp; kv-args? query?])}
  [&amp; unparsed-args]
  (pipeline/transduce-unparsed (count-rf) :toucan.query-type/select.count unparsed-args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- exists?-rf
  ([] false)
  ([acc] acc)
  ([_acc row]
   (if (contains? row :exists)
     (let [exists (:exists row)
           result (if (integer? exists)
                    (pos? exists)
                    (boolean exists))]
       (if (true? result)
         (reduced true)
         false))
     (do
       (log/warnf &quot;Warning: inefficient exists? query. See documentation for toucan2.select/exists?.&quot;)
       (reduced true)))))</pre></td></tr><tr><td class="docs"><p>Like [[select]], but returns whether or not <em>any</em> rows match in an efficient way.</p>

<h3>Implementation note:</h3>

<p>The default Honey SQL 2 map query compilation backend builds an efficient</p>

<p>```sql
SELECT exists(SELECT 1 FROM ... WHERE ...) AS exists
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn exists?
  {:arglists '([modelable-columns &amp; kv-args? query?]
               [:conn connectable modelable-columns &amp; kv-args? query?])}
  [&amp; unparsed-args]
  (pipeline/transduce-unparsed exists?-rf :toucan.query-type/select.exists unparsed-args))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.after" name="toucan2.tools.after"><h1 class="project-name">toucan2.tools.after</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Common code shared by various <code>after-</code> methods. Since the <code>after</code> methods operate over instances, we need to upgrade
<code>result-type/pks</code> and <code>result-type/update-count</code> queries to <code>result-type/instances</code>, run them with the 'upgraded'
result type, run our after stuff on each row, and then return the original results.</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.after
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.log :as log]
   [toucan2.model :as model]
   [toucan2.pipeline :as pipeline]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>Should return a function with the signature</p>

<p>```clj
(f instance)
```</p>

<p>This function is only done for side-effects for query types that return update counts or PKs.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti each-row-fn
  {:arglists '([query-type model])
   :defmethod-arities #{2}
   :dispatch-value-spec ::types/dispatch-value.query-type-model}
  u/dispatch-on-first-two-args)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod each-row-fn :after :default
  [query-type f]
  (assert (fn? f)
          (format &quot;Expected each-row-fn for query type %s to return a function, got ^%s %s&quot;
                  (pr-str query-type)
                  (some-&gt; f class .getCanonicalName)
                  (pr-str f)))
  f)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/results-transform [#_query-type :toucan.result-type/instances #_model ::model]
  [query-type model]
  ;; if there's no [[each-row-fn]] for this `query-type` then we don't need to apply any transforms. Example: maybe a
  ;; model has an [[each-row-fn]] for `INSERT` queries, but not for `UPDATE`. Since the model derives from `::model`, we
  ;; end up here either way. But if `query-type` is `UPDATE` we shouldn't touch the query.
  (if (m/is-default-primary-method? each-row-fn [query-type model])
    (next-method query-type model)
    (let [row-fn (each-row-fn query-type model)
          row-fn (fn [row]
                   (u/try-with-error-context [&quot;Apply after row fn&quot; {::query-type query-type, ::model model}]
                     (log/debugf &quot;Apply after %s for %s&quot; query-type model)
                     (let [result (row-fn row)]
                       ;; if the row fn didn't return something (not generally necessary for something like
                       ;; `after-update` which is always done for side effects) then return the original row. We still
                       ;; need it for stuff like getting the PKs back out.
                       (if (some? result)
                         result
                         row))))
          xform  (map row-fn)]
      (comp xform
            (next-method query-type model)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmulti ^:private result-type-rf
  {:arglists            '([original-query-type model rf])
   :defmethod-arities   #{3}
   :dispatch-value-spec ::types/dispatch-value.query-type}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod result-type-rf :toucan.result-type/update-count
  &quot;Reducing function transform that will return the count of rows.&quot;
  [_original-query-type _model rf]
  ((map (constantly 1))
   rf))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod result-type-rf :toucan.result-type/pks
  &quot;Reducing function transform that will return just the PKs (as single values or vectors of values) by getting them from
  row maps (instances).&quot;
  [_original-query-type model rf]
  (let [pks-fn (model/select-pks-fn model)]
    ((map (fn [row]
            (assert (map? row))
            (pks-fn row)))
     rf)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(derive ::query-type :toucan.query-type/abstract)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-query [#_query-type     ::query-type
                                       #_model          ::model
                                       #_resolved-query :default]
  &quot;'Upgrade' a query so that it returns instances, and run the upgraded query so that we can apply [[each-row-fn]] to the
  results. Then apply [[result-type-rf]] to the results of the original expected type are ultimately returned.&quot;
  [rf query-type model parsed-args resolved-query]
  (if (or
       ;; only &quot;upgrade&quot; the query if there's an applicable [[each-row-fn]] to apply.
       (m/is-default-primary-method? each-row-fn [query-type model])
       ;; there's no need to &quot;upgrade&quot; the query if it's already returning instances.
       (isa? query-type :toucan.result-type/instances))
    (next-method rf query-type model parsed-args resolved-query)
    ;; otherwise we need to run an upgraded query but then transform the results back to the originals
    ;; with [[result-type-rf]]
    (let [upgraded-type (types/similar-query-type-returning query-type :toucan.result-type/instances)
          _             (assert upgraded-type (format &quot;Don't know how to upgrade a %s query to one returning instances&quot;
                                                      query-type))
          rf*           (result-type-rf query-type model rf)]
      (pipeline/transduce-query rf* upgraded-type model parsed-args resolved-query))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc ^{:style/indent [:form]} define-after-impl
  [next-method query-type model row-fn]
  (let [f      (fn [row]
                 (or (row-fn row)
                     row))
        next-f (when next-method
                 (next-method query-type model))]
    (if next-f
      (comp next-f f)
      f)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro define-after
  [query-type model [instance-binding] &amp; body]
  `(do
     (u/maybe-derive ~model ::model)
     (m/defmethod each-row-fn [~query-type ~model]
       [~'&amp;query-type ~'&amp;model]
       (define-after-impl ~'next-method
                          ~'&amp;query-type
                          ~'&amp;model
                          (fn [~instance-binding]
                            ~@body)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef define-after*
  :args (s/cat :query-type #(isa? % :toucan.query-type/*)
               :model      some?
               :bindings   (s/spec (s/cat :instance :clojure.core.specs.alpha/binding-form))
               :body       (s/+ any?))
  :ret any?)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.after-insert" name="toucan2.tools.after-insert"><h1 class="project-name">toucan2.tools.after-insert</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.after-insert
  (:require
   [clojure.spec.alpha :as s]
   [toucan2.tools.after :as tools.after]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(derive :toucan.query-type/insert.* ::tools.after/query-type)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro define-after-insert
  {:style/indent :defn}
  [model [instance-binding] &amp; body]
  `(tools.after/define-after :toucan.query-type/insert.*
     ~model
     [~instance-binding]
     ~@body))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef define-after-insert
  :args (s/cat :model    some?
               :bindings (s/spec (s/cat :instance :clojure.core.specs.alpha/binding-form))
               :body     (s/+ any?))
  :ret any?)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.after-select" name="toucan2.tools.after-select"><h1 class="project-name">toucan2.tools.after-select</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.after-select
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.pipeline :as pipeline]
   [toucan2.tools.simple-out-transform :as tools.simple-out-transform]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment types/keep-me)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmulti after-select
  {:arglists            '([instance])
   :defmethod-arities   #{1}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs"><p>Do after-select for anything returning instances, not just SELECT. [[toucan2.insert/insert-returning-instances!]]
should do after-select as well.</p>
</td><td class="codes"><pre class="brush: clojure">(tools.simple-out-transform/define-out-transform [:toucan.result-type/instances ::after-select]
  [instance]
  (if (isa? &amp;query-type :toucan.query-type/select.instances-from-pks)
    instance
    (after-select instance)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro define-after-select
  {:style/indent :defn}
  [model [instance-binding] &amp; body]
  `(do
     (u/maybe-derive ~model ::after-select)
     (m/defmethod after-select ~model
       [instance#]
       (let [~instance-binding (cond-&gt; instance#
                                 ~'next-method ~'next-method)]
         ~@body))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef define-after-select
  :args (s/cat :model    some?
               :bindings (s/spec (s/cat :instance :clojure.core.specs.alpha/binding-form))
               :body     (s/+ any?))
  :ret any?)</pre></td></tr><tr><td class="docs"><p><code>after-select</code> should be done before [[toucan2.tools.after-update]] and [[toucan2.tools.after-insert]]</p>
</td><td class="codes"><pre class="brush: clojure">(m/prefer-method! #'pipeline/results-transform
                  [:toucan.result-type/instances ::after-select]
                  [:toucan.result-type/instances :toucan2.tools.after/model])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.after-update" name="toucan2.tools.after-update"><h1 class="project-name">toucan2.tools.after-update</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.after-update
  (:require
   [clojure.spec.alpha :as s]
   [toucan2.tools.after :as tools.after]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(derive :toucan.query-type/update.* ::tools.after/query-type)</pre></td></tr><tr><td class="docs"><p>The value of this is ultimately ignored, but when composing multiple <code>after-update</code> methods the values after each
method are threaded thru, so this should return the updated row</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro define-after-update
  {:style/indent :defn}
  [model [instance-binding] &amp; body]
  `(tools.after/define-after :toucan.query-type/update.*
     ~model
     [~instance-binding]
     ~@body))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef define-after-update
  :args (s/cat :model    some?
               :bindings (s/spec (s/cat :instance :clojure.core.specs.alpha/binding-form))
               :body     (s/+ any?))
  :ret any?)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.before-delete" name="toucan2.tools.before-delete"><h1 class="project-name">toucan2.tools.before-delete</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.before-delete
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.connection :as conn]
   [toucan2.log :as log]
   [toucan2.pipeline :as pipeline]
   [toucan2.realize :as realize]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment types/keep-me)</pre></td></tr><tr><td class="docs"><p>Underlying method implemented when using [[define-before-delete]]. You <em>probably</em> shouldn't be adding implementations
to this method directly, unless you know what you are doing!</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti before-delete
  {:arglists            '([model instance])
   :defmethod-arities   #{2}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod before-delete :around :default
  [model instance]
  (log/tracef &quot;Do before-delete for %s %s&quot; model instance)
  (next-method model instance))</pre></td></tr><tr><td class="docs"><p>Select and transduce the matching rows and run their [[before-delete]] methods.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- do-before-delete-for-matching-rows!
  [model parsed-args resolved-query]
  (pipeline/transduce-query
   ((map (fn [row]
           ;; this is another case where we don't NEED to fully realize the rows but it's a big hassle for people
           ;; to use this if we don't. Let's be nice and realize things for people.
           (before-delete model (realize/realize row))))
    (constantly nil))
   :toucan.query-type/select.instances
   model
   parsed-args
   resolved-query))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-query [#_query-type     :toucan.query-type/delete.*
                                       #_model          ::before-delete
                                       #_resolved-query :default]
  &quot;Do a recursive SELECT query with the args passed to `delete!`; apply [[before-delete]] to all matching rows. Then call
  the `next-method`. This is all done inside of a transaction.&quot;
  [rf query-type model parsed-args resolved-query]
  (conn/with-transaction [_conn nil {:nested-transaction-rule :ignore}]
    (do-before-delete-for-matching-rows! model parsed-args resolved-query)
    (next-method rf query-type model parsed-args resolved-query)))</pre></td></tr><tr><td class="docs"><p>Implementation of [[define-before-delete]]; don't call this directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc -before-delete-impl
  [next-method model instance f]
  ;; if `f` didn't return anything, just use the original instance again.
  (let [result (or (f model instance)
                   instance)]
    (if next-method
      (next-method model result)
      result)))</pre></td></tr><tr><td class="docs"><p>Define a method that will be called for every instance that is about to be deleted. The results of this before-delete
method are ultimately ignored, but the entire operation (both the original delete and the recursive select) are done
in a transaction, so you can use before-delete to enforce preconditions and abort deletes when they fail, or do
something for side effects.</p>

<p>Before-delete is implemented by first selecting all the rows matching the [[toucan2.delete/delete!]] conditions and
then transducing those rows and calling the [[before-delete]] method this macro defines on each row. Because
before-delete has to fetch every instance matching the condition, defining a before-delete method can be quite
expensive! For example, a <code>delete!</code> operation that deletes a million rows would normally be a single database call;
with before-delete in place, it would have to fetch and transduce all million rows and apply [[before-delete]] to each
of them <em>before</em> even getting to the <code>DELETE</code> operation! So be sure you <em>really</em> need before-delete behavior before
opting in to it.</p>

<p>To skip before-delete behavior, you can always use the model's raw table name directly, e.g.</p>

<p>```clj
(t2/delete! (t2/table-name :models/user) ...)
```</p>

<p>This might be wise when deleting a large number of rows.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro define-before-delete
  {:style/indent :defn}
  [model [instance-binding] &amp; body]
  `(do
     (u/maybe-derive ~model ::before-delete)
     (m/defmethod before-delete ~model
       [model# instance#]
       (-before-delete-impl ~'next-method
                            model#
                            instance#
                            (fn [~'&amp;model ~instance-binding]
                              ~@body)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef define-before-delete
  :args (s/cat :model    some?
               :bindings (s/spec (s/cat :instance :clojure.core.specs.alpha/binding-form))
               :body     (s/+ any?))
  :ret any?)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.before-insert" name="toucan2.tools.before-insert"><h1 class="project-name">toucan2.tools.before-insert</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.before-insert
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.connection :as conn]
   [toucan2.log :as log]
   [toucan2.pipeline :as pipeline]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment types/keep-me)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmulti before-insert
  {:arglists            '([model row])
   :defmethod-arities   #{2}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- do-before-insert-to-rows [rows model]
  (mapv
   (fn [row]
     (u/try-with-error-context [`before-insert {::model model, ::row row}]
       (log/tracef &quot;Do before-insert for %s %s&quot; model row)
       (let [result (before-insert model row)]
         (log/tracef &quot;[before insert] =&gt; %s&quot; row)
         result)))
   rows))</pre></td></tr><tr><td class="docs"><p>make sure we transform rows whether it's in the parsed args or in the resolved query.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-query :around [#_query-type     :toucan.query-type/insert.*
                                               #_model          ::before-insert
                                               #_resolved-query :default]
  &quot;Execute [[before-insert]] methods and the INSERT query inside a transaction.&quot;
  [rf query-type model parsed-args resolved-query]
  (conn/with-transaction [_conn nil {:nested-transaction-rule :ignore}]
    (next-method rf query-type model parsed-args resolved-query)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type     :toucan.query-type/insert.*
                             #_model          ::before-insert
                             #_resolved-query clojure.lang.IPersistentMap]
  &quot;Apply [[before-insert]] to `:rows` in the `resolved-query` or `parsed-args` for Honey SQL queries.&quot;
  [query-type model parsed-args resolved-query]
  ;; not 100% sure why either `parsed-args` OR `resolved-query` can have `:rows` but I guess we have to update either
  ;; one
  (let [parsed-args    (cond-&gt; parsed-args
                         (:rows parsed-args) (update :rows do-before-insert-to-rows model))
        resolved-query (cond-&gt; resolved-query
                         (:rows resolved-query) (update :rows do-before-insert-to-rows model))]
    (next-method query-type model parsed-args resolved-query)))</pre></td></tr><tr><td class="docs"><p>Important! before-insert should be done BEFORE any [[toucan2.tools.transformed/transforms]]. Transforms are often
for serializing and deserializing values; we don't want before insert methods to have to work with
already-serialized values.</p>

<p>By marking <code>::before-insert</code> as preferred over <code>:toucan2.tools.transformed/transformed</code> it will be done first (see
https://github.com/camsaul/methodical#before-methods)</p>
</td><td class="codes"><pre class="brush: clojure">#_(m/prefer-method! #'pipeline/transduce-with-model
                  [:toucan.query-type/insert.* ::before-insert]
                  [:toucan.query-type/insert.* :toucan2.tools.transformed/transformed.model])
(defmacro define-before-insert
  {:style/indent :defn}
  [model [instance-binding] &amp; body]
  `(do
     (u/maybe-derive ~model ::before-insert)
     (m/defmethod before-insert ~model
       [~'&amp;model ~instance-binding]
       (cond-&gt;&gt; (do ~@body)
         ~'next-method (~'next-method ~'&amp;model)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef define-before-insert
  :args (s/cat :model    some?
               :bindings (s/spec (s/cat :instance :clojure.core.specs.alpha/binding-form))
               :body     (s/+ any?))
  :ret any?)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.before-select" name="toucan2.tools.before-select"><h1 class="project-name">toucan2.tools.before-select</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.before-select
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.log :as log]
   [toucan2.pipeline :as pipeline]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment types/keep-me)</pre></td></tr><tr><td class="docs"><p>Impl for [[define-before-select]].</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti before-select
  {:arglists            '([model parsed-args])
   :defmethod-arities   #{2}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod before-select :around :default
  [model parsed-args]
  (u/try-with-error-context [&quot;before select&quot; {::model model}]
    (log/debugf &quot;do before-select for %s&quot; model)
    (let [result (next-method model parsed-args)]
      (log/debugf &quot;[before select] =&gt; %s&quot; result)
      result)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type     :toucan.query-type/select.*
                             #_model          ::model
                             #_resolved-query :default]
  [query-type model parsed-args resolved-query]
  (let [parsed-args (before-select model parsed-args)]
    (next-method query-type model parsed-args resolved-query)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro define-before-select
  {:style/indent :defn}
  [model [args-binding] &amp; body]
  `(do
     (u/maybe-derive ~model ::model)
     (m/defmethod before-select ~model
       [~'&amp;model ~args-binding]
       (cond-&gt;&gt; (do ~@body)
         ~'next-method
         (~'next-method ~'&amp;model)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef define-before-select
  :args (s/cat :dispatch-value some?
               :bindings       (s/spec (s/cat :args :clojure.core.specs.alpha/binding-form))
               :body           (s/+ any?))
  :ret any?)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.before-update" name="toucan2.tools.before-update"><h1 class="project-name">toucan2.tools.before-update</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.before-update
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.connection :as conn]
   [toucan2.instance :as instance]
   [toucan2.log :as log]
   [toucan2.model :as model]
   [toucan2.pipeline :as pipeline]
   [toucan2.protocols :as protocols]
   [toucan2.realize :as realize]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment types/keep-me)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(derive ::select-for-before-update :toucan.query-type/select.instances.from-update)</pre></td></tr><tr><td class="docs"><p>Do before-update operations for side effects and transformations to a <code>row</code> (presumably a Toucan instance?) before
applying an UPDATE operation.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti before-update
  {:arglists            '([model row])
   :defmethod-arities   #{2}
   ;; work around https://github.com/camsaul/methodical/issues/142
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod before-update :around :default
  [model row]
  (assert (map? row) (format &quot;Expected a map row, got ^%s %s&quot; (some-&gt; row class .getCanonicalName) (pr-str row)))
  (log/debugf &quot;before-update %s %s&quot; model row)
  (let [result (next-method model row)]
    (assert (map? result) (format &quot;%s for %s should return a map, got %s&quot; `before-update model (pr-str result)))
    (log/debugf &quot;[before-update] =&gt; %s&quot; result)
    result))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- changes-&gt;affected-pk-maps-rf [model changes]
  (assert (map? changes) (format &quot;Expected changes to be a map, got %s&quot; (pr-str changes)))
  (fn
    ([] {})
    ([m]
     (assert (map? m) (format &quot;changes-&gt;affected-pk-maps-rf should have returned a map, got %s&quot; (pr-str m)))
     m)
    ([changes-&gt;pks row]
     (assert (map? changes-&gt;pks))
     (assert (map? row) (format &quot;%s expected a map row, got %s&quot; `changes-&gt;affected-pk-maps (pr-str row)))
     ;; After going back and forth on this I've concluded that it's probably best to just realize the entire row here.
     ;; There are a lot of situations where we don't need to do this, but it means we have to step on eggshells
     ;; everywhere else in order to make things work nicely. Maybe we can revisit this in the future.
     (let [row         (realize/realize row)
           row         (merge row changes)
           row         (before-update model row)
           ;; if the `before-update` method returned a plain map then consider that to be the changes.
           ;; `protocols/changes` will return `nil` for non-instances. TODO -- does that behavior make sense? Clearly,
           ;; it's easy to use wrong -- it took me hours to figure out why something was working and that I needed to
           ;; make this change :sad:
           row-changes (if (instance/instance? row)
                         (protocols/changes row)
                         row)]
       (log/tracef &quot;The following values have changed: %s&quot; changes)
       (cond-&gt; changes-&gt;pks
         (seq row-changes) (update row-changes (fn [pks]
                                                 (conj (set pks) (model/primary-key-values-map model row)))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- fetch-changes-&gt;pk-maps [model {:keys [changes], :as parsed-args} resolved-query]
  (not-empty
   (pipeline/transduce-query
    (changes-&gt;affected-pk-maps-rf model changes)
    ::select-for-before-update
    model
    parsed-args
    resolved-query)))</pre></td></tr><tr><td class="docs"><p>Fetch the matching rows based on original <code>parsed-args</code>; apply [[before-update]] to each. Return a new <em>sequence</em> of
parsed args maps that should be used to perform 'replacement' update operations.</p>

<p>TODO -- this is sort of problematic since it breaks [[toucan2.tools.compile]]</p>
</td><td class="codes"><pre class="brush: clojure">(defn- apply-before-update-to-matching-rows
  [model {:keys [changes], :as parsed-args} resolved-query]
  (u/try-with-error-context [&quot;apply before-update to matching rows&quot; {::model model, ::changes changes}]
    (log/debugf &quot;apply before-update to matching rows for %s&quot; model)
    (when-let [changes-&gt;pk-maps (fetch-changes-&gt;pk-maps model parsed-args resolved-query)]
      (log/tracef &quot;changes-&gt;pk-maps = %s&quot; changes-&gt;pk-maps)
      (if (= (count changes-&gt;pk-maps) 1)
        ;; every row has the same exact changes: we only need to perform a single update, using the original
        ;; conditions.
        [(assoc parsed-args :changes (first (keys changes-&gt;pk-maps)))]
        ;; more than one set of changes: need to do multiple updates.
        (for [[changes pk-maps] changes-&gt;pk-maps
              pk-map            pk-maps]
          (assoc parsed-args :changes changes, :kv-args pk-map))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-query [#_query-type     :toucan.query-type/update.*
                                       #_model          ::before-update
                                       #_resolved-query :default]
  &quot;Apply [[toucan2.tools.before-update/before-update]] to matching rows. If multiple versions of `:changes` are produced
  as a result, recursively does an update for each version.&quot;
  [rf query-type model {::keys [doing-before-update?], :keys [changes], :as parsed-args} resolved-query]
  (cond
    doing-before-update?
    (next-method rf query-type model parsed-args resolved-query)
    (empty? changes)
    (next-method rf query-type model parsed-args resolved-query)
    :else
    (let [new-args-maps (apply-before-update-to-matching-rows model
                                                              (assoc parsed-args ::doing-before-update? true)
                                                              resolved-query)]
      (log/debugf &quot;Doing recursive updates with new args maps %s&quot; new-args-maps)
      (conn/with-transaction [_conn nil {:nested-transaction-rule :ignore}]
        (transduce
         (comp (map (fn [args-map]
                      (next-method rf query-type model args-map resolved-query)))
               (if (isa? query-type :toucan.result-type/pks)
                 cat
                 identity))
         rf
         new-args-maps)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro define-before-update [model [instance-binding] &amp; body]
  `(do
     (u/maybe-derive ~model ::before-update)
     (m/defmethod before-update ~model
       [~'&amp;model ~instance-binding]
       (cond-&gt;&gt; (do ~@body)
         ~'next-method
         (~'next-method ~'&amp;model)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef define-before-update
  :args (s/cat :model    some?
               :bindings (s/spec (s/cat :instance :clojure.core.specs.alpha/binding-form))
               :body     (s/+ any?))
  :ret any?)</pre></td></tr><tr><td class="docs"><p><code>::before-update</code> should intercept the query before <code>after-update</code> tries to upgrade the query for results
transforms.</p>
</td><td class="codes"><pre class="brush: clojure">(m/prefer-method! #'pipeline/transduce-query
                  [:toucan.query-type/update.* ::before-update :default]
                  [:toucan2.tools.after/query-type :toucan2.tools.after/model :default])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.compile" name="toucan2.tools.compile"><h1 class="project-name">toucan2.tools.compile</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Macros that can wrap a form and return the built query, compiled query, etc. without executing it.</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.compile
  (:refer-clojure :exclude [compile])
  (:require
   [toucan2.pipeline :as pipeline]))</pre></td></tr><tr><td class="docs"><p>Impl for the [[compile]] macro. Do not use this directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc -compile
  [thunk]
  (binding [pipeline/*transduce-execute* (fn [_rf _query-type _model compiled-query]
                                           compiled-query)]
    (thunk)))</pre></td></tr><tr><td class="docs"><p>Return the compiled query that would be executed by a form, rather than executing that form itself.</p>

<p>```clj
(compile
  (delete/delete :table :id 1))
=>
["DELETE FROM table WHERE ID = ?" 1]
```</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro compile
  {:style/indent 0}
  [&amp; body]
  `(-compile (^:once fn* [] ~@body)))</pre></td></tr><tr><td class="docs"><p>Impl for the [[build]] macro. Do not use this directly.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc -build
  [thunk]
  (binding [pipeline/*compile* (fn [_query-type _model built-query]
                                 built-query)]
    (-compile thunk)))</pre></td></tr><tr><td class="docs"><p>Return the built query before compilation that would have been executed by <code>body</code> without compiling or executing it.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro build
  {:style/indent 0}
  [&amp; body]
  `(-build (^:once fn* [] ~@body)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -resolved [thunk]
  (binding [pipeline/*build* (fn [_query-type _model _parsed-args resolved-query]
                               resolved-query)]
    (-build thunk)))</pre></td></tr><tr><td class="docs"><p>Return the resolved query and parsed args <em>before</em> building a query (e.g. before creating a Honey SQL query from the
args passed to [[toucan2.select/select]] created by <code>body</code> without building a query, compiling it, or executing it.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro resolved
  {:style/indent 0}
  [&amp; body]
  `(-resolved (^:once fn* [] ~@body)))</pre></td></tr><tr><td class="docs"><p>(defmacro parsed-args
  [&amp; body]
  )</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.debug" name="toucan2.tools.debug"><h1 class="project-name">toucan2.tools.debug</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.debug
  (:require
   [toucan2.log :as log]
   [toucan2.pipeline :as pipeline]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- print-result [message result]
  (log/-pprint-doc (log/-&gt;Doc [(log/-&gt;Text message) result]))
  result)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -debug [thunk]
  (binding [pipeline/*build*   (comp (partial print-result &quot;\nBuilt:&quot;)
                                     (let [build* pipeline/*build*]
                                       (fn [query-type model parsed-args resolved-query]
                                         (print-result &quot;\nParsed args:&quot; parsed-args)
                                         (print-result &quot;\nResolved query:&quot; resolved-query)
                                         (build* query-type model parsed-args resolved-query))))
            pipeline/*compile* (comp (partial print-result &quot;\nCompiled:&quot;) pipeline/*compile*)]
    (thunk)))</pre></td></tr><tr><td class="docs"><p>Simple debug macro. This is a placeholder until I come up with a more sophisticated version.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro debug
  {:style/indent 0}
  [&amp; body]
  `(-debug (^:once fn* [] ~@body)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.default-fields" name="toucan2.tools.default-fields"><h1 class="project-name">toucan2.tools.default-fields</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.default-fields
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.honeysql2 :as t2.honeysql]
   [toucan2.log :as log]
   [toucan2.pipeline :as pipeline]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment types/keep-me)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::default-field
  (s/or :keyword      keyword?
        :fn-and-alias (s/spec (s/cat :fn      ifn?
                                     :keyword keyword?))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::default-fields
  (s/coll-of ::default-field))</pre></td></tr><tr><td class="docs"><p>The default fields to return for a model <code>model</code> that derives from <code>:toucan2.tools.default-fields/default-fields</code>. You
probably don't need to use this directly; use [[toucan2.tools.default-fields/define-default-fields]] instead.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti default-fields
  {:arglists            '([model])
   :defmethod-arities   #{1}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod default-fields :around :default
  [model]
  (let [fields (next-method model)]
    (when (s/invalid? (s/conform ::default-fields fields))
      (throw (ex-info (format &quot;Invalid default fields for %s: %s&quot; (pr-str model) (s/explain-str ::default-fields fields))
                      (s/explain-data ::default-fields fields))))
    (log/debugf &quot;Default fields for %s: %s&quot; model fields)
    fields))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- default-fields-xform [model]
  (let [field-fns (mapv (fn [[field-type v]]
                          (case field-type
                            :keyword      (fn [instance]
                                            [v (get instance v)])
                            :fn-and-alias (let [{k :keyword, f :fn} v]
                                            (fn [instance]
                                              [k (f instance)]))))
                        (s/conform ::default-fields (default-fields model)))]
    (map (fn [instance]
           (log/tracef &quot;Selecting default-fields from instance&quot;)
           (into (empty instance) (map (fn [field-fn]
                                         (field-fn instance))
                                       field-fns))))))</pre></td></tr><tr><td class="docs"><p>Whether to skip applying default Fields because the query already includes explicit fields, e.g. <code>:select</code> for a Honey
SQL query.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *skip-default-fields*
  false)</pre></td></tr><tr><td class="docs"><p>TODO -- should we skip default fields for a Query that has top-level <code>:union</code> or <code>:union-all</code>?</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-query [#_query-type          :toucan.result-type/instances
                                       #_model               ::default-fields
                                       #_resolved-query-type clojure.lang.IPersistentMap]
  &quot;Skip default fields behavior for Honey SQL queries that contain `:select`. Bind [[*skip-default-fields*]] to `true`.&quot;
  [rf query-type model parsed-args honeysql]
  (if (t2.honeysql/include-default-select? honeysql)
    (next-method rf query-type model parsed-args honeysql)
    (binding [*skip-default-fields* true]
      (log/debugf &quot;Not adding default fields because query already contains `:select` or `:select-distinct`&quot;)
      (next-method rf query-type model parsed-args honeysql))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/results-transform [#_query-type :toucan.result-type/instances #_model ::default-fields]
  [query-type model]
  (log/debugf &quot;Model %s has default fields&quot; model)
  (cond
    *skip-default-fields*
    (next-method query-type model)
    ;; don't apply default fields for queries that specify other columns e.g. `(select [SomeModel :col])`
    (seq (:columns pipeline/*parsed-args*))
    (do
      (log/debugf &quot;Not adding default fields transducer since query already has `:columns`&quot;)
      (next-method query-type model))
    ;; don't apply default fields for queries like [[toucan2.select/select-fn-set]] since they are already doing their
    ;; own transforms
    (isa? query-type :toucan.query-type/select.instances.fns)
    (do
      (log/debugf &quot;Not adding default fields transducer since query type derives from :toucan.query-type/select.instances.fns&quot;)
      (next-method query-type model))
    ;; don't apply default fields for the recursive select done by before-update, because it busts things when we want
    ;; to update non-default fields =(
    ;;
    ;; See [[toucan2.tools.before-update-test/before-update-with-default-fields-test]]
    (isa? query-type :toucan2.tools.before-update/select-for-before-update)
    (do
      (log/debugf &quot;Not adding default fields transducer since query type is done for the purposes of before-update&quot;)
      (next-method query-type model))
    :else
    (do
      (log/debugf &quot;adding transducer to return default fields for %s&quot; model)
      (let [xform (default-fields-xform model)]
        (comp xform
              (next-method query-type model))))))</pre></td></tr><tr><td class="docs"><p><code>default-fields</code> should be done before [[toucan2.tools.after-select]] so that fields added by after select get
preserved.</p>
</td><td class="codes"><pre class="brush: clojure">(m/prefer-method! #'pipeline/results-transform
                  [:toucan.result-type/instances ::default-fields]
                  [:toucan.result-type/instances :toucan2.tools.after-select/after-select])</pre></td></tr><tr><td class="docs"><p><code>default-fields</code> should be done before [[toucan2.tools.after-update]] and [[toucan2.tools.after-insert]] so that
fields added by those methods get preserved.</p>
</td><td class="codes"><pre class="brush: clojure">(m/prefer-method! #'pipeline/results-transform
                  [:toucan.result-type/instances ::default-fields]
                  [:toucan.result-type/instances :toucan2.tools.after/model])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro define-default-fields {:style/indent :defn} [model &amp; body]
  `(do
     (u/maybe-derive ~model ::default-fields)
     (m/defmethod default-fields ~model [~'&amp;model] ~@body)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef define-default-fields
  :args (s/cat :model some?
               :body  (s/+ any?))
  :ret any?)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.disallow" name="toucan2.tools.disallow"><h1 class="project-name">toucan2.tools.disallow</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.disallow
  (:require
   [methodical.core :as m]
   [toucan2.pipeline :as pipeline]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type     :toucan.query-type/select.*
                             #_model          ::select
                             #_resolved-query :default]
  &quot;Throw an Exception when trying to build a SELECT query for models deriving from `:toucan2.tools.disallow/select`.&quot;
  [_query-type model _parsed-args _resolved-query]
  (throw (UnsupportedOperationException. (format &quot;You cannot select %s.&quot; model))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type     :toucan.query-type/delete.*
                             #_model          ::delete
                             #_resolved-query :default]
  &quot;Throw an Exception when trying to build a DELETE query for models deriving from `:toucan2.tools.disallow/delete`.&quot;
  [_query-type model _parsed-args _resolved-query]
  (throw (UnsupportedOperationException. (format &quot;You cannot delete instances of %s.&quot; model))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type     :toucan.query-type/insert.*
                             #_model          ::insert
                             #_resolved-query :default]
  &quot;Throw an Exception when trying to build a INSERT query for models deriving from `:toucan2.tools.disallow/insert`.&quot;
  [_query-type model _parsed-args _resolved-query]
  (throw (UnsupportedOperationException. (format &quot;You cannot create new instances of %s.&quot; model))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type     :toucan.query-type/update.*
                             #_model          ::update
                             #_resolved-query :default]
  &quot;Throw an Exception when trying to build a UPDATE query for models deriving from `:toucan2.tools.disallow/update`.&quot;
  [_query-type model _parsed-args _resolved-query]
  (throw (UnsupportedOperationException. (format &quot;You cannot update a %s after it has been created.&quot; model))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.hydrate" name="toucan2.tools.hydrate"><h1 class="project-name">toucan2.tools.hydrate</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>[[hydrate]] adds one or more keys to an instance or instances using various hydration strategies, usually using one of
the existing keys in those instances. A typical use case would be to take a sequence of <code>orders</code> and add <code>:user</code> keys
to them based on their values of the foreign key <code>:user-id</code>.</p>

<p>[[hydrate]] is how you <em>use</em> the hydration facilities; everything else in this namespace is only for extending
hydration to support your models.</p>

<p>Toucan 2 ships with several hydration strategies out of the box:</p>

<h4>Automagic Batched Hydration (via [[model-for-automagic-hydration]])</h4>

<p>[[hydrate]] attempts to do a <em>batched hydration</em> where possible. If the key being hydrated is defined as one of some
table's [[model-for-automagic-hydration]], <code>hydrate</code> will do a batched
[[toucan2.select/select]] if a corresponding key (by default, the same key suffixed by <code>-id</code>) is found in the
objects being batch hydrated. The corresponding key can be customized by
implementing [[fk-keys-for-automagic-hydration]].</p>

<p>```clj
(hydrate [{:user<em>id 100}, {:user</em>id 101}] :user)
```</p>

<p>Since <code>:user</code> is a hydration key for <code>:models/User</code>, a single [[toucan2.select/select]] will used to fetch Users:</p>

<p>```clj
(db/select :models/User :id [:in #{100 101}])
```</p>

<p>The corresponding Users are then added under the key <code>:user</code>.</p>

<h4>Function-Based Batched Hydration (via [[batched-hydrate]] methods)</h4>

<p>If the key can't be hydrated auto-magically with the appropriate [[model-for-automagic-hydration]],
[[hydrate]] will attempt to do batched hydration if it can find a matching method
for [[batched-hydrate]]. If a matching function is found, it is called with a collection of
objects, e.g.</p>

<p>```clj
(m/defmethod hydrate/batched-hydrate [:default :fields]
  [_model _k instances]
  (let [id->fields (get-some-fields instances)]
    (for [instance instances]
      (assoc instance :fields (get id->fields (:id instance))))))
```</p>

<h4>Simple Hydration (via [[simple-hydrate]] methods)</h4>

<p>If the key is <em>not</em> eligible for batched hydration, [[hydrate]] will look for a matching
[[simple-hydrate]] method. <code>simple-hydrate</code> is called with a single instance.</p>

<p>```clj
(m/defmethod simple-hydrate [:default :dashboard]
  [_model _k {:keys [dashboard-id], :as instance}]
  (assoc instance :dashboard (select/select-one :models/Dashboard :toucan/pk dashboard-id)))
```</p>

<h4>Hydrating Multiple Keys</h4>

<p>You can hydrate several keys at one time:</p>

<p>```clj
(hydrate {...} :a :b)
  -> {:a 1, :b 2}
```</p>

<h4>Nested Hydration</h4>

<p>You can do recursive hydration by listing keys inside a vector:</p>

<p>```clj
(hydrate {...} [:a :b])
  -> {:a {:b 1}}
```</p>

<p>The first key in a vector will be hydrated normally, and any subsequent keys will be hydrated <em>inside</em> the
corresponding values for that key.</p>

<p>```clj
(hydrate {...}
         [:a [:b :c] :e])
  -> {:a {:b {:c 1} :e 2}}
```</p>

<h3>Forcing Hydration</h3>

<p>Normally, hydration is skipped if an instance already has a non-nil value for the key being hydrated, but you can
override this behavior by implementing [[needs-hydration?]].</p>

<h3>Flowchart</h3>

<p>If you're digging in to the details, this is a flowchart of how hydration works:</p>

<p>```
                    hydrate 
                                         
                                         
                 hydrate-forms            
                                         
                                          (recursively)
                hydrate-one-form          
                                         
            keyword?  sequence?      
                                        
                                        
          hydrate-key    hydrate-key-seq 
               
               
      (for each strategy) 
       ::automagic-batched         
       ::multimethod-batched       
       ::multimethod-simple        
                                   (try next strategy)
                                  
      can-hydrate-with-strategy?   
                                  
        yes  no 
         
         
hydrate-with-strategy
```</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.hydrate
  (:require
   [camel-snake-kebab.core :as csk]
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.log :as log]
   [toucan2.model :as model]
   [toucan2.protocols :as protocols]
   [toucan2.realize :as realize]
   [toucan2.select :as select]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(derive ::automagic-batched   ::strategy)
(derive ::multimethod-batched ::strategy)
(derive ::multimethod-simple  ::strategy)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::dispatch-value.strategy
  (s/or
   :default  ::types/dispatch-value.default
   :strategy #(isa? % ::strategy)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::dispatch-value.hydration-key
  (some-fn keyword? symbol?))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::dispatch-value.model-k
  (s/or :default ::types/dispatch-value.default
        :model-k (s/cat
                  :model ::types/dispatch-value.model
                  :k     ::dispatch-value.hydration-key)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::dispatch-value.model-k-model
  (s/or :default ::types/dispatch-value.default
        :model-k (s/cat
                  :model ::types/dispatch-value.model
                  :k     ::dispatch-value.hydration-key
                  :model ::types/dispatch-value.model)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::dispatch-value.model-strategy-k
  (s/or :default          ::types/dispatch-value.default
        :model-strategy-k (s/cat :model    ::types/dispatch-value.model
                                 :strategy ::dispatch-value.strategy
                                 :k        ::dispatch-value.hydration-key)))</pre></td></tr><tr><td class="docs"><p>Can we hydrate the key <code>k</code> in instances of <code>model</code> using a specific hydration <code>strategy</code>?</p>

<p>Normally you should never need to call this yourself. The only reason you would implement it is if you are
implementing a custom hydration strategy.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti can-hydrate-with-strategy?
  {:arglists            '([model strategy k])
   :defmethod-arities   #{3}
   :dispatch-value-spec (s/nonconforming ::dispatch-value.model-strategy-k)}
  u/dispatch-on-first-three-args)</pre></td></tr><tr><td class="docs"><p>Hydrate the key <code>k</code> in <code>instances</code> of <code>model</code> using a specific hydration <code>strategy</code>.</p>

<p>Normally you should not call this yourself. The only reason you would implement this method is if you are implementing
a custom hydration strategy.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti hydrate-with-strategy
  {:arglists            '([model strategy k instances])
   :defmethod-arities   #{4}
   :dispatch-value-spec (s/nonconforming ::dispatch-value.strategy)}
  (fn [_model strategy _k _instances]
    strategy))</pre></td></tr><tr><td class="docs"><p>Whether an <code>instance</code> of <code>model</code> needs the key <code>k</code> to be hydrated. By default, this is true if <code>(get instance k)</code> is
<code>nil</code>. You can override this if you want to force a key to always be re-hydrated even if it is already present.</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti needs-hydration?
  {:arglists            '([model k instance])
   :defmethod-arities   #{3}
   :dispatch-value-spec (s/nonconforming ::dispatch-value.model-k)}
  u/dispatch-on-first-two-args)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod needs-hydration? :default
  [_model k instance]
  (nil? (get instance k)))</pre></td></tr><tr><td class="docs"><h1>                                 Automagic Batched Hydration (via :table-keys)</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>The model that should be used to automagically hydrate the key <code>k</code> in instances of <code>original-model</code>.</p>

<p>```clj
(model-for-automagic-hydration :some-table :user) :-> :myapp.models/user
```</p>

<p>Dispatches off of the [[toucan2.protocols/dispatch-value]] (normally [[toucan2.protocols/model]]) of the instance
being hydrated and the key <code>k</code> that we are attempting to hydrate. To hydrate the key <code>k</code> for <em>any</em> model, you can use
<code>:default</code> in your <code>defmethod</code> dispatch value. Example implementation:</p>

<p>```clj
;; when hydrating the :user key for <em>any</em> model, hydrate with instances of the model :models/user
;;
;; By default, this will look for values of :user-id in the instances being hydrated and then fetch the instances of
;; :models/user with a matching :id
(m/defmethod hydrate/model-for-automagic-hydration [:default :user]
  [_original-model _k]
  :models/user)</p>

<p>;; when hydrating the :user key for instances of :models/orders, hydrate with instances of :models/user
(m/defmethod hydrate/model-for-automagic-hydration [:models/orders :user]
  [_original-model _k]
  :models/user)
```</p>

<p>Automagic hydration looks for the [[fk-keys-for-automagic-hydration]] in the instance being hydrated, and if they're
all non-<code>nil</code>, fetches instances of [[model-for-automagic-hydration]] with the
corresponding [[toucan2.model/primary-keys]]. Thus you might also want to implement</p>

<ul>
<li><p>[[fk-keys-for-automagic-hydration]] for the model whose instances hydrating and the key being hydrated
(e.g. <code>:models/orders</code> and <code>:user</code>)</p></li>
<li><p>[[toucan2.model/primary-keys]] for the model you want to hydrate with (e.g. <code>:models/user</code>)</p></li>
</ul>

<h4>Tips</h4>

<ul>
<li>You probably don't want to write an implementation for <code>[&lt;some-model&gt; :default]</code> or <code>[:default :default]</code>, unless
you want every key that we attempt to hydrate to be hydrated by that method.</li>
</ul>

<p>TODO -- should this get called with <code>instance</code> rather than the instance's model? Should we support multiple possible
models automagically hydrating the same key? For example an Emitter in Metabase can be a CardEmitter, that points to
a Card, or a DashboardEmitter, that points to a Dashboard -- would it be possible to hydrate the same key in a
sequence of mixed-type emitters?</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti model-for-automagic-hydration
  {:arglists            '([original-model k])
   :defmethod-arities   #{2}
   :dispatch-value-spec (s/nonconforming ::dispatch-value.model-k)}
  u/dispatch-on-first-two-args)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod model-for-automagic-hydration :default
  [_model _k]
  nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod can-hydrate-with-strategy? [#_model :default #_strategy ::automagic-batched #_k :default]
  [model _strategy dest-key]
  (boolean (model-for-automagic-hydration model dest-key)))</pre></td></tr><tr><td class="docs"><p>The keys in we should use when automagically hydrating the key <code>dest-key</code> in instances of <code>original-model</code> with
instances <code>hydrating-model</code>.</p>

<p>```clj
;; when hydrating :user in an order with a user, fetch the user based on the value of the :user-id key
;;
;; This means we take the value of :user-id from our order and then fetch the user with the matching primary key
;; (by default, :id)
(fk-keys-for-automagic-hydration :models/orders :user :models/user) => [:user-id]
```</p>

<p>The model that we are hydrating with (e.g. <code>:models/user</code>) is determined by [[model-for-automagic-hydration]].</p>

<p>By default [[fk-keys-for-automagic-hydration]] is just the key we're hydrating, with <code>-id</code> appended to it; e.g. if
we're hydrating <code>:user</code> the default FK key to use is <code>:user-id</code>. *If this convention is fine, you do not need to
implement this method.* If you want to do something that does not follow this convention, like hydrate a <code>:user</code> key
based on values of <code>:creator-id</code>, you should implement this method.</p>

<p>Example implementation:</p>

<p>```clj
;; hydrate orders :user key using values of :creator-id
(m/defmethod hydrate/fk-keys-for-automagic-hydration [:model/orders :user :default]
  [_original-model _dest-key _hydrating-model]
  [:creator-id])
```</p>

<h4>Tips</h4>

<p>When implementing this method, you probably do not want to specialize on the <code>hydrating-model</code> (the third part of the
dispatch value) -- the model to use is normally determined by [[model-for-automagic-hydration]]. The only time you
might want to specialize on <code>hydrating-model</code> is you wanted to do something like</p>

<p>```clj
;; by default when we hydrate the :user key with a :models/user, use :creator-id as the source FK
(m/defmethod hydrate/fk-keys-for-automagic-hydration [:default :model/orders :user :models/user]
  [_original-model _dest-key _hydrating-model]
  [:creator-id])
```</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti fk-keys-for-automagic-hydration
  {:arglists            '([original-model dest-key hydrating-model])
   :defmethod-arities   #{3}
   :dispatch-value-spec (s/nonconforming ::dispatch-value.model-k-model)}
  u/dispatch-on-first-three-args)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod fk-keys-for-automagic-hydration :default
  [_original-model dest-key _hydrated-key]
  ;; TODO -- this should probably use the key transform associated with the `original-model` -- if it's not using magic
  ;; maps this wouldn't work
  [(csk/-&gt;kebab-case (keyword (str (name dest-key) &quot;-id&quot;)))])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod fk-keys-for-automagic-hydration :around :default
  [original-model dest-key hydrating-model]
  (assert (keyword? dest-key) &quot;dest-key should be a keyword&quot;)
  (let [result (next-method original-model dest-key hydrating-model)]
    (when-not (and (sequential? result)
                   (seq result)
                   (every? keyword? result))
      (throw (ex-info (format &quot;fk-keys-for-automagic-hydration should return a non-empty sequence of keywords. Got: %s&quot;
                              (pr-str result))
                      {:original-model original-model
                       :dest-key       dest-key
                       :hydrating-model hydrating-model
                       :result         result})))
    result))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- automagic-batched-hydration-add-fks [model dest-key instances fk-keys]
  (assert (seq fk-keys) &quot;fk-keys cannot be empty&quot;)
  (let [get-fk-values (apply juxt fk-keys)]
    (for [instance instances]
      (if-not (needs-hydration? model dest-key instance)
        (do
          (log/tracef &quot;Don't need to hydrate %s: %s does not need hydration&quot; instance dest-key)
          instance)
        (do
          (log/tracef &quot;Getting values of %s for instance&quot; fk-keys)
          (let [fk-vals (get-fk-values instance)]
            (if (every? some? fk-vals)
              (do
                (log/tracef &quot;Attempting to hydrate %s with values of %s %s&quot; instance fk-keys fk-vals)
                (assoc instance ::fk fk-vals))
              (do
                (log/tracef &quot;Skipping %s: values of %s are %s&quot; instance fk-keys fk-vals)
                instance))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- automagic-batched-hydration-fetch-pk-&gt;instance [hydrating-model instances]
  (let [pk-keys (model/primary-keys hydrating-model)]
    (assert (pos? (count pk-keys)))
    (if-let [fk-values-set (not-empty (set (filter some? (map ::fk instances))))]
      (let [fk-values-set (if (= (count pk-keys) 1)
                            (into #{} (map first) fk-values-set)
                            fk-values-set)]
        (log/debugf &quot;Fetching %s with PK columns %s values %s&quot; hydrating-model pk-keys fk-values-set)
        ;; TODO -- not sure if we need to be realizing stuff here?
        (select/select-pk-&gt;fn realize/realize hydrating-model :toucan/pk [:in fk-values-set]))
      (log/debugf &quot;Not hydrating %s because no instances have non-nil FK values&quot; hydrating-model))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- do-automagic-batched-hydration [dest-key instances pk-&gt;fetched-instance]
  (log/debugf &quot;Attempting to hydrate %s instances out of %s&quot; (count (filter ::fk instances)) (count instances))
  (for [instance instances]
    (if-not (::fk instance)
      ;; If `::fk` doesn't exist for this instance...
      (if (contains? instance dest-key)
        ;; don't stomp on any existing values of `dest-key` if one is already present.
        instance
        ;; if no value is present, `assoc` `nil`.
        (assoc instance dest-key nil))
      ;; otherwise if we DO have an `::fk`, remove it and add the hydrated key in its place
      (let [fk-vals          (::fk instance)
            ;; convert fk to from [id] to id if it only has one key. This is what [[toucan2.select/select-pk-&gt;fn]]
            ;; returns.
            fk-vals          (if (= (count fk-vals) 1)
                               (first fk-vals)
                               fk-vals)
            fetched-instance (get pk-&gt;fetched-instance fk-vals)]
        (log/tracef &quot;Hydrate %s %s with %s&quot; dest-key [instance] (or fetched-instance
                                                                    &quot;nil (no matching fetched instance)&quot;))
        (-&gt; (dissoc instance ::fk)
            (assoc dest-key fetched-instance))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod hydrate-with-strategy ::automagic-batched
  [model _strategy dest-key instances]
  (u/try-with-error-context [&quot;automagic batched hydration&quot; {::model model, ::dest-key dest-key}]
                            (let [hydrating-model      (model-for-automagic-hydration model dest-key)
                                  _                    (log/debugf &quot;Hydrating %s key %s with instances from %s&quot; (or model &quot;map&quot;) dest-key hydrating-model)
                                  fk-keys              (fk-keys-for-automagic-hydration model dest-key hydrating-model)
                                  _                    (log/debugf &quot;Hydrating with FKs %s&quot; fk-keys)
                                  instances                 (automagic-batched-hydration-add-fks model dest-key instances fk-keys)
                                  pk-&gt;fetched-instance (automagic-batched-hydration-fetch-pk-&gt;instance hydrating-model instances)]
                              (log/debugf &quot;Fetched %s instances of %s&quot; (count pk-&gt;fetched-instance) hydrating-model)
                              (do-automagic-batched-hydration dest-key instances pk-&gt;fetched-instance))))</pre></td></tr><tr><td class="docs"><h1>                        Method-Based Batched Hydration (using impls of [[batched-hydrate]])</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Hydrate the key <code>k</code> in one or more <code>instances</code> of <code>model</code>. Implement this method to support batched hydration for the
key <code>k</code>. Example implementation:</p>

<p>```clj
;; This method defines a batched hydration strategy for the :bird-type key for all models.
(m/defmethod hydrate/batched-hydrate [:default :is-bird?]
  [_model _k instances]
  ;; fetch a set of all the non-nil bird IDs in instances.
  (let [bird-ids           (into #{} (comp (map :bird-id) (filter some?)) instances)
        ;; if bird-ids is non-empty, fetch a map of bird ID => bird type
        bird-id->bird-type (when (seq bird-ids)
                             (select/select-pk->fn :bird-type :models/bird :id [:in bird-ids]))]
    ;; for each instance add a :bird-type key.
    (for [instance instances]
      (assoc instance :bird-type (get bird-id->bird-type (:bird-id instance))))))
```</p>

<p>Batched hydration implementations should try to be efficient, e.g. minimizing the number of database calls made rather
than doing one call per instance. If you just want to hydrate each instance independently,
implement [[simple-hydrate]] instead. If you are hydrating entire instances of some other model, consider setting up
automagic batched hydration using [[model-for-automagic-hydration]] and possibly [[fk-keys-for-automagic-hydration]].</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti batched-hydrate
  {:arglists            '([model k instances])
   :defmethod-arities   #{3}
   :dispatch-value-spec (s/nonconforming ::dispatch-value.model-k)}
  u/dispatch-on-first-two-args)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod can-hydrate-with-strategy? [#_model :default #_strategy ::multimethod-batched #_k :default]
  [model _strategy k]
  (boolean (m/effective-primary-method batched-hydrate (m/dispatch-value batched-hydrate model k))))</pre></td></tr><tr><td class="docs"><p>The basic strategy behind batched hydration is thus:</p>

<ol>
<li><p>Take the sequence of instances and "annotate" them, recording whether they <code>:needs-hydration?</code></p></li>
<li><p>Take all the instances that <code>:needs-hydration?</code> and do [[batched-hydrate]] for them</p></li>
<li><p>Go back thru the sequence of annotated instances, and each time we encounter an instance marked
<code>:needs-hydration?</code>, replace it with the first hydrated instance; repeat this process until we have spliced all
the hydrated instances back in.</p></li>
</ol>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Merge the annotated instances as returned by [[annotate-instances]] and the hydrated instances as returned
by [[hydrate-annotated-instances]] back into a single un-annotated sequence.</p>

<p>  (merge-hydrated-instances
   [{:needs-hydration? false, :instance {:x 1, :y 1}}
    {:needs-hydration? false, :instance {:x 2, :y 2}}
    {:needs-hydration? true,  :instance {:x 3}}
    {:needs-hydration? true,  :instance {:x 4}}
    {:needs-hydration? false, :instance {:x 5, :y 5}}
    {:needs-hydration? true,  :instance {:x 6}}]
   [{:x 3, :y 3} {:x 4, :y 4} {:x 6, :y 6}])
  =>
  [{:x 1, :y 1}
   {:x 2, :y 2}
   {:x 3, :y 3}
   {:x 4, :y 4}
   {:x 5, :y 5}
   {:x 6, :y 6}]</p>
</td><td class="codes"><pre class="brush: clojure">(defn- merge-hydrated-instances
  [annotated-instances hydrated-instances]
  (loop [acc [], annotated-instances annotated-instances, hydrated-instances hydrated-instances]
    (if (empty? hydrated-instances)
      (concat acc (map :instance annotated-instances))
      (let [[not-hydrated [_needed-hydration &amp; more]] (split-with (complement :needs-hydration?) annotated-instances)]
        (recur (vec (concat acc (map :instance not-hydrated) [(first hydrated-instances)]))
               more
               (rest hydrated-instances))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- annotate-instances [model k instances]
  (for [instance instances]
    {:needs-hydration? (needs-hydration? model k instance)
     :instance         instance}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- hydrate-annotated-instances [model k annotated-instances]
  (when-let [instances-that-need-hydration (not-empty (map :instance (filter :needs-hydration? annotated-instances)))]
    (batched-hydrate model k instances-that-need-hydration)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod hydrate-with-strategy ::multimethod-batched
  [model _strategy k instances]
  (let [annotated-instances (annotate-instances model k instances)
        hydrated-instances  (hydrate-annotated-instances model k annotated-instances)]
    (merge-hydrated-instances annotated-instances hydrated-instances)))</pre></td></tr><tr><td class="docs"><h1>                         Method-Based Simple Hydration (using impls of [[simple-hydrate]])</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Implementations should return a version of map <code>instance</code> with the key <code>k</code> added.</p>

<p>TODO -- better dox</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti simple-hydrate
  {:arglists            '([model k instance])
   :defmethod-arities   #{3}
   :dispatch-value-spec (s/nonconforming ::dispatch-value.model-k)}
  u/dispatch-on-first-two-args)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- simple-hydrate* [model k instance]
  (u/try-with-error-context [&quot;simple hydrate&quot; {:model model, :k k, :instance instance}]
    (simple-hydrate model k instance)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod can-hydrate-with-strategy? [#_model :default #_strategy ::multimethod-simple #_k :default]
  [model _strategy k]
  (boolean (m/effective-primary-method simple-hydrate (m/dispatch-value simple-hydrate model k))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod hydrate-with-strategy ::multimethod-simple
  [model _strategy k instances]
  ;; TODO -- consider whether we should optimize this a bit and cache the methods we use so we don't have to go thru
  ;; multimethod dispatch on every instance.
  (for [instance instances]
    (when instance
      ;; only hydrate the key if it's not non-nil.
      (cond-&gt;&gt; instance
        (needs-hydration? model k instance)
        (simple-hydrate* model k)))))</pre></td></tr><tr><td class="docs"><h1>                                          Hydration Using All Strategies</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- strategies []
  (keys (m/primary-methods hydrate-with-strategy)))</pre></td></tr><tr><td class="docs"><p>Determine the appropriate hydration strategy to hydrate the key <code>k</code> in instances of <code>model</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc hydration-strategy
  [model k]
  (some
   (fn [strategy]
     (when (can-hydrate-with-strategy? model strategy k)
       strategy))
   (strategies)))</pre></td></tr><tr><td class="docs"><h1>                                              Primary Hydration Fns</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare hydrate)</pre></td></tr><tr><td class="docs"><p>TODO -- consider renaming this to <code>*error-on-unknown-key-override*</code></p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *error-on-unknown-key* nil)</pre></td></tr><tr><td class="docs"><p>Whether hydration should error when it encounters a key that has no hydration methods associated with
it (default: <code>false</code>). Global default value. You can bind [[<em>error-on-unknown-key</em>]] to temporarily override this
value.</p>
</td><td class="codes"><pre class="brush: clojure">(defonce 
  global-error-on-unknown-key
  (atom false))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:no-doc error-on-unknown-key? []
  (if (some? *error-on-unknown-key*)
    *error-on-unknown-key*
    @global-error-on-unknown-key))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- hydrate-key
  [model instances k]
  (if-let [strategy (hydration-strategy model k)]
    (u/try-with-error-context [&quot;hydrate key&quot; {:model model, :key k, :strategy strategy}]
                              (log/debugf &quot;Hydrating %s %s with strategy %s&quot; (or model &quot;map&quot;) k strategy)
                              (hydrate-with-strategy model strategy k instances))
    (do
      (log/warnf &quot;Don't know how to hydrate %s for model %s instances %s&quot; k model (take 1 instances))
      (when (error-on-unknown-key?)
        (throw (ex-info (format &quot;Don't know how to hydrate %s&quot; (pr-str k))
                        {:model model, :instances instances, :k k})))
      instances)))</pre></td></tr><tr><td class="docs"><p>Hydrate a nested hydration form (vector) by recursively calling [[hydrate]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn- hydrate-key-seq
  [results [k &amp; nested-keys :as coll]]
  (when-not (seq nested-keys)
    (throw (ex-info (str (format &quot;Invalid hydration form: replace %s with %s. Vectors are for nested hydration.&quot; coll k)
                         &quot; There's no need to use one when you only have a single key.&quot;)
                    {:invalid-form coll})))
  (let [results                     (hydrate results k)
        newly-hydrated-values       (map k results)
        recursively-hydrated-values (apply hydrate newly-hydrated-values nested-keys)]
    (map
     (fn [result v]
       (if (and result (some? v))
         (assoc result k v)
         result))
     results
     recursively-hydrated-values)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare hydrate-one-form)</pre></td></tr><tr><td class="docs"><p>Convert a collection <code>coll</code> into a flattened sequence of maps with <code>:item</code> and <code>:path</code>.</p>

<p>```clj
(flatten-collection [[{:a 1}]])
=>
[{:path [], :item []}
 {:path [0], :item []}
 {:path [0 0], :item {:a 1}}]
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn- flatten-collection
  ([coll]
   (flatten-collection [] coll))
  ([path coll]
   (if (sequential? coll)
     (into [{:path path, :item []}]
           (comp (map-indexed (fn [i x]
                                (flatten-collection (conj path i) x)))
                 cat)
           coll)
     [{:path path, :item coll}])))</pre></td></tr><tr><td class="docs"><p>Take a sequence of items flattened by [[flatten-collection]] and restore them to their original shape.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- unflatten-collection
  [flattened]
  (reduce
   (fn [acc {:keys [path item]}]
     (if (= path [])
       item
       (assoc-in acc path item)))
   []
   flattened))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- hydrate-sequence-of-sequences [model coll k]
  (let [flattened (flatten-collection coll)
        items     (for [{:keys [item path]} flattened
                        :when (map? item)]
                    (vary-meta item assoc ::path path))
        hydrated (hydrate-one-form model items k)]
    (unflatten-collection (concat flattened
                                  (for [item hydrated]
                                    (do
                                      (assert (::path (meta item)))
                                      {:item item, :path (::path (meta item))}))))))</pre></td></tr><tr><td class="docs"><p>Hydrate for a single hydration key or form <code>k</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- hydrate-one-form
  [model results k]
  (log/debugf &quot;hydrate %s for model %s instances %s&quot; k model (take 1 results))
  (cond
    (and (sequential? results)
         (empty? results))
    results
    ;; check whether the first non-nil result is a sequence. If it is, then hydrate sequences-of-sequences
    (sequential? (some (fn [result]
                         (when (some? result)
                           result))
                       results))
    (hydrate-sequence-of-sequences model results k)
    (keyword? k)
    (hydrate-key model results k)
    (sequential? k)
    (hydrate-key-seq results k)
    :else
    (throw (ex-info (format &quot;Invalid hydration form: %s. Expected keyword or sequence.&quot; k)
                    {:invalid-form k}))))</pre></td></tr><tr><td class="docs"><p>Hydrate many hydration forms across a <em>sequence</em> of <code>results</code> by recursively calling [[hydrate-one-form]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn- hydrate-forms
  [model results &amp; forms]
  (reduce (partial hydrate-one-form model) results forms))</pre></td></tr><tr><td class="docs"><p>Given an arbitrarily nested sequence <code>coll</code>, continue unnesting the sequence until we get a non-sequential first item.</p>

<p>```clj
(unnest-first-result [:a :b])  => :a
(unnest-first-result [[:a]])   => :a
(unnest-first-result [[[:a]]]) => :a
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn- unnest-first-result
  [coll]
  (-&gt;&gt; (iterate first coll)
       (take-while sequential?)
       last
       first))</pre></td></tr><tr><td class="docs"><h1>                                                Public Interface</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Hydrate the keys <code>ks</code> in a single instance or sequence of instances. See [[toucan2.tools.hydrate]] for more
information.</p>
</td><td class="codes"><pre class="brush: clojure">(defn hydrate
  ;; no keys -- no-op
  ([instance-or-instances]
   instance-or-instances)
  ([instance-or-instances &amp; ks]
   (u/try-with-error-context [&quot;hydrate&quot; {:what instance-or-instances, :keys ks}]
     (cond
       (not instance-or-instances)
       nil
       (and (sequential? instance-or-instances)
            (empty? instance-or-instances))
       instance-or-instances
       ;; sequence of instances
       (sequential? instance-or-instances)
       (let [model (protocols/model (unnest-first-result instance-or-instances))]
         (apply hydrate-forms model instance-or-instances ks))
       ;; not sequential
       :else
       (first (apply hydrate-forms (protocols/model instance-or-instances) [instance-or-instances] ks))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.identity-query" name="toucan2.tools.identity-query"><h1 class="project-name">toucan2.tools.identity-query</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.identity-query
  (:require
   [methodical.core :as m]
   [pretty.core :as pretty]
   [toucan2.connection :as conn]
   [toucan2.instance :as instance]
   [toucan2.log :as log]
   [toucan2.pipeline :as pipeline]
   [toucan2.realize :as realize]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord ^:no-doc IdentityQuery [rows]
  pretty/PrettyPrintable
  (pretty [_this]
    (list `identity-query rows))
  realize/Realize
  (realize [_this]
    (realize/realize rows))
  clojure.lang.IReduceInit
  (reduce [_this rf init]
    (log/debugf &quot;reduce IdentityQuery rows&quot;)
    (reduce rf init rows)))</pre></td></tr><tr><td class="docs"><p>A queryable that returns <code>reducible-rows</code> as-is without compiling anything or running anything against a database.
Good for mocking stuff.</p>

<p>```clj
(def parrot-query
  (identity-query [{:id 1, :name "Parroty"}
                   {:id 2, :name "Green Friend"}]))</p>

<p>(select/select ::parrot parrot-query)
=>
[(instance ::parrot {:id 1, :name "Parroty"})
 (instance ::parrot {:id 2, :name "Green Friend"})]
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn identity-query
  [reducible-rows]
  (-&gt;IdentityQuery reducible-rows))</pre></td></tr><tr><td class="docs"><p>(m/defmethod pipeline/transduce-execute [#<em>query-type :default #</em>model :default #_query IdentityQuery]
  [rf _query-type model {:keys [rows], :as _query}]
  (log/debugf "transduce IdentityQuery rows %s" rows)
  (transduce (if model
               (map (fn [result-row]
                      (instance/instance model result-row)))
               identity)
             rf
             rows))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Not sure I understand how you're supposed to get to these points anyway</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/compile [#_query-type :default #_model :default #_query IdentityQuery]
  [_query-type _model query]
  query)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build :around [#_query-type :default #_model :default #_query IdentityQuery]
  &quot;This is an around method so we can intercept anything else that might normally be considered a more specific method
  when it dispatches off of more-specific values of `query-type`.&quot;
  [_query-type _model _parsed-args resolved-query]
  resolved-query)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-query [#_query-type     :default
                                       #_model          IdentityQuery
                                       #_resolved-query :default]
  &quot;Allow using an identity query as an 'identity model'.&quot;
  [rf _query-type model _parsed-args _resolved-query]
  (transduce identity rf model))</pre></td></tr><tr><td class="docs"><p>Identity connection</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype ^:no-doc IdentityConnection []
  pretty/PrettyPrintable
  (pretty [_this]
    (list `-&gt;IdentityConnection)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod conn/do-with-connection IdentityConnection
  [connectable f]
  {:pre [(ifn? f)]}
  (f connectable))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod conn/do-with-transaction IdentityConnection
  [connectable _options f]
  {:pre [(ifn? f)]}
  (f connectable))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-execute-with-connection [#_conn IdentityConnection #_query-type :default #_model :default]
  [rf _conn _query-type model id-query]
  (assert (instance? IdentityQuery id-query))
  (binding [conn/*current-connectable* nil]
    (transduce
     (map (fn [row]
            (if (map? row)
              (instance/instance model row)
              row)))
     rf
     (:rows id-query))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/transduce-query [#_query-type     :default
                                       #_model          :default
                                       #_resolved-query IdentityQuery]
  [rf query-type model parsed-args resolved-query]
  (binding [conn/*current-connectable* (-&gt;IdentityConnection)]
    (next-method rf query-type model parsed-args resolved-query)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.named-query" name="toucan2.tools.named-query"><h1 class="project-name">toucan2.tools.named-query</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.named-query
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.pipeline :as pipeline]
   [toucan2.types :as types]))</pre></td></tr><tr><td class="docs"><p>Helper for defining 'named' queries.</p>

<p>```clj
;; define a custom query ::my-count that you can then use with select and the like
(define-named-query ::my-count
  {:select [:%count.*], :from [(keyword (model/table-name model))]})</p>

<p>(select :model/user ::my-count)
```</p>

<p>This doesn't NEED to be a macro but having the definition live in the namespace it was defined in is useful for
stack trace purposes. Also it lets us do validation with the spec below.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro define-named-query
  {:style/indent 1}
  ([query-name resolved-query]
   `(define-named-query ~query-name :default :default ~resolved-query))
  ([query-name query-type model resolved-query]
   `(m/defmethod pipeline/resolve [~query-type ~model ~query-name]
      &quot;Created by [[toucan2.tools.named-query/define-named-query]].&quot;
      [~'&amp;query-type ~'&amp;model ~'&amp;unresolved-query]
      ~resolved-query)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef define-named-query
  :args (s/alt :2-arity (s/cat :query-name     (every-pred keyword? namespace)
                               :resolved-query some?)
               :4-arity (s/cat :query-name     (every-pred keyword? namespace)
                               :query-type     (s/alt :query-type types/query-type?
                                                      :default    #{:default})
                               :model          some?
                               :resolved-query some?))
  :ret any?)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.simple-out-transform" name="toucan2.tools.simple-out-transform"><h1 class="project-name">toucan2.tools.simple-out-transform</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.simple-out-transform
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.instance :as instance]
   [toucan2.pipeline :as pipeline]))</pre></td></tr><tr><td class="docs"><p>TODO -- I'm not really convinced this is worth it at all. It's used in exactly one place =(</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn -xform [f]
  (map (fn [instance]
         (let [instance (f instance)]
           (cond-&gt; instance
             (instance/instance? instance)
             instance/reset-original)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro define-out-transform
  {:style/indent :defn}
  [[query-type model-type] [instance-binding] &amp; body]
  `(m/defmethod pipeline/results-transform [~query-type ~model-type]
     [~'&amp;query-type ~'&amp;model]
     (let [xform# (-xform (fn [~instance-binding] ~@body))]
       (comp xform#
             (~'next-method ~'&amp;query-type ~'&amp;model)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef define-out-transform
  :args (s/cat :dispatch-value (s/spec (s/cat :query-type keyword?
                                              :model-type any?))
               :bindings (s/spec (s/cat :row :clojure.core.specs.alpha/binding-form))
               :body     (s/+ any?))
  :ret any?)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (define-out-transform [:toucan.query-type/select.instances ::venues]
    [row]
    (assoc row :neat true)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.transformed" name="toucan2.tools.transformed"><h1 class="project-name">toucan2.tools.transformed</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.transformed
  (:require
   [better-cond.core :as b]
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [methodical.impl.combo.operator :as m.combo.operator]
   [toucan2.instance :as instance]
   [toucan2.log :as log]
   [toucan2.model :as model]
   [toucan2.pipeline :as pipeline]
   [toucan2.protocols :as protocols]
   [toucan2.query :as query]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::transforms-map.direction-&gt;fn
  (s/map-of #{:in :out}
            ifn?))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::transforms-map.column-&gt;direction
  (s/map-of keyword?
            ::transforms-map.direction-&gt;fn))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- validate-transforms-map [transforms-map]
  (when (and transforms-map
             (s/invalid? (s/conform ::transforms-map.column-&gt;direction transforms-map)))
    (throw (ex-info (format &quot;Invalid deftransforms map: %s&quot;
                            (s/explain-str ::transforms-map.column-&gt;direction transforms-map))
                    (s/explain-data ::transforms-map.column-&gt;direction transforms-map)))))</pre></td></tr><tr><td class="docs"><p>combine the results of all matching methods into one map.</p>
</td><td class="codes"><pre class="brush: clojure">(m.combo.operator/defoperator ::merge-transforms
  [method-fns invoke]
  (transduce
   (map invoke)
   (fn
     ([]
      {})
     ([m]
      (validate-transforms-map m)
      m)
     ([m1 m2]
      ;; for the time being keep the values from map returned by the more-specific method in preference to the ones
      ;; returned by the less-specific methods.
      ;;
      ;; TODO -- we should probably throw an error if one of the transforms is stomping on the other.
      (merge-with merge m2 m1)))
   method-fns))</pre></td></tr><tr><td class="docs"><p>Return a map of</p>

<p>```clj
{column-name {:in <fn>, :out <fn>}}
```</p>

<p>For a given <code>model</code>, all matching transforms are combined with <code>merge-with merge</code> in an indeterminate order, so don't
try to specify multiple transforms for the same column in the same direction for a given model -- compose your
transform functions instead if you want to do that. See [[toucan2.tools.transformed/deftransforms]] for more info.</p>
</td><td class="codes"><pre class="brush: clojure">(defonce ^{:doc 
           :arglists '([model])}
  transforms
  ;; TODO -- this has to be uncached for now because of https://github.com/camsaul/methodical/issues/98
  (m/uncached-multifn
   (m/standard-multifn-impl
    (m.combo.operator/operator-method-combination ::merge-transforms)
    ;; TODO -- once https://github.com/camsaul/methodical/issues/97 is implemented, use that.
    (m/standard-dispatcher u/dispatch-on-first-arg)
    (m/standard-method-table))
   {:ns                  *ns*
    :name                `transforms
    :defmethod-arities   #{1}
    :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}))</pre></td></tr><tr><td class="docs"><p>I originally considered walking and transforming the HoneySQL, but decided against it because it's too ambiguous.
It's too hard to tell if</p>

<p>   [:= :id :col]</p>

<p>means</p>

<p>A) <code>:id</code> is a column identifier key, and <code>:col</code> is a value for it that we should transform
B) <code>:col</code> is a column identifier key, and <code>:id</code> is a value for it that we should transform
C) <code>:id</code> is a column identifier key, but <code>:col</code> is just a reference to another column, and we shouldn't transform it
D) <code>:col</code> is a column identifier key, but <code>:id</code> is just a reference to another column, and we shouldn't transform it</p>

<p>It's also hard to know what are the "values" of every different type of filter clause (including custom ones we
don't know about). I think leaving HoneySQL as an outlet to bypass type transforms makes sense for now. This also
avoids locking us in to HoneySQL too much</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- transform-condition-value [xform v]
  (cond
    (sequential? v)
    (into [(first v)]
          (map (fn xform* [v]
                 (if (or (sequential? v)
                         (set? v))
                   (mapv xform* v)
                   (xform v))))
          (rest v))
    ;; only apply xform if the value is non-nil.
    (some? v)
    (xform v)
    :else
    nil))</pre></td></tr><tr><td class="docs"><p>Get the [[transforms]] functions for a model in a either the <code>:in</code> or <code>:out</code> direction; wrap the functions in
<code>try-catch</code> forms so we can meaningful error messages if they fail, and so that the transform is skipped for <code>nil</code>
values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- wrapped-transforms
  [model direction]
  (u/try-with-error-context [&quot;calculate transforms&quot; {::model model, ::direction direction}]
    (when-let [k-&gt;direction-&gt;transform (not-empty (transforms model))]
      ;; make the transforms map an instance so we can get appropriate magic map behavior when looking for the
      ;; appropriate transform for a given key.
      (instance/instance
       model
       (into {} (for [[k direction-&gt;xform] k-&gt;direction-&gt;transform
                      :let                 [xform (get direction-&gt;xform direction)]
                      :when                xform]
                  [k (fn xform-fn [v]
                       (if-not (some? v)
                         v
                         (u/try-with-error-context [&quot;apply transform&quot; {::transforms k-&gt;direction-&gt;transform
                                                                       ::model      model
                                                                       ::k          k
                                                                       ::v          v
                                                                       ::xform      xform}]
                           (xform v))))]))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- in-transforms [model]
  (wrapped-transforms model :in))</pre></td></tr><tr><td class="docs"><p>this is just here so we can intercept low-level calls to [[query/apply-kv-arg]] instead of needing to know how to
handle stuff like <code>:toucan/pk</code> ourselves</p>

<p>TODO -- this whole thing is still busted a <em>little</em> bit I think because it's assuming that everything in <code>kv-args</code>
is a CONDITION (goes in a WHERE clause) but I guess if we're intercepting the bottom-level calls to
[[query/apply-kv-arg]] at that point it IS a condition. We need to verify this tho and test it with some sort of
thing like the custom <code>::limit</code> thing</p>

<p>TODO This name is WACK</p>
</td><td class="codes"><pre class="brush: clojure">(defrecord ^:no-doc RecordTypeForInterceptingApplyKVArgCalls [])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod query/apply-kv-arg [#_model :default
                                 #_query RecordTypeForInterceptingApplyKVArgCalls
                                 #_k     :default]
  [model _query k v]
  (let [v (if-let [xform (get (in-transforms model) k)]
            (transform-condition-value xform v)
            v)]
    [k v]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private ^:dynamic *skip-in-transforms* false)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod query/apply-kv-arg [#_model ::transformed.model
                                 #_query :default
                                 #_k     :default]
  [model query k v]
  (if (or (instance? RecordTypeForInterceptingApplyKVArgCalls query)
          *skip-in-transforms*
          (nil? v))
    (next-method model query k v)
    (let [[k v*] (query/apply-kv-arg model (-&gt;RecordTypeForInterceptingApplyKVArgCalls) k v)]
      #_(printf &quot;Intercepted apply-kv-arg %s %s =&gt; %s\n&quot; k (pr-str v) (pr-str v*))
      (binding [*skip-in-transforms* true]
        (next-method model query k v*)))))</pre></td></tr><tr><td class="docs"><p>after select (or other things returning instances)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- apply-result-row-transform [instance k xform]
  (assert (map? instance)
          (format &quot;%s expected map rows, got %s&quot; `apply-result-row-transform (pr-str instance)))
  ;; The &quot;Special Optimizations&quot; below *should* be the default case, but if some other aux methods are in place or
  ;; custom impls it might not be; things should still work normally either way.
  ;;
  ;; Special Optimization 1: if `instance` is an `IInstance`, and original and current are the same object, this only
  ;; applies `xform` once.
  (instance/update-original-and-current
   instance
   (fn [row]
     ;; Special Optimization 2: if the underlying original/current maps of `instance` are instances of something
     ;; like [[toucan2.jdbc.row/-&gt;TransientRow]] we can do a 'deferred update' that only applies the transform if and
     ;; when the value is realized.
     (log/tracef &quot;Transform %s %s&quot; k (get row k))
     (u/try-with-error-context [&quot;Transform result column&quot; {::k k, ::xform xform, ::row row}]
       (protocols/deferrable-update row k xform)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- out-transforms [model]
  (wrapped-transforms model :out))</pre></td></tr><tr><td class="docs"><p>Given a <code>column</code> and a transform function <code>xform</code>, return a function with the signature</p>

<p>```clj
(f row)
```</p>

<p>that will apply that transform to that column if the row contains that column.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- apply-result-row-transform-fn
  [column xform]
  (fn [instance]
    (cond-&gt; instance
      (contains? instance column) (apply-result-row-transform column xform))))</pre></td></tr><tr><td class="docs"><p>Given a map of column key -> transform function, return a function with the signature</p>

<p>```clj
(f row)
```</p>

<p>That can be called on each instance returned in the results.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- result-row-transform-fn
  [k-&gt;transform]
  {:pre [(map? k-&gt;transform) (seq k-&gt;transform)]}
  (reduce
   (fn [f [k xform]]
     (comp (apply-result-row-transform-fn k xform)
           f))
   identity
   k-&gt;transform))</pre></td></tr><tr><td class="docs"><p>Return a transducer to transform rows of <code>model</code> using its [[out-transforms]].</p>
</td><td class="codes"><pre class="brush: clojure">(defn- transform-result-rows-transducer
  [model]
  (if-let [k-&gt;transform (not-empty (out-transforms model))]
    (map (let [f (result-row-transform-fn k-&gt;transform)]
           (fn [row]
             (assert (map? row) (format &quot;Expected map row, got ^%s %s&quot; (some-&gt; row class .getCanonicalName) (pr-str row)))
             (log/tracef &quot;Transform %s row %s&quot; model row)
             (let [result (u/try-with-error-context [&quot;transform result row&quot; {::model model, ::row row}]
                            (f row))]
               (log/tracef &quot;[transform] =&gt; %s&quot; result)
               result))))
    identity))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type     :toucan.query-type/select.instances-from-pks
                             #_model          ::transformed.model
                             #_resolved-query :default]
  &quot;Don't try to transform stuff when we're doing SELECT directly with PKs (e.g. to fake INSERT returning instances), We're
  not doing transforms on the way out so we don't need to do them on the way in.&quot;
  [query-type model parsed-args resolved-query]
  (binding [*skip-in-transforms* true]
    (next-method query-type model parsed-args resolved-query)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/results-transform [#_query-type :toucan.result-type/instances #_model ::transformed.model]
  [query-type model]
  (if (isa? query-type :toucan.query-type/select.instances-from-pks)
    (next-method query-type model)
    (let [xform (transform-result-rows-transducer model)]
      (comp xform
            (next-method query-type model)))))</pre></td></tr><tr><td class="docs"><p>before update</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- transform-update-changes [m k-&gt;transform]
  {:pre [(map? k-&gt;transform) (seq k-&gt;transform)]}
  (into {} (for [[k v] m]
             [k (when (some? v)
                  (if-let [xform (get k-&gt;transform k)]
                    (xform v)
                    v))])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type     :toucan.query-type/update.*
                             #_model          ::transformed.model
                             #_resolved-query :default]
  &quot;Apply transformations to the `changes` map in an UPDATE query.&quot;
  [query-type model {:keys [changes], :as parsed-args} resolved-query]
  (b/cond
    (not (map? changes))
    (next-method query-type model parsed-args resolved-query)
    :let [k-&gt;transform (not-empty (in-transforms model))]
    (not k-&gt;transform)
    (next-method query-type model parsed-args resolved-query)
    (let [parsed-args (update parsed-args :changes transform-update-changes k-&gt;transform)]
      (next-method query-type model parsed-args resolved-query))))</pre></td></tr><tr><td class="docs"><p>before insert</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- transform-insert-rows [[first-row :as rows] k-&gt;transform]
  {:pre [(map? first-row) (map? k-&gt;transform)]}
  (let [x-forms (for [[k transform] k-&gt;transform]
                  (fn [row]
                    (if (some? (get row k))
                      (update row k transform)
                      row)))
        x-form  (apply comp x-forms)]
   (map x-form rows)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type     :toucan.query-type/insert.*
                             #_model          ::transformed.model
                             #_resolved-query :default]
  [query-type model parsed-args resolved-query]
  (assert (isa? model ::transformed.model))
  (b/cond
    (::already-transformed? parsed-args)
    (next-method query-type model parsed-args resolved-query)
    :let [k-&gt;transform (in-transforms model)]
    (empty? k-&gt;transform)
    (next-method query-type model parsed-args resolved-query)
    :else
    (u/try-with-error-context [&quot;apply in transforms before inserting rows&quot; {::query-type  query-type
                                                                            ::model       model
                                                                            ::parsed-args parsed-args
                                                                            ::transforms  k-&gt;transform}]
      (log/debugf &quot;Apply %s transforms to %s&quot; k-&gt;transform parsed-args)
      (let [parsed-args    (cond-&gt; parsed-args
                             (seq (:rows parsed-args))
                             (update :rows transform-insert-rows k-&gt;transform)
                             true
                             (assoc ::already-transformed? true))
            resolved-query (cond-&gt; resolved-query
                             (seq (:rows resolved-query))
                             (update :rows transform-insert-rows k-&gt;transform))]
        (next-method query-type model parsed-args resolved-query)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/results-transform [#_query-type :toucan.query-type/insert.pks #_model ::transformed.model]
  &quot;Transform results of `insert!` returning PKs.&quot;
  [query-type model]
  (let [pk-keys (model/primary-keys model)
        xform   (comp
                 ;; 1. convert result PKs to a map of PK key -&gt; value
                 (map (fn [pk-or-pks]
                        (log/tracef &quot;convert result PKs %s to map of PK key -&gt; value&quot; pk-or-pks)
                        (let [m (zipmap pk-keys (if (sequential? pk-or-pks)
                                                  pk-or-pks
                                                  [pk-or-pks]))]
                          (log/tracef &quot;=&gt; %s&quot; pk-or-pks)
                          m)))
                 ;; 2. transform the PK results using the model's [[out-transforms]]
                 (transform-result-rows-transducer model)
                 ;; 3. Now flatten the maps of PK key -&gt; value back into plain PK values or vectors of plain PK values
                 ;; (if the model has a composite primary key)
                 (map (let [f (if (= (count pk-keys) 1)
                                (first pk-keys)
                                (juxt pk-keys))]
                        (fn [row]
                          (log/tracef &quot;convert PKs map back to flat PKs&quot;)
                          (let [row (f row)]
                            (log/tracef &quot;=&gt; %s&quot; row)
                            row)))))]
    (comp xform
          (next-method query-type model))))</pre></td></tr><tr><td class="docs"><p>[[deftransforms]]</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Define type transforms to use for a specific model. <code>transforms</code> should be a map of</p>

<p>```clj
{:column-name {:in <fn>, :out <fn>}}
```</p>

<p><code>:in</code> transforms are applied to values going over the wire to the database; these generally only applied to values
passed at or near the top level to various functions; don't expect Toucan 2 to parse your SQL to find out which
parameter corresponds to what in order to apply transforms or to apply transforms inside JOINS in hand-written
HoneySQL. That said, unless you're doing something weird your transforms should generally get applied.</p>

<p><code>:out</code> transforms are applied to values coming out of the database; since nothing weird really happens there this is
done consistently.</p>

<p>Transform functions for either case are skipped for <code>nil</code> values.</p>

<p>Example:</p>

<p>```clj
(deftransforms :models/user
  {:type {:in name, :out keyword}})
```</p>

<p>You can also define transforms independently, and derive a model from them:</p>

<p>```clj
(deftransforms ::type-keyword
  {:type {:in name, :out keyword}})</p>

<p>(derive :models/user ::type-keyword)
(derive :models/user ::some-other-transform)
```</p>

<p>Don't derive a model from multiple [[deftransforms]] for the same key in the same direction.</p>

<p>When multiple transforms match a given model they are combined into a single map of transforms with `merge-with
merge`. If multiple transforms match a given column in a given direction, only one of them will be used; you should
assume which one is used is indeterminate. (This may be made an error, or at least a warning, in the future.)</p>

<p>Until upstream issue https://github.com/camsaul/methodical/issues/97 is resolved, you will have to specify which
method should be applied first in cases of ambiguity using [[methodical.core/prefer-method!]]:</p>

<p>```clj
(m/prefer-method! transforms ::user-with-location ::user-with-password)
```</p>

<p>If you want to override transforms completely for a model, and ignore transforms from ancestors of a model, you can
create an <code>:around</code> method:</p>

<p>```clj
(m/defmethod toucan2.tools.transforms :around ::my-model
  [_model]
  {:field {:in name, :out keyword}})
```</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro deftransforms
  {:style/indent 1}
  [model column-&gt;direction-&gt;fn]
  `(do
     (u/maybe-derive ~model ::transformed.model)
     (m/defmethod transforms ~model
       [~'model]
       ~column-&gt;direction-&gt;fn)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef deftransforms
  :args (s/cat :model      some?
               :transforms any?)
  :ret any?)</pre></td></tr><tr><td class="docs"><p>apply results transforms before [[toucan2.tools.after-update]] or [[toucan2.tools.after-insert]]</p>
</td><td class="codes"><pre class="brush: clojure">(m/prefer-method! #'pipeline/results-transform
                  [:toucan.result-type/instances ::transformed.model]
                  [:toucan.result-type/instances :toucan2.tools.after/model])</pre></td></tr><tr><td class="docs"><p>apply results transforms before [[toucan2.tools.after-select]]</p>
</td><td class="codes"><pre class="brush: clojure">(m/prefer-method! #'pipeline/results-transform
                  [:toucan.result-type/instances ::transformed.model]
                  [:toucan.result-type/instances :toucan2.tools.after-select/after-select])</pre></td></tr><tr><td class="docs"><p>apply transforms before applying the [[toucan2.tools.default-fields]] functions</p>
</td><td class="codes"><pre class="brush: clojure">(m/prefer-method! #'pipeline/results-transform
                  [:toucan.result-type/instances ::transformed.model]
                  [:toucan.result-type/instances :toucan2.tools.default-fields/default-fields])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.tools.with-temp" name="toucan2.tools.with-temp"><h1 class="project-name">toucan2.tools.with-temp</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.tools.with-temp
  (:require
   [clojure.pprint :as pprint]
   [clojure.spec.alpha :as s]
   [clojure.test :as t]
   [methodical.core :as m]
   [toucan2.delete :as delete]
   [toucan2.insert :as insert]
   [toucan2.log :as log]
   [toucan2.model :as model]
   [toucan2.types :as types]
   [toucan2.util :as u]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment types/keep-me)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmulti with-temp-defaults
  {:arglists            '([model])
   :defmethod-arities   #{1}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod with-temp-defaults :default
  [_model]
  nil)</pre></td></tr><tr><td class="docs"><p>Implementation of [[with-temp]]. You can implement this if you need to do some sort of special behavior for a
particular model. But normally you would just implement [[with-temp-defaults]]. If you need to do special setup when
using [[with-temp]], you can implement a <code>:before</code> method:</p>

<p>```clj
(m/defmethod do-with-temp* :before :default
  [_model _explicit-attributes f]
  (set-up-db!)
  f)
```</p>

<p><code>explicit-attributes</code> are the attributes specified in the <code>with-temp</code> form itself, any may be <code>nil</code>. The default
implementation merges the attributes from [[with-temp-defaults]] like</p>

<p>```clj
(merge {} (with-temp-defaults model) explict-attributes)
```</p>
</td><td class="codes"><pre class="brush: clojure">(m/defmulti do-with-temp*
  {:arglists            '([model explicit-attributes f])
   :defmethod-arities   #{3}
   :dispatch-value-spec (s/nonconforming ::types/dispatch-value.model)}
  u/dispatch-on-first-arg)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod do-with-temp* :default
  [model explicit-attributes f]
  (assert (some? model) (format &quot;%s model cannot be nil.&quot; `with-temp))
  (when (some? explicit-attributes)
    (assert (map? explicit-attributes) (format &quot;attributes passed to %s must be a map.&quot; `with-temp)))
  (let [defaults          (with-temp-defaults model)
        merged-attributes (merge {} defaults explicit-attributes)]
    (u/try-with-error-context [&quot;with temp&quot; {::model               model
                                            ::explicit-attributes explicit-attributes
                                            ::default-attributes  defaults
                                            ::merged-attributes   merged-attributes}]
      (log/debugf &quot;Create temporary %s with attributes %s&quot; model merged-attributes)
      (let [temp-object (first (insert/insert-returning-instances! model merged-attributes))]
        (log/debugf &quot;[with-temp] =&gt; %s&quot; temp-object)
        (try
          (t/testing (format &quot;\nwith temporary %s with attributes\n%s\n&quot;
                             (pr-str model)
                             (with-out-str (pprint/pprint merged-attributes)))
            (f temp-object))
          (finally
            (delete/delete! model :toucan/pk ((model/select-pks-fn model) temp-object))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn do-with-temp [modelable attributes f]
  (let [model (model/resolve-model modelable)]
    (do-with-temp* model attributes f)))</pre></td></tr><tr><td class="docs"><p>Define a temporary instance of a model and bind it to <code>temp-object-binding</code>. The object is inserted
using [[insert/insert-returning-instances!]] using the values from [[with-temp-defaults]] merged with a map of
<code>attributes</code>. At the conclusion of <code>body</code>, the object is deleted. This is primarily intended for usage in tests, so
this adds a [[clojure.test/testing]] context around <code>body</code> as well.</p>

<p>[[with-temp]] can create multiple objects in one form if you pass additional bindings.</p>

<p><code>temp-object-binding</code> and <code>attributes</code> are optional, and default to <code>_</code> and <code>nil</code>, respectively. If you're creating
multiple objects at once these must be explicitly specified.</p>

<p>Examples:</p>

<p>```clj
;;; use the with-temp-defaults for :models/bird
(with-temp [:models/bird bird]
  (do-something bird))</p>

<p>;;; use the with-temp-defaults for :models/bird merged with {:name "Lucky Pigeon"}
(with-temp [:models/bird bird {:name "Lucky Pigeon"}]
  (do-something bird))</p>

<p>;;; define multiple instances at the same time
(with-temp [:models/bird bird-1 {:name "Parroty"}
            :models/bird bird-2 {:name "Green Friend", :best-friend-id (:id bird-1)}]
  (do-something bird))
```</p>

<p>If you want to implement custom behavior for a model other than default values, you can implement [[do-with-temp*]].</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-temp
  {:style/indent :defn}
  [[modelable temp-object-binding attributes &amp; more] &amp; body]
  `(do-with-temp ~modelable ~attributes
                 (^:once fn* [temp-object#]
                  (let [~(or temp-object-binding '_) temp-object#]
                    ~(if (seq more)
                       `(with-temp ~(vec more) ~@body)
                       `(do ~@body))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef with-temp
  :args (s/cat :bindings (s/spec (s/cat
                                  :model+binding+attributes
                                  (s/* (s/cat :model      some?
                                              :binding    :clojure.core.specs.alpha/binding-form
                                              :attributes any?))

                                  :model+optional
                                  (s/cat :model    some?
                                         :optional (s/? (s/cat :binding    :clojure.core.specs.alpha/binding-form
                                                               :attributes (s/? any?))))))
               :body     (s/* any?))
  :ret  any?)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.types" name="toucan2.types"><h1 class="project-name">toucan2.types</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Toucan 2 query type hierarchy.</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.types
  (:require [clojure.spec.alpha :as s]))</pre></td></tr><tr><td class="docs"><p>the query type hierarchy below is used for pipeline methods and tooling to decide what sort of things they need to
do -- for example you should not do row-map transformations to a query that returns an update count.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(derive :toucan.query-type/select.* :toucan.query-type/*)
(derive :toucan.query-type/insert.* :toucan.query-type/*)
(derive :toucan.query-type/update.* :toucan.query-type/*)
(derive :toucan.query-type/delete.* :toucan.query-type/*)</pre></td></tr><tr><td class="docs"><p><code>DML</code> (Data manipulation language) here means things like <code>UPDATE</code>, <code>DELETE</code>, or <code>INSERT</code>. Some goofballs include
<code>SELECT</code> in this category, but we are not! We are calling <code>SELECT</code> a <code>DQL</code> (Data Query Language) statement. There
are other types of queries like <code>DDL</code> (Data Definition Language, e.g. <code>CREATE TABLE</code>), but Toucan 2 doesn't
currently have any tooling around those. Stuff like [[toucan2.execute/query]] that could potentially execute those
don't care what kind of query you're executing anyway.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(derive :toucan.statement-type/DML :toucan.statement-type/*)
(derive :toucan.statement-type/DQL :toucan.statement-type/*)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(derive :toucan.query-type/select.* :toucan.statement-type/DQL)
(derive :toucan.query-type/insert.* :toucan.statement-type/DML)
(derive :toucan.query-type/update.* :toucan.statement-type/DML)
(derive :toucan.query-type/delete.* :toucan.statement-type/DML)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(derive :toucan.result-type/instances    :toucan.result-type/*)
(derive :toucan.result-type/pks          :toucan.result-type/*)
(derive :toucan.result-type/update-count :toucan.result-type/*)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doto :toucan.query-type/select.instances
  (derive :toucan.query-type/select.*)
  (derive :toucan.result-type/instances))</pre></td></tr><tr><td class="docs"><p>[[toucan2.select/select-fn-set]] and [[toucan2.select/select-fn-vec]] queries -- we are applying a specific function
transform to the results, so we don't want to apply a default fields transform or other stuff like that.</p>
</td><td class="codes"><pre class="brush: clojure">(derive :toucan.query-type/select.instances.fns :toucan.query-type/select.instances)</pre></td></tr><tr><td class="docs"><p>A special query type that is just supposed to return the count of matching rows rather than the actual matching
rows. This is used to implement [[toucan2.select/count]]. Query compilation backends should build something that
returns a row with the key <code>:count</code>.</p>

<p>If the query does not return a row with the key <code>:count</code>, [[toucan2.select/count]] will count up all the rows
returned.</p>
</td><td class="codes"><pre class="brush: clojure">(derive :toucan.query-type/select.count :toucan.query-type/select.instances.fns)</pre></td></tr><tr><td class="docs"><p>A special query type that should just return whether or not <em>any</em> rows matching the conditions exist. Used to
implement [[toucan2.select/exists?]]. Similar to <code>:toucan.query-type/select.count</code>, but this should return a result
row with the key <code>:exists</code>, which may be either a boolean or integer (positive = truthy).</p>

<p>If the query does not return a row with the key <code>:exists</code>, [[toucan2.select/exists?]] will simply check whether or
not a row is returned.</p>
</td><td class="codes"><pre class="brush: clojure">(derive :toucan.query-type/select.exists :toucan.query-type/select.instances.fns)</pre></td></tr><tr><td class="docs"><p>A special subtype of a SELECT query that should use the syntax of update. Used to
power [[toucan2.tools.before-update]].</p>

<p>The difference is that update is supposed to treat a resolved query map as a conditions map rather than a Honey SQL
form.</p>
</td><td class="codes"><pre class="brush: clojure">(derive :toucan.query-type/select.instances.from-update :toucan.query-type/select.instances)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doto :toucan.query-type/insert.update-count
  (derive :toucan.query-type/insert.*)
  (derive :toucan.result-type/update-count))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doto :toucan.query-type/insert.pks
  (derive :toucan.query-type/insert.*)
  (derive :toucan.result-type/pks))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doto :toucan.query-type/insert.instances
  (derive :toucan.query-type/insert.*)
  (derive :toucan.result-type/instances))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doto :toucan.query-type/update.update-count
  (derive :toucan.query-type/update.*)
  (derive :toucan.result-type/update-count))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doto :toucan.query-type/update.pks
  (derive :toucan.query-type/update.*)
  (derive :toucan.result-type/pks))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doto :toucan.query-type/update.instances
  (derive :toucan.query-type/update.*)
  (derive :toucan.result-type/instances))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doto :toucan.query-type/delete.update-count
  (derive :toucan.query-type/delete.*)
  (derive :toucan.result-type/update-count))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doto :toucan.query-type/delete.pks
  (derive :toucan.query-type/delete.*)
  (derive :toucan.result-type/pks))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(doto :toucan.query-type/delete.instances
  (derive :toucan.query-type/delete.*)
  (derive :toucan.result-type/instances))</pre></td></tr><tr><td class="docs"><p>The following are 'special' types only used in SPECIAL situations.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A select query that is done with PKs fetched directly from that database. These don't need to be transformed.</p>
</td><td class="codes"><pre class="brush: clojure">(derive :toucan.query-type/select.instances-from-pks :toucan.query-type/select.instances)</pre></td></tr><tr><td class="docs"><p>True if <code>query-type</code> derives from one of the various abstract query keywords such as <code>:toucan.result-type/*</code> or
<code>:toucan.query-type/*</code>. This does not guarantee that the query type is a 'concrete', just that it is something with
some sort of query type information.</p>
</td><td class="codes"><pre class="brush: clojure">(defn query-type?
  [query-type]
  (some (fn [abstract-type]
          (isa? query-type abstract-type))
        [:toucan.result-type/*
         :toucan.query-type/*
         :toucan.statement-type/*]))</pre></td></tr><tr><td class="docs"><p>utils</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parent-query-type [query-type]
  (some (fn [k]
          (when (isa? k :toucan.query-type/*)
            k))
        (parents query-type)))</pre></td></tr><tr><td class="docs"><p>E.g. something like <code>:toucan.query-type/insert.*</code>. The immediate descendant of <code>:toucan.query-type/*</code>.</p>

<p>```clj
(base-query-type :toucan.query-type/insert.instances)
=>
:toucan.query-type/insert.*
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn base-query-type
  [query-type]
  (when (isa? query-type :toucan.query-type/*)
    (loop [last-query-type nil, query-type query-type]
      (if (or (= query-type :toucan.query-type/*)
              (not query-type))
        last-query-type
        (recur query-type (parent-query-type query-type))))))</pre></td></tr><tr><td class="docs"><p>```clj
(similar-query-type-returning :toucan.query-type/insert.instances :toucan.result-type/pks)
=>
:toucan.query-type/insert.pks
```</p>
</td><td class="codes"><pre class="brush: clojure">(defn similar-query-type-returning
  [query-type result-type]
  (let [base-type (base-query-type query-type)]
    (some (fn [descendant]
            (when (and ((parents descendant) base-type)
                       (isa? descendant result-type))
              descendant))
          (descendants base-type))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::dispatch-value.default
  (partial = :default))</pre></td></tr><tr><td class="docs"><p>Helper for creating a spec that also accepts the <code>:default</code> keyword.</p>
</td><td class="codes"><pre class="brush: clojure">(defn or-default-spec
  [spec]
  (s/nonconforming
   (s/or :default     ::dispatch-value.default
         :non-default spec)))</pre></td></tr><tr><td class="docs"><p><code>:toucan.query-type/abstract</code> exists for things that aren't actually supposed to go in the query type hierarchy, but
we want to be able to derive other query types FROM them. See [[toucan2.tools.after]] and
<code>:toucan2.tools.after/query-type</code> for example.</p>
</td><td class="codes"><pre class="brush: clojure">(s/def ::dispatch-value.query-type
  (or-default-spec
   (s/or :abstract-query-type #(isa? % :toucan.query-type/abstract)
         :query-type          query-type?)))</pre></td></tr><tr><td class="docs"><p>technically <code>nil</code> is valid and it's not read in as a Symbol</p>

<p>What about (Class/forName "...") forms? Those are valid classes...</p>
</td><td class="codes"><pre class="brush: clojure">(s/def ::dispatch-value.keyword-or-class
  (some-fn keyword? symbol? nil?))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::dispatch-value.model
  ::dispatch-value.keyword-or-class)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::dispatch-value.query
  ::dispatch-value.keyword-or-class)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::dispatch-value.query-type-model
  (or-default-spec
   (s/cat :query-type ::dispatch-value.query-type
          :model      ::dispatch-value.model)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/def ::dispatch-value.query-type-model-query
  (or-default-spec
   (s/cat :query-type ::dispatch-value.query-type
          :model      ::dispatch-value.model
          :query      ::dispatch-value.query)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.update" name="toucan2.update"><h1 class="project-name">toucan2.update</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation of [[update!]].</p>
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.update
  (:require
   [clojure.spec.alpha :as s]
   [methodical.core :as m]
   [toucan2.log :as log]
   [toucan2.pipeline :as pipeline]
   [toucan2.query :as query]))</pre></td></tr><tr><td class="docs"><p>this is basically the same as the args for <code>select</code> and <code>delete</code> but the difference is that it has an additional
optional arg, <code>:pk</code>, as the second arg, and one additional optional arg, the <code>changes</code> map at the end</p>
</td><td class="codes"><pre class="brush: clojure">(s/def ::args
  (s/cat
   :connectable ::query/default-args.connectable
   :modelable   ::query/default-args.modelable
   :pk          (s/? (complement (some-fn keyword? map?)))
   ;; these are treated as CONDITIONS
   :kv-args     ::query/default-args.kv-args
   ;; by default, assuming this resolves to a map query, is treated as a map of conditions.
   :queryable   ::query/default-args.queryable
   ;; TODO -- This should support named changes maps too. Also,
   :changes     map?))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod query/parse-args :toucan.query-type/update.*
  [query-type unparsed-args]
  (let [parsed (query/parse-args-with-spec query-type ::args unparsed-args)]
    (cond-&gt; parsed
      (contains? parsed :pk) (-&gt; (dissoc :pk)
                                 (update :kv-args assoc :toucan/pk (:pk parsed))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(m/defmethod pipeline/build [#_query-type :toucan.query-type/update.*
                             #_model      :default
                             #_query      :default]
  &quot;Default method for building UPDATE queries. Code for building Honey SQL for UPDATE lives
  in [[toucan2.honeysql2]].
  This doesn't really do much, but if the query has no `:changes`, returns the special flag `:toucan2.pipeline/no-op`.&quot;
  [query-type model {:keys [changes], :as parsed-args} resolved-query]
  (if (empty? changes)
    (do
      (log/debugf &quot;Query has no changes, skipping update&quot;)
      ::pipeline/no-op)
    (next-method query-type model parsed-args resolved-query)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reducible-update
  {:arglists '([modelable pk? conditions-map-or-query? &amp; conditions-kv-args changes-map])}
  [&amp; unparsed-args]
  (pipeline/reducible-unparsed :toucan.query-type/update.update-count unparsed-args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn update!
  {:arglists '([modelable pk? conditions-map-or-query? &amp; conditions-kv-args changes-map])}
  [&amp; unparsed-args]
  (pipeline/transduce-unparsed-with-default-rf :toucan.query-type/update.update-count unparsed-args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reducible-update-returning-pks
  {:arglists '([modelable pk? conditions-map-or-query? &amp; conditions-kv-args changes-map])}
  [&amp; unparsed-args]
  (pipeline/reducible-unparsed :toucan.query-type/update.pks unparsed-args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn update-returning-pks!
  {:arglists '([modelable pk? conditions-map-or-query? &amp; conditions-kv-args changes-map])}
  [&amp; unparsed-args]
  (pipeline/transduce-unparsed-with-default-rf :toucan.query-type/update.pks unparsed-args))</pre></td></tr><tr><td class="docs"><p>TODO -- add <code>update-returning-instances!</code>, similar to [[toucan2.update/insert-returning-instances!]]</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#toucan2.util" name="toucan2.util"><h1 class="project-name">toucan2.util</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns toucan2.util
  (:require
   [camel-snake-kebab.core :as csk]
   [clojure.spec.alpha :as s]
   [clojure.walk :as walk]
   [methodical.util.dispatch :as m.dispatch]
   [pretty.core :as pretty]
   [toucan2.protocols :as protocols])
  (:import
   (clojure.lang IPersistentMap)
   (potemkin.collections PotemkinMap)))</pre></td></tr><tr><td class="docs"><p>TODO -- there is a lot of repeated code in here to make sure we don't accidentally realize and print <code>IReduceInit</code>,
and at least 3 places we turn an <code>eduction</code> into the same pretty form. Maybe we should try to consolidate some of
that logic.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(set! *warn-on-reflection* true)</pre></td></tr><tr><td class="docs"><p>Dispatch on the first argument using [[dispatch-value]], and ignore all other args.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:arglists '([x &amp; _])} dispatch-on-first-arg
  (m.dispatch/dispatch-on-first-arg #'protocols/dispatch-value))</pre></td></tr><tr><td class="docs"><p>Dispatch on the two arguments using [[protocols/dispatch-value]], and ignore all other args.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:arglists '([x y &amp; _])} dispatch-on-first-two-args
  (m.dispatch/dispatch-on-first-two-args #'protocols/dispatch-value))</pre></td></tr><tr><td class="docs"><p>Dispatch on the three arguments using [[protocols/dispatch-value]], and ignore all other args.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:arglists '([x y z &amp; _])} dispatch-on-first-three-args
  (m.dispatch/dispatch-on-first-three-args #'protocols/dispatch-value))</pre></td></tr><tr><td class="docs"><p>Locale-agnostic version of [[clojure.string/lower-case]]. <code>clojure.string/lower-case</code> uses the default locale in
conversions, turning <code>ID</code> into <code>d</code>, in the Turkish locale. This function always uses the <code>Locale/US</code> locale.</p>
</td><td class="codes"><pre class="brush: clojure">(defn lower-case-en
  [^CharSequence s]
  (.. s toString (toLowerCase (java.util.Locale/US))))</pre></td></tr><tr><td class="docs"><p>Derive <code>child</code> from <code>parent</code> only if <code>child</code> is not already a descendant of <code>parent</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn maybe-derive
  [child parent]
  (when-not (isa? child parent)
    (derive child parent)))</pre></td></tr><tr><td class="docs"><p>[[try-with-error-context]]</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>TODO -- I don't love this stuff anymore, need to rework it at some point.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ^:private AddContext
  (^:no-doc add-context ^Throwable [^Throwable e additional-context]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- add-context-to-ex-data [ex-data-map additional-context]
  (update ex-data-map
          :toucan2/context-trace
          #(conj (vec %) (walk/prewalk
                          (fn [form]
                            (cond
                              (instance? pretty.core.PrettyPrintable form)
                              (pretty/pretty form)
                              (instance? clojure.core.Eduction form)
                              (list 'eduction
                                    (.xform ^clojure.core.Eduction form)
                                    (.coll ^clojure.core.Eduction form))
                              (and (instance? clojure.lang.IReduceInit form)
                                   (not (coll? form)))
                              (class form)
                              :else
                              form))
                          additional-context))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol AddContext
  clojure.lang.ExceptionInfo
  (add-context [^Throwable e additional-context]
    (if (empty? additional-context)
      e
      (doto ^Throwable (ex-info (ex-message e)
                                (add-context-to-ex-data (ex-data e) additional-context)
                                (ex-cause e))
        (.setStackTrace (.getStackTrace e)))))

  Throwable
  (add-context [^Throwable e additional-context]
    (if (empty? additional-context)
      e
      (doto ^Throwable (ex-info (ex-message e)
                                (add-context-to-ex-data {} additional-context)
                                e)
        (.setStackTrace (.getStackTrace e))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro try-with-error-context
  {:style/indent :defn}
  [additional-context &amp; body]
  `(try
     ~@body
     (catch Exception e#
       (throw (add-context e# ~additional-context)))
     (catch AssertionError e#
       (throw (add-context e# ~additional-context)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(s/fdef try-with-error-context
  :args (s/cat :additional-context (s/alt :message+map (s/spec (s/cat :message string?
                                                                      :map     map?))
                                          ;; some sort of function call or something like that.
                                          :form        seqable?)
               :body               (s/+ any?))
  :ret  any?)</pre></td></tr><tr><td class="docs"><p>Like <code>camel-snake-kebab.core/-&gt;kebab-case</code>, but supports namespaced keywords.</p>
</td><td class="codes"><pre class="brush: clojure">(defn -&gt;kebab-case
  [x]
  (if (and (keyword? x) (namespace x))
    (keyword (csk/-&gt;kebab-case (namespace x))
             (csk/-&gt;kebab-case (name x)))
    (csk/-&gt;kebab-case x)))</pre></td></tr><tr><td class="docs"><p>Is this a map a transient row, or created using p/def-map-type? This includes Instances.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol IsCustomMap
  (custom-map? [m]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol IsCustomMap
  IPersistentMap
  (custom-map? [_] false)

  PotemkinMap
  (custom-map? [_] true))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/clj-commons/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a><div id="floating-toc"><ul><li class="floating-toc-li" id="floating-toc_toucan2.connection">toucan2.connection</li><li class="floating-toc-li" id="floating-toc_toucan2.core">toucan2.core</li><li class="floating-toc-li" id="floating-toc_toucan2.delete">toucan2.delete</li><li class="floating-toc-li" id="floating-toc_toucan2.execute">toucan2.execute</li><li class="floating-toc-li" id="floating-toc_toucan2.honeysql2">toucan2.honeysql2</li><li class="floating-toc-li" id="floating-toc_toucan2.insert">toucan2.insert</li><li class="floating-toc-li" id="floating-toc_toucan2.instance">toucan2.instance</li><li class="floating-toc-li" id="floating-toc_toucan2.jdbc">toucan2.jdbc</li><li class="floating-toc-li" id="floating-toc_toucan2.jdbc.connection">toucan2.jdbc.connection</li><li class="floating-toc-li" id="floating-toc_toucan2.jdbc.mysql-mariadb">toucan2.jdbc.mysql-mariadb</li><li class="floating-toc-li" id="floating-toc_toucan2.jdbc.options">toucan2.jdbc.options</li><li class="floating-toc-li" id="floating-toc_toucan2.jdbc.pipeline">toucan2.jdbc.pipeline</li><li class="floating-toc-li" id="floating-toc_toucan2.jdbc.postgres">toucan2.jdbc.postgres</li><li class="floating-toc-li" id="floating-toc_toucan2.jdbc.query">toucan2.jdbc.query</li><li class="floating-toc-li" id="floating-toc_toucan2.jdbc.read">toucan2.jdbc.read</li><li class="floating-toc-li" id="floating-toc_toucan2.jdbc.result-set">toucan2.jdbc.result-set</li><li class="floating-toc-li" id="floating-toc_toucan2.jdbc.row">toucan2.jdbc.row</li><li class="floating-toc-li" id="floating-toc_toucan2.log">toucan2.log</li><li class="floating-toc-li" id="floating-toc_toucan2.model">toucan2.model</li><li class="floating-toc-li" id="floating-toc_toucan2.pipeline">toucan2.pipeline</li><li class="floating-toc-li" id="floating-toc_toucan2.protocols">toucan2.protocols</li><li class="floating-toc-li" id="floating-toc_toucan2.query">toucan2.query</li><li class="floating-toc-li" id="floating-toc_toucan2.realize">toucan2.realize</li><li class="floating-toc-li" id="floating-toc_toucan2.save">toucan2.save</li><li class="floating-toc-li" id="floating-toc_toucan2.select">toucan2.select</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.after">toucan2.tools.after</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.after-insert">toucan2.tools.after-insert</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.after-select">toucan2.tools.after-select</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.after-update">toucan2.tools.after-update</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.before-delete">toucan2.tools.before-delete</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.before-insert">toucan2.tools.before-insert</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.before-select">toucan2.tools.before-select</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.before-update">toucan2.tools.before-update</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.compile">toucan2.tools.compile</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.debug">toucan2.tools.debug</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.default-fields">toucan2.tools.default-fields</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.disallow">toucan2.tools.disallow</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.hydrate">toucan2.tools.hydrate</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.identity-query">toucan2.tools.identity-query</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.named-query">toucan2.tools.named-query</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.simple-out-transform">toucan2.tools.simple-out-transform</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.transformed">toucan2.tools.transformed</li><li class="floating-toc-li" id="floating-toc_toucan2.tools.with-temp">toucan2.tools.with-temp</li><li class="floating-toc-li" id="floating-toc_toucan2.types">toucan2.types</li><li class="floating-toc-li" id="floating-toc_toucan2.update">toucan2.update</li><li class="floating-toc-li" id="floating-toc_toucan2.util">toucan2.util</li></ul></div></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
SyntaxHighlighter.all();

// hackity hack
$(window).load(function() {
    var ft = $("#floating-toc");
    var ul = ft.find('ul');
    var lis = ft.find('li');
    var liHeight = $(lis.first()).height();

    ul.css('margin', '0px');
    ft.css('height', liHeight + 'px');

    showNs = function(ns) {
        var index = 0;

        for(i in nsPositions.nss) {
            if(ns == nsPositions.nss[i]) index = i;
        }

        if(index != lastNsIndex) {
            lastNsIndex = index;
            ul.animate({marginTop: (-1 * liHeight * index) + 'px'},
               300);
        }

    }

    var calcNsPositions = function() {
        var hheight = $('.docs-header').first().height();
        var nss = [];
        var anchors = [];
        var positions = [];
        $.each(lis, function(i, el) {
            var ns = $(el).attr('id').split('_')[1];
            nss.push(ns);
            var a = $("a[name='"+ns+"']");
            anchors.push(a);
            positions.push(a.offset().top - hheight);
            // console.log(a.offset().top)
        });

        return {nss: nss, positions: positions};
    }

    var nsPositions = calcNsPositions();
    // console.log(nsPositions)
    var lastNsIndex = -1;
    var $window = $(window);

    var currentSection = function(nsp) {
        var ps = nsp.positions;
        var scroll = $window.scrollTop();
        var nsIndex = -1;

        for(var i = 0, length = ps.length; i < length; i++) {
            if(ps[i] >= scroll) {
                nsIndex = i-1;
                break;
            }
        }

        if(nsIndex == -1) {
             if(scroll >= ps[0]) {
                 nsIndex = ps.length - 1;
             } else {
                 nsIndex = 0;
             }
        }

        return nsp.nss[nsIndex];
    }

    $(window).scroll(function(e) {
        showNs(currentSection(nsPositions));
    });
});
</script></body></html>